From 07b35c4724214807960df1f669d3aea7433274cd Mon Sep 17 00:00:00 2001
Message-Id: <07b35c4724214807960df1f669d3aea7433274cd.1241484428.git.john.williams@petalogix.com>
In-Reply-To: <930a7bf07b58a3d6a48393a6419b2c958fc9dc2a.1241484427.git.john.williams@petalogix.com>
References: <930a7bf07b58a3d6a48393a6419b2c958fc9dc2a.1241484427.git.john.williams@petalogix.com>
From: John Williams <john.williams@petalogix.com>
Date: Tue, 28 Apr 2009 14:39:36 +1000
Subject: [PATCH 29/63] microblaze: Fix options passing in gcc

---
 gcc/Makefile.in           |   19 +-
 gcc/Makefile.in.orig      | 4616 +++++++++++++++++++++++++++
 gcc/common.opt            |   14 +-
 gcc/config/i386/i386.opt  |    4 +-
 gcc/cp/Make-lang.in       |    2 +-
 gcc/fortran/Make-lang.in  |    2 +-
 gcc/gcc.c                 |    3 +
 gcc/gcc.c.orig            | 7757 +++++++++++++++++++++++++++++++++++++++++++++
 gcc/java/Make-lang.in     |    4 +-
 gcc/optc-gen.awk          |   57 +-
 gcc/opts-common.c         |  237 ++
 gcc/opts.c                |   85 -
 gcc/opts.h                |    3 +
 gcc/treelang/Make-lang.in |    4 +-
 14 files changed, 12689 insertions(+), 118 deletions(-)
 create mode 100644 gcc/Makefile.in.orig
 create mode 100644 gcc/gcc.c.orig
 create mode 100644 gcc/opts-common.c

diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 96a55ad..d01da20 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -934,6 +934,9 @@ C_TARGET_OBJS=@c_target_objs@
 # Target specific, C++ specific object file
 CXX_TARGET_OBJS=@cxx_target_objs@
 
+# Object files for gcc driver.
+GCC_OBJS = gcc.o opts-common.o options.o
+
 # Language-specific object files for C and Objective C.
 C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
@@ -973,7 +976,7 @@ OBJS-common = \
  haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-modes.o	   \
  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o	   \
  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  	   \
- loop.o mode-switching.o modulo-sched.o optabs.o options.o opts.o	   \
+ loop.o mode-switching.o modulo-sched.o optabs.o options.o opts.o opts-common.o \
  params.o postreload.o postreload-gcse.o predict.o			   \
  insn-preds.o pointer-set.o 					   	   \
  print-rtl.o print-tree.o profile.o value-prof.o var-tracking.o		   \
@@ -1218,17 +1221,17 @@ libbackend.a: $(OBJS@onestep@)
 # We call this executable `xgcc' rather than `gcc'
 # to avoid confusion if the current directory is in the path
 # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
-xgcc$(exeext): gcc.o gccspec.o version.o intl.o prefix.o \
+xgcc$(exeext): $(GCC_OBJS) gccspec.o version.o intl.o prefix.o \
    version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
-	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o gccspec.o intl.o \
-	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) gccspec.o \
+	  intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
 
 # cpp is to cpp0 as gcc is to cc1.
 # The only difference from xgcc is that it's linked with cppspec.o
 # instead of gccspec.o.
-cpp$(exeext): gcc.o cppspec.o version.o intl.o prefix.o \
+cpp$(exeext): $(GCC_OBJS) cppspec.o version.o intl.o prefix.o \
    version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
-	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o cppspec.o intl.o \
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) cppspec.o intl.o \
 	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
 
 # Create links to binutils, especially for in-tree builds, to make -B.
@@ -1611,7 +1614,7 @@ DRIVER_DEFINES = \
 
 gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
     Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \
-    configargs.h $(OBSTACK_H)
+    configargs.h $(OBSTACK_H) opts.h
 	(SHLIB_LINK='$(SHLIB_LINK)' \
 	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
 	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
@@ -2024,6 +2027,8 @@ opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \
    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \
    $(FLAGS_H) $(PARAMS_H) tree-pass.h
+opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h intl.h
 targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
    $(EXPR_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h output.h toplev.h \
    $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H) $(GGC_H) gt-targhooks.h
diff --git a/gcc/Makefile.in.orig b/gcc/Makefile.in.orig
new file mode 100644
index 0000000..96a55ad
--- /dev/null
+++ b/gcc/Makefile.in.orig
@@ -0,0 +1,4616 @@
+# Makefile for GNU Compiler Collection
+# Run 'configure' to generate Makefile from Makefile.in
+
+# Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
+# 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify
+#it under the terms of the GNU General Public License as published by
+#the Free Software Foundation; either version 2, or (at your option)
+#any later version.
+
+#GCC is distributed in the hope that it will be useful,
+#but WITHOUT ANY WARRANTY; without even the implied warranty of
+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#GNU General Public License for more details.
+
+#You should have received a copy of the GNU General Public License
+#along with GCC; see the file COPYING.  If not, write to
+#the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+#Boston MA 02110-1301, USA.
+
+# The targets for external use include:
+# all, doc, proto, install, install-cross, install-cross-rest,
+# uninstall, TAGS, mostlyclean, clean, distclean, maintainer-clean,
+# stage1, stage2, stage3, stage4.
+
+# This is the default target.
+# Set by autoconf to "all.internal" for a native build, or
+# "all.cross" to build a cross compiler.
+all: @ALL@
+
+# Depend on this to specify a phony target portably.
+force:
+
+# This tells GNU make version 3 not to export the variables
+# defined in this file into the environment (and thus recursive makes).
+.NOEXPORT:
+# And this tells it not to automatically pass command-line variables
+# to recursive makes.
+MAKEOVERRIDES =
+
+# Suppress smart makes who think they know how to automake yacc and flex file
+.y.c:
+.l.c:
+
+# The only suffixes we want for implicit rules are .c and .o, so clear
+# the list and add them.  This speeds up GNU Make, and allows -r to work.
+# For i18n support, we also need .gmo, .po, .pox.
+# This must come before the language makefile fragments to allow them to
+# add suffixes and rules of their own.
+.SUFFIXES:
+.SUFFIXES: .c .o .po .pox .gmo
+
+# -------------------------------
+# Standard autoconf-set variables
+# -------------------------------
+
+build=@build@
+host=@host@
+target=@target@
+target_noncanonical:=@target_noncanonical@
+
+# Sed command to transform gcc to installed name.
+program_transform_name := @program_transform_name@
+
+# -----------------------------
+# Directories used during build
+# -----------------------------
+
+# Directory where sources are, from where we are.
+srcdir = @srcdir@
+docdir = @srcdir@/doc
+
+# Directory where sources are, absolute.
+abs_srcdir = @abs_srcdir@
+abs_docdir = @abs_srcdir@/doc
+
+# Top build directory for this package, relative to here.
+top_builddir = .
+# objdir is set by configure.
+# It's normally the absolute path to the current directory.
+objdir = @objdir@
+
+host_subdir=@host_subdir@
+build_subdir=@build_subdir@
+
+ifeq ($(host_subdir),.)
+build_objdir := ../$(build_subdir)
+else
+build_objdir := ../../$(build_subdir)
+endif
+
+# --------
+# Defined vpaths
+# --------
+
+# Directory where sources are, from where we are.
+VPATH = @srcdir@
+
+# We define a vpath for the sources of the .texi files here because they
+# are split between multiple directories and we would rather use one implicit
+# pattern rule for everything.
+# This vpath could be extended within the Make-lang fragments.
+
+vpath %.texi $(docdir):$(docdir)/include
+
+# ----
+# Default values for variables overridden in Makefile fragments.
+# These need to be quite early in the Makefile so as to avoid
+# trouble induced by changes in fragment ordering.
+# ----
+
+# For ada/Make-lang.in; overridden in, for example, config/pa/x-ada.
+X_ADA_CFLAGS =
+T_ADA_CFLAGS =
+X_ADAFLAGS =
+T_ADAFLAGS =
+
+# --------
+# UNSORTED
+# --------
+
+# Variables that exist for you to override.
+# See below for how to change them for certain systems.
+
+# List of language subdirectories.
+SUBDIRS =@subdirs@ build
+
+# Selection of languages to be made.
+CONFIG_LANGUAGES = @all_languages@
+LANGUAGES = c gcov$(exeext) gcov-dump$(exeext) $(CONFIG_LANGUAGES)
+
+# Selection of languages to be made during stage1 build.
+BOOT_LANGUAGES = c @all_boot_languages@
+
+# Various ways of specifying flags for compilations:
+# CFLAGS is for the user to override to, e.g., do a cross build with -O2.
+# For recursive  bootstrap builds CFLAGS is used to pass in STAGE1_CFLAGS
+# or BOOT_CFLAGS
+# STAGE1_CFLAGS is set by configure on some targets or passed from toplevel
+# and sets the CFLAGS passed to stage1 of a bootstrap compilation.
+# STAGE1_CHECKING enables checking for the stage1 compiler
+# BOOT_CFLAGS is the value of CFLAGS to pass to the stage2, stage3 and stage4
+# bootstrap compilations.
+# XCFLAGS is used for most compilations but not when using the GCC just built.
+# TCFLAGS is used for compilations with the GCC just built.
+XCFLAGS =
+TCFLAGS =
+CFLAGS = -g
+STAGE1_CFLAGS = -g @stage1_cflags@
+STAGE1_CHECKING = -DENABLE_CHECKING -DENABLE_ASSERT_CHECKING
+BOOT_CFLAGS = -g -O2
+
+# Flags to determine code coverage. When coverage is disabled, this will
+# contain the optimization flags, as you normally want code coverage
+# without optimization.
+COVERAGE_FLAGS = @coverage_flags@
+coverageexts = .{gcda,gcno}
+
+# The warning flags are separate from BOOT_CFLAGS because people tend to
+# override optimization flags and we'd like them to still have warnings
+# turned on.  These flags are also used to pass other stage dependent
+# flags from configure.  The user is free to explicitly turn these flags
+# off if they wish.
+# LOOSE_WARN are the warning flags to use when compiling something
+# which is only compiled with gcc, such as libgcc and the frontends
+# other than C.
+# STRICT_WARN and STRICT2_WARN are the additional warning flags to
+# apply to the back end and the C front end, which may be compiled
+# with other compilers.  This is partially controlled by configure in
+# stage1, as not all versions of gcc understand -Wno-long-long or
+# -Wno-variadic-macros.
+LOOSE_WARN = -W -Wall -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes
+STRICT_WARN = @strict1_warn@
+WERROR_FLAGS = @WERROR@
+STRICT2_WARN = -pedantic -Wno-long-long -Wno-variadic-macros \
+  -Wold-style-definition -Wmissing-format-attribute $(WERROR_FLAGS)
+
+# This is set by --enable-checking.  The idea is to catch forgotten
+# "extern" tags in header files.
+NOCOMMON_FLAG = @nocommon_flag@
+
+# This is set by --disable-maintainer-mode (default) to "#"
+MAINT := @MAINT@
+
+# These are set by --enable-checking=valgrind.
+RUN_GEN = @valgrind_command@
+VALGRIND_DRIVER_DEFINES = @valgrind_path_defines@
+
+# This is how we control whether or not the additional warnings are applied.
+.-warn = $(STRICT_WARN)
+build-warn = $(STRICT_WARN)
+GCC_WARN_CFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)
+
+# These files are to have -Werror bypassed in stage2:
+# These are very hard to completely clean due to target complexities.
+gcc.o-warn = -Wno-error
+build/insn-conditions.o-warn = -Wno-error
+# Bison-1.75 output often yields (harmless) -Wtraditional warnings
+build/gengtype-yacc.o-warn = -Wno-error
+# flex output may yield harmless "no previous prototype" warnings
+build/gengtype-lex.o-warn = -Wno-error
+# SYSCALLS.c misses prototypes
+SYSCALLS.c.X-warn = -Wno-strict-prototypes -Wno-error
+# These files need -Wno-error because the gimplifier triggers hard to fix
+# warnings when converting to GIMPLE form.  The warnings are triggered because
+# moving the condition into the loop prevents the loop optimizer from
+# recognizing that the loop will always be executed at least once.  We need
+# a new loop optimizer.
+reload1.o-warn = -Wno-error
+
+# All warnings have to be shut off in stage1 if the compiler used then
+# isn't gcc; configure determines that.  WARN_CFLAGS will be either
+# $(GCC_WARN_CFLAGS), or nothing.
+WARN_CFLAGS = @warn_cflags@
+
+CPPFLAGS = @CPPFLAGS@
+
+# These exists to be overridden by the x-* and t-* files, respectively.
+X_CFLAGS =
+T_CFLAGS =
+
+X_CPPFLAGS =
+T_CPPFLAGS =
+
+AWK = @AWK@
+CC = @CC@
+BISON = @BISON@
+BISONFLAGS =
+FLEX = @FLEX@
+FLEXFLAGS =
+AR = @AR@
+AR_FLAGS = rc
+NM = @NM@
+RANLIB = @RANLIB@
+RANLIB_FLAGS = @ranlib_flags@
+
+# -------------------------------------------
+# Programs which operate on the build machine
+# -------------------------------------------
+
+SHELL = @SHELL@
+# pwd command to use.  Allow user to override default by setting PWDCMD in
+# the environment to account for automounters.  The make variable must not
+# be called PWDCMD, otherwise the value set here is passed to make
+# subprocesses and overrides the setting from the user's environment.
+# Don't use PWD since it is a common shell environment variable and we
+# don't want to corrupt it.
+PWD_COMMAND = $${PWDCMD-pwd}
+# on sysV, define this as cp.
+INSTALL = @INSTALL@
+# Some systems may be missing symbolic links, regular links, or both.
+# Allow configure to check this and use "ln -s", "ln", or "cp" as appropriate.
+LN=@LN@
+LN_S=@LN_S@
+# These permit overriding just for certain files.
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL@
+MAKEINFO = @MAKEINFO@
+MAKEINFOFLAGS = --no-split
+TEXI2DVI = texi2dvi
+TEXI2HTML = $(MAKEINFO) --html
+TEXI2POD = perl $(srcdir)/../contrib/texi2pod.pl
+POD2MAN = pod2man --center="GNU" --release="gcc-$(version)"
+# Some versions of `touch' (such as the version on Solaris 2.8)
+# do not correctly set the timestamp due to buggy versions of `utime'
+# in the kernel.  So, we use `echo' instead.
+STAMP = echo timestamp >
+
+# Make sure the $(MAKE) variable is defined.
+@SET_MAKE@
+REMAKEFLAGS=LANGUAGES="$(LANGUAGES)" BOOT_CFLAGS="$(BOOT_CFLAGS)"
+
+# Locate mkinstalldirs.
+mkinstalldirs=$(SHELL) $(srcdir)/../mkinstalldirs
+
+# --------
+# UNSORTED
+# --------
+
+# Some compilers can't handle cc -c blah.c -o foo/blah.o.
+# In stage2 and beyond, we force this to "-o $@" since we know we're using gcc.
+OUTPUT_OPTION = @OUTPUT_OPTION@
+
+# This is where we get zlib from.  zlibdir is -L../zlib and zlibinc is
+# -I../zlib, unless we were configured with --with-system-zlib, in which
+# case both are empty.
+ZLIB = @zlibdir@ -lz
+ZLIBINC = @zlibinc@
+
+# How to find GMP
+GMPLIBS = @GMPLIBS@
+GMPINC = @GMPINC@
+
+CPPLIB = ../libcpp/libcpp.a
+CPPINC = -I$(srcdir)/../libcpp/include
+
+# Substitution type for target's getgroups 2nd arg.
+TARGET_GETGROUPS_T = @TARGET_GETGROUPS_T@
+
+# Target to use when installing include directory.  Either
+# install-headers-tar, install-headers-cpio or install-headers-cp.
+INSTALL_HEADERS_DIR = @build_install_headers_dir@
+
+# Header files that are made available under the same name
+# to programs compiled with GCC.
+USER_H = $(srcdir)/ginclude/float.h \
+	 $(srcdir)/ginclude/iso646.h \
+	 $(srcdir)/ginclude/stdarg.h \
+	 $(srcdir)/ginclude/stdbool.h \
+	 $(srcdir)/ginclude/stddef.h \
+	 $(srcdir)/ginclude/varargs.h \
+	 $(EXTRA_HEADERS)
+
+UNWIND_H = $(srcdir)/unwind-generic.h
+
+# The GCC to use for compiling libgcc.a and crt*.o.
+# Usually the one we just built.
+# Don't use this as a dependency--use $(GCC_PASSES) or $(GCC_PARTS).
+GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include -L$(objdir)/../ld
+
+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.
+# It omits XCFLAGS, and specifies -B./.
+# It also specifies -isystem ./include to find, e.g., stddef.h.
+GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
+
+# ---------------------------------------------------
+# Programs which produce files for the target machine
+# ---------------------------------------------------
+
+AR_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/ar ] ; then \
+    echo $(objdir)/../binutils/ar ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo $(AR); \
+    else \
+       t='$(program_transform_name)'; echo ar | sed -e $$t ; \
+    fi; \
+  fi)
+AR_FLAGS_FOR_TARGET =
+AR_CREATE_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) rc
+AR_EXTRACT_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) x
+LIPO_FOR_TARGET = lipo
+ORIGINAL_AS_FOR_TARGET = @ORIGINAL_AS_FOR_TARGET@
+RANLIB_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/ranlib ] ; then \
+    echo $(objdir)/../binutils/ranlib ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo $(RANLIB); \
+    else \
+       t='$(program_transform_name)'; echo ranlib | sed -e $$t ; \
+    fi; \
+  fi)
+ORIGINAL_LD_FOR_TARGET = @ORIGINAL_LD_FOR_TARGET@
+ORIGINAL_NM_FOR_TARGET = @ORIGINAL_NM_FOR_TARGET@
+NM_FOR_TARGET = ./nm
+STRIP_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/strip ] ; then \
+    echo $(objdir)/../binutils/strip ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo strip; \
+    else \
+       t='$(program_transform_name)'; echo strip | sed -e $$t ; \
+    fi; \
+  fi)
+
+# --------
+# UNSORTED
+# --------
+
+# Where to find some libiberty headers.
+HASHTAB_H   = $(srcdir)/../include/hashtab.h
+OBSTACK_H   = $(srcdir)/../include/obstack.h
+SPLAY_TREE_H= $(srcdir)/../include/splay-tree.h
+FIBHEAP_H   = $(srcdir)/../include/fibheap.h
+PARTITION_H = $(srcdir)/../include/partition.h
+MD5_H	    = $(srcdir)/../include/md5.h
+
+# Default native SYSTEM_HEADER_DIR, to be overridden by targets.
+NATIVE_SYSTEM_HEADER_DIR = /usr/include
+# Default cross SYSTEM_HEADER_DIR, to be overridden by targets.
+CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@
+
+# autoconf sets SYSTEM_HEADER_DIR to one of the above.
+# Purge it of unneccessary internal relative paths
+# to directories that might not exist yet.
+# The sed idiom for this is to repeat the search-and-replace until it doesn't match, using :a ... ta.
+SYSTEM_HEADER_DIR = `echo @SYSTEM_HEADER_DIR@ | sed -e :a -e "s,[^/]*/\.\.\/,," -e ta`
+
+# Control whether to run fixproto and fixincludes.
+STMP_FIXPROTO = @STMP_FIXPROTO@
+STMP_FIXINC = @STMP_FIXINC@
+
+# Test to see whether <limits.h> exists in the system header files.
+LIMITS_H_TEST = [ -f $(SYSTEM_HEADER_DIR)/limits.h ]
+
+# Directory for prefix to system directories, for
+# each of $(system_prefix)/usr/include, $(system_prefix)/usr/lib, etc.
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+
+xmake_file=@xmake_file@
+tmake_file=@tmake_file@
+out_file=$(srcdir)/config/@out_file@
+out_object_file=@out_object_file@
+md_file=$(srcdir)/config/@md_file@
+tm_file_list=@tm_file_list@
+tm_include_list=@tm_include_list@
+tm_defines=@tm_defines@
+tm_p_file_list=@tm_p_file_list@
+tm_p_include_list=@tm_p_include_list@
+build_xm_file_list=@build_xm_file_list@
+build_xm_include_list=@build_xm_include_list@
+build_xm_defines=@build_xm_defines@
+host_xm_file_list=@host_xm_file_list@
+host_xm_include_list=@host_xm_include_list@
+host_xm_defines=@host_xm_defines@
+xm_file_list=@xm_file_list@
+xm_include_list=@xm_include_list@
+xm_defines=@xm_defines@
+lang_checks=check-gcc
+lang_opt_files=@lang_opt_files@ $(srcdir)/c.opt $(srcdir)/common.opt
+lang_specs_files=@lang_specs_files@
+lang_tree_files=@lang_tree_files@
+target_cpu_default=@target_cpu_default@
+GCC_THREAD_FILE=@thread_file@
+OBJC_BOEHM_GC=@objc_boehm_gc@
+GTHREAD_FLAGS=@gthread_flags@
+extra_modes_file=@extra_modes_file@
+extra_opt_files=@extra_opt_files@
+host_hook_obj=@out_host_hook_obj@
+
+# ------------------------
+# Installation directories
+# ------------------------
+
+# Common prefix for installation directories.
+# NOTE: This directory must exist when you start installation.
+prefix = @prefix@
+# Directory in which to put localized header files. On the systems with
+# gcc as the native cc, `local_prefix' may not be `prefix' which is
+# `/usr'.
+# NOTE: local_prefix *should not* default from prefix.
+local_prefix = @local_prefix@
+# Directory in which to put host dependent programs and libraries
+exec_prefix = @exec_prefix@
+# Directory in which to put the executable for the command `gcc'
+bindir = @bindir@
+# Directory in which to put the directories used by the compiler.
+libdir = @libdir@
+# Directory in which GCC puts its executables.
+libexecdir = @libexecdir@
+
+# --------
+# UNSORTED
+# --------
+
+# Directory in which the compiler finds libraries etc.
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(version)
+# Directory in which the compiler finds executables
+libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(version)
+# Used to produce a relative $(gcc_tooldir) in gcc.o
+unlibsubdir = ../../..
+# Directory in which to find other cross-compilation tools and headers.
+dollar = @dollar@
+# Used in install-cross.
+gcc_tooldir = @gcc_tooldir@
+# Used to install the shared libgcc.
+slibdir = @slibdir@
+# Since gcc_tooldir does not exist at build-time, use -B$(build_tooldir)/bin/
+build_tooldir = $(exec_prefix)/$(target_noncanonical)
+# Directory in which the compiler finds target-independent g++ includes.
+gcc_gxx_include_dir = @gcc_gxx_include_dir@
+# Directory to search for site-specific includes.
+local_includedir = $(local_prefix)/include
+includedir = $(prefix)/include
+# where the info files go
+infodir = @infodir@
+# Where cpp should go besides $prefix/bin if necessary
+cpp_install_dir = @cpp_install_dir@
+# where the locale files go
+datadir = @datadir@
+localedir = $(datadir)/locale
+# Extension (if any) to put in installed man-page filename.
+man1ext = .1
+man7ext = .7
+objext = .o
+exeext = @host_exeext@
+build_exeext = @build_exeext@
+
+# Directory in which to put man pages.
+mandir = @mandir@
+man1dir = $(mandir)/man1
+man7dir = $(mandir)/man7
+# Dir for temp files.
+tmpdir = /tmp
+
+# Directory in which to put HTML
+htmldir = $(objdir)/HTML/gcc-$(version)
+
+# Whether we were configured with NLS.
+USE_NLS = @USE_NLS@
+
+# Internationalization library.
+LIBINTL = @LIBINTL@
+LIBINTL_DEP = @LIBINTL_DEP@
+
+# Character encoding conversion library.
+LIBICONV = @LIBICONV@
+LIBICONV_DEP = @LIBICONV_DEP@
+
+# The GC method to be used on this system.
+GGC=@GGC@.o
+
+# If a supplementary library is being used for the GC.
+GGC_LIB=
+
+# libgcc.a may be built directly or via stmp-multilib,
+# and installed likewise.  Overridden by t-fragment.
+LIBGCC = libgcc.a
+INSTALL_LIBGCC = install-libgcc
+
+# "true" if the target C library headers are unavailable; "false"
+# otherwise.
+inhibit_libc = @inhibit_libc@
+ifeq ($(inhibit_libc),true)
+INHIBIT_LIBC_CFLAGS = -Dinhibit_libc
+endif
+
+# Options to use when compiling libgcc2.a.
+#
+LIBGCC2_DEBUG_CFLAGS = -g
+LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) \
+		 $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) \
+		 -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED \
+		 $(INHIBIT_LIBC_CFLAGS)
+
+# Additional options to use when compiling libgcc2.a.
+# Some targets override this to -isystem include
+LIBGCC2_INCLUDES =
+
+# Additional target-dependent options for compiling libgcc2.a.
+TARGET_LIBGCC2_CFLAGS =
+
+# Options to use when compiling crtbegin/end.
+CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
+  -finhibit-size-directive -fno-inline-functions -fno-exceptions \
+  -fno-zero-initialized-in-bss -fno-unit-at-a-time \
+  $(INHIBIT_LIBC_CFLAGS)
+
+# Additional sources to handle exceptions; overridden by targets as needed.
+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
+   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+LIB2ADDEHSTATIC = $(LIB2ADDEH)
+LIB2ADDEHSHARED = $(LIB2ADDEH)
+LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h
+
+# Don't build libunwind by default.
+LIBUNWIND =
+LIBUNWINDDEP =
+SHLIBUNWIND_LINK =
+SHLIBUNWIND_INSTALL =
+
+# nm flags to list global symbols in libgcc object files.
+SHLIB_NM_FLAGS = -pg
+
+# List of extra executables that should be compiled for this target machine
+# that are used for compiling from source code to object code.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PASSES =@extra_passes@
+
+# Like EXTRA_PASSES, but these are used when linking.
+EXTRA_PROGRAMS = @extra_programs@
+
+# List of extra object files that should be compiled for this target machine.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PARTS = @extra_parts@
+
+# List of extra object files that should be compiled and linked with
+# compiler proper (cc1, cc1obj, cc1plus).
+EXTRA_OBJS = @extra_objs@
+
+# List of extra object files that should be compiled and linked with
+# the gcc driver.
+EXTRA_GCC_OBJS =@extra_gcc_objs@
+
+# List of additional header files to install.
+EXTRA_HEADERS =@extra_headers_list@
+
+# The configure script will set this to collect2$(exeext), except on a
+# (non-Unix) host which can not build collect2, for which it will be
+# set to empty.
+COLLECT2 = @collect2@
+
+# List of extra C and assembler files to add to static and shared libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_EXTRA =
+
+# List of extra C and assembler files to add to static libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_STATIC_EXTRA =
+
+# Program to convert libraries.
+LIBCONVERT =
+
+# Control whether header files are installed.
+INSTALL_HEADERS=install-headers install-mkheaders
+
+# Control whether Info documentation is built and installed.
+BUILD_INFO = @BUILD_INFO@
+
+# Control whether manpages generated by texi2pod.pl can be rebuilt.
+GENERATED_MANPAGES = @GENERATED_MANPAGES@
+
+# Additional directories of header files to run fixincludes on.
+# These should be directories searched automatically by default
+# just as /usr/include is.
+# *Do not* use this for directories that happen to contain
+# header files, but are not searched automatically by default.
+# On most systems, this is empty.
+OTHER_FIXINCLUDES_DIRS=
+
+# A list of all the language-specific executables.
+COMPILERS = cc1$(exeext) @all_compilers@
+
+# List of things which should already be built whenever we try to use xgcc
+# to compile anything (without linking).
+GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
+
+# List of things which should already be built whenever we try to use xgcc
+# to link anything.
+GCC_PARTS=$(GCC_PASSES) $(LIBGCC) $(EXTRA_PROGRAMS) $(COLLECT2) $(EXTRA_PARTS)
+
+# Directory to link to, when using the target `maketest'.
+DIR = ../gcc
+
+# Native compiler for the build machine and its switches.
+CC_FOR_BUILD = @CC_FOR_BUILD@
+BUILD_CFLAGS= @BUILD_CFLAGS@ -DGENERATOR_FILE
+
+# Native linker and preprocessor flags.  For x-fragment overrides.
+BUILD_LDFLAGS=$(LDFLAGS)
+BUILD_CPPFLAGS=$(ALL_CPPFLAGS)
+
+# Actual name to use when installing a native compiler.
+GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')
+GCC_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gcc|sed '$(program_transform_name)')
+CPP_INSTALL_NAME := $(shell echo cpp|sed '$(program_transform_name)')
+PROTOIZE_INSTALL_NAME := $(shell echo protoize|sed '$(program_transform_name)')
+UNPROTOIZE_INSTALL_NAME := $(shell echo unprotoize|sed '$(program_transform_name)')
+GCOV_INSTALL_NAME := $(shell echo gcov|sed '$(program_transform_name)')
+GCCBUG_INSTALL_NAME := $(shell echo gccbug|sed '$(program_transform_name)')
+
+# Setup the testing framework, if you have one
+EXPECT = `if [ -f $${rootme}/../expect/expect ] ; then \
+            echo $${rootme}/../expect/expect ; \
+          else echo expect ; fi`
+
+RUNTEST = `if [ -f $${srcdir}/../dejagnu/runtest ] ; then \
+	       echo $${srcdir}/../dejagnu/runtest ; \
+	    else echo runtest; fi`
+RUNTESTFLAGS =
+
+# Extra symbols for fixproto to define when parsing headers.
+FIXPROTO_DEFINES =
+
+# Extra flags to use when compiling crt{begin,end}.o.
+CRTSTUFF_T_CFLAGS =
+
+# Extra flags to use when compiling [m]crt0.o.
+CRT0STUFF_T_CFLAGS =
+
+# "t" or nothing, for building multilibbed versions of, say, crtbegin.o.
+T =
+
+# Should T contain a `=', libgcc.mk will make T_TARGET, setting
+# $(T_TARGET) to the name of the actual target filename.
+T_TARGET =
+T_TARGET : $(T_TARGET)
+
+# This should name the specs file that we're going to install.  Target
+# Makefiles may override it and name another file to be generated from
+# the built-in specs and installed as the default spec, as long as
+# they also introduce a rule to generate a file name specs, to be used
+# at build time.
+SPECS = specs
+
+# End of variables for you to override.
+
+# GTM_H lists the config files that the generator files depend on,
+# while TM_H lists the ones ordinary gcc files depend on, which
+# includes several files generated by those generators.
+BCONFIG_H = bconfig.h $(build_xm_file_list)
+CONFIG_H  = config.h  $(host_xm_file_list)
+TCONFIG_H = tconfig.h $(xm_file_list)
+TM_P_H    = tm_p.h    $(tm_p_file_list)
+GTM_H     = tm.h      $(tm_file_list)
+TM_H      = $(GTM_H) insn-constants.h insn-flags.h options.h
+
+# Variables for version information.
+BASEVER     := $(srcdir)/BASE-VER  # 4.x.y
+DEVPHASE    := $(srcdir)/DEV-PHASE # experimental, prerelease, ""
+DATESTAMP   := $(srcdir)/DATESTAMP # YYYYMMDD or empty
+
+BASEVER_c   := $(shell cat $(BASEVER))
+DEVPHASE_c  := $(shell cat $(DEVPHASE))
+DATESTAMP_c := $(shell cat $(DATESTAMP))
+
+version     := $(BASEVER_c)
+
+# For use in version.c - double quoted strings, with appropriate
+# surrounding punctuation and spaces, and with the datestamp and
+# development phase collapsed to the empty string in release mode
+# (i.e. if DEVPHASE_c is empty).  The space immediately after the
+# comma in the $(if ...) constructs is significant - do not remove it.
+BASEVER_s   := "\"$(BASEVER_c)\""
+DEVPHASE_s  := "\"$(if $(DEVPHASE_c), ($(DEVPHASE_c)))\""
+DATESTAMP_s := "\"$(if $(DEVPHASE_c), $(DATESTAMP_c))\""
+
+# Shorthand variables for dependency lists.
+TARGET_H = $(TM_H) target.h insn-modes.h
+MACHMODE_H = machmode.h mode-classes.def insn-modes.h
+HOOKS_H = hooks.h $(MACHMODE_H)
+HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)
+LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)
+TARGET_DEF_H = target-def.h $(HOOKS_H)
+RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \
+  input.h real.h statistics.h
+RTL_H = $(RTL_BASE_H) genrtl.h
+PARAMS_H = params.h params.def
+TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h builtins.def \
+          input.h statistics.h vec.h treestruct.def
+BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \
+          hard-reg-set.h cfghooks.h $(OBSTACK_H)
+GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h
+COVERAGE_H = coverage.h $(GCOV_IO_H)
+DEMANGLE_H = $(srcdir)/../include/demangle.h
+RECOG_H = recog.h
+ALIAS_H = alias.h
+EMIT_RTL_H = emit-rtl.h
+FLAGS_H = flags.h options.h
+EXPR_H = expr.h insn-config.h function.h $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)
+OPTABS_H = optabs.h insn-codes.h
+REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)
+RESOURCE_H = resource.h hard-reg-set.h
+SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H)
+INTEGRATE_H = integrate.h varray.h
+CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)
+CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H)
+IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H) 
+IPA_REFERENCE_H = ipa-reference.h bitmap.h $(TREE_H)  
+IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)  
+CGRAPH_H = cgraph.h $(TREE_H)
+DF_H = df.h bitmap.h sbitmap.h $(BASIC_BLOCK_H)
+DDG_H = ddg.h sbitmap.h $(DF_H)
+GCC_H = gcc.h version.h
+GGC_H = ggc.h gtype-desc.h
+TIMEVAR_H = timevar.h timevar.def
+INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h
+C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H)
+C_PRAGMA_H = c-pragma.h $(CPPLIB_H)
+C_TREE_H = c-tree.h $(C_COMMON_H) toplev.h $(DIAGNOSTIC_H)
+SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h
+PREDICT_H = predict.h predict.def
+CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \
+	$(srcdir)/../libcpp/include/cpplib.h
+MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h
+SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h
+CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h
+TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)
+TREE_GIMPLE_H = tree-gimple.h tree-iterator.h
+TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \
+		bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_GIMPLE_H) \
+		$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H)
+TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)
+PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)
+DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)
+C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)
+SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)
+LAMBDA_H = lambda.h tree.h vec.h $(GGC_H)
+TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H)
+VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)
+
+#
+# Now figure out from those variables how to compile and link.
+
+# IN_GCC distinguishes between code compiled into GCC itself and other
+# programs built during a bootstrap.
+# autoconf inserts -DCROSS_COMPILE if we are building a cross compiler.
+INTERNAL_CFLAGS = -DIN_GCC @CROSS@
+
+# This is the variable actually used when we compile. If you change this,
+# you probably want to update BUILD_CFLAGS in configure.ac
+ALL_CFLAGS = $(X_CFLAGS) $(T_CFLAGS) \
+  $(CFLAGS) $(INTERNAL_CFLAGS) $(COVERAGE_FLAGS) $(WARN_CFLAGS) $(XCFLAGS) @DEFS@
+
+# Likewise.  Put INCLUDES at the beginning: this way, if some autoconf macro
+# puts -I options in CPPFLAGS, our include files in the srcdir will always
+# win against random include files in /usr/include.
+ALL_CPPFLAGS = $(INCLUDES) $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)
+
+# Build and host support libraries.
+LIBIBERTY = ../libiberty/libiberty.a
+BUILD_LIBIBERTY = $(build_objdir)/libiberty/libiberty.a
+
+# Dependencies on the intl and portability libraries.
+LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP)
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBDEPS= $(BUILD_LIBIBERTY)
+
+# How to link with both our special library facilities
+# and the system's installed libraries.
+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY)
+
+# Any system libraries needed just for GNAT.
+SYSLIBS = @GNAT_LIBEXC@
+
+# Libs needed (at present) just for jcf-dump.
+LDEXP_LIB = @LDEXP_LIB@
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBS = $(BUILD_LIBIBERTY)
+
+BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o \
+	    build/min-insn-modes.o
+BUILD_SUPPORT = build/gensupport.o build/insn-conditions.o
+BUILD_EARLY_SUPPORT = build/gensupport.o build/dummy-conditions.o
+
+BUILD_PRINT = build/print-rtl.o
+BUILD_ERRORS = build/errors.o
+BUILD_VARRAY = build/varray.o
+
+# Specify the directories to be searched for header files.
+# Both . and srcdir are used, in that order,
+# so that *config.h will be found in the compilation
+# subdirectory rather than in the source directory.
+# -I$(@D) and -I$(srcdir)/$(@D) cause the subdirectory of the file
+# currently being compiled, in both source trees, to be examined as well.
+# libintl.h will be found in ../intl if we are using the included libintl.
+INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
+	   -I$(srcdir)/../include @INCINTL@ \
+	   $(CPPINC) $(GMPINC)
+
+.c.o:
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
+
+#
+# Support for additional languages (other than C).
+# C can be supported this way too (leave for later).
+
+LANG_MAKEFRAGS = @all_lang_makefrags@
+LANG_MAKEFILES = @all_lang_makefiles@
+LANG_STAGESTUFF = @all_stagestuff@
+
+# Flags to pass to recursive makes.
+# CC is set by configure.  Hosts without symlinks need special handling
+# because we need CC="stage1/xgcc -Bstage1/" to work in the language
+# subdirectories.
+# ??? The choices here will need some experimenting with.
+
+export AR_FOR_TARGET
+export AR_CREATE_FOR_TARGET
+export AR_FLAGS_FOR_TARGET
+export AR_EXTRACT_FOR_TARGET
+export AWK
+export DESTDIR
+export GCC_FOR_TARGET
+export INCLUDES
+export INSTALL_DATA
+export LIB1ASMSRC
+export LIBGCC2_CFLAGS
+export LIPO_FOR_TARGET
+export MACHMODE_H
+export NM_FOR_TARGET
+export STRIP_FOR_TARGET
+export RANLIB_FOR_TARGET
+export libsubdir
+export slibdir
+
+ORDINARY_FLAGS_TO_PASS = \
+	"BISON=$(BISON)" \
+	"BISONFLAGS=$(BISONFLAGS)" \
+	"CFLAGS=$(CFLAGS) $(WARN_CFLAGS)" \
+	"LDFLAGS=$(LDFLAGS)" \
+	"FLEX=$(FLEX)" \
+	"FLEXFLAGS=$(FLEXFLAGS)" \
+	"LN=$(LN)" \
+	"LN_S=$(LN_S)" \
+	"MAKEINFO=$(MAKEINFO)" \
+	"MAKEINFOFLAGS=$(MAKEINFOFLAGS)" \
+	"MAKEOVERRIDES=" \
+	"SHELL=$(SHELL)" \
+	"exeext=$(exeext)" \
+	"build_exeext=$(build_exeext)" \
+	"objext=$(objext)" \
+	"exec_prefix=$(exec_prefix)" \
+	"prefix=$(prefix)" \
+	"local_prefix=$(local_prefix)" \
+	"gxx_include_dir=$(gcc_gxx_include_dir)" \
+	"build_tooldir=$(build_tooldir)" \
+	"gcc_tooldir=$(gcc_tooldir)" \
+	"bindir=$(bindir)" \
+	"libexecsubdir=$(libsubdir)" \
+	"datadir=$(datadir)" \
+	"localedir=$(localedir)"
+FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) "CC=@cc_set_by_configure@" \
+	"STAGE_PREFIX=@stage_prefix_set_by_configure@"
+PREPEND_DOTDOT_TO_RELATIVE_PATHS = sed \
+	-e 's|^ *[^ /][^ /]*/|%&|' \
+	-e 's| -B| -B%|g' \
+	-e 's|% *[^- /]|%&|g' \
+	-e 's|%% *|../|g' \
+	-e 's|%||g'
+SUBDIR_FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) \
+	"CC=`echo @quoted_cc_set_by_configure@ | $(PREPEND_DOTDOT_TO_RELATIVE_PATHS)`" \
+	"STAGE_PREFIX=`echo @quoted_stage_prefix_set_by_configure@ | $(PREPEND_DOTDOT_TO_RELATIVE_PATHS)`"
+#
+# Lists of files for various purposes.
+
+# All option source files
+ALL_OPT_FILES=$(lang_opt_files) $(extra_opt_files)
+
+# Target specific, C specific object file
+C_TARGET_OBJS=@c_target_objs@
+
+# Target specific, C++ specific object file
+CXX_TARGET_OBJS=@cxx_target_objs@
+
+# Language-specific object files for C and Objective C.
+C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
+  c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
+  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
+  c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
+  c-gimplify.o tree-mudflap.o c-pretty-print.o
+
+# Language-specific object files for C.
+C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)
+
+# Language-independent object files.
+OBJS-common = \
+ tree-chrec.o tree-scalar-evolution.o tree-data-ref.o			   \
+ tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \
+ gimplify.o tree-pretty-print.o tree-into-ssa.o				   \
+ tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o tree-ssa-uncprop.o		   \
+ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o	   \
+ tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \
+ tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o	   \
+ tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o	   \
+ tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o		   \
+ tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o		   \
+ tree-ssa-loop-manip.o tree-ssa-threadupdate.o				   \
+ tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o		   \
+ tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o	   \
+ tree-ssa-math-opts.o							   \
+ tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o		   \
+ alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o	  	   \
+ cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o		   \
+ cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o	   \
+ cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o 	   \
+ dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o tree-ssa-loop-im.o	   \
+ debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o		   \
+ dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o		   \
+ expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o		   \
+ genrtl.o ggc-common.o global.o graph.o gtype-desc.o			   \
+ haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-modes.o	   \
+ insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o	   \
+ integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  	   \
+ loop.o mode-switching.o modulo-sched.o optabs.o options.o opts.o	   \
+ params.o postreload.o postreload-gcse.o predict.o			   \
+ insn-preds.o pointer-set.o 					   	   \
+ print-rtl.o print-tree.o profile.o value-prof.o var-tracking.o		   \
+ real.o recog.o reg-stack.o regclass.o regmove.o regrename.o		   \
+ reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o	   \
+ sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o	   \
+ simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o		   \
+ targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o		   \
+ varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o	   \
+ et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o	   \
+ tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o    			   \
+ lambda-trans.o	lambda-code.o tree-loop-linear.o tree-ssa-sink.o 	   \
+ tree-vrp.o tree-stdarg.o tree-cfgcleanup.o tree-ssa-reassoc.o		   \
+ tree-ssa-structalias.o tree-object-size.o
+
+
+OBJS-md = $(out_object_file)
+OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o		   \
+  cgraph.o cgraphunit.o tree-nomudflap.o ipa.o ipa-inline.o                \
+  ipa-utils.o ipa-reference.o ipa-pure-const.o ipa-type-escape.o           \
+  ipa-prop.o ipa-cp.o
+
+OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)
+
+OBJS-onestep = libbackend.o $(OBJS-archive)
+
+BACKEND = main.o @TREEBROWSER@ libbackend.a $(CPPLIB)
+
+# Files to be copied after each stage in building.
+STAGECOPYSTUFF = insn-flags.h insn-config.h insn-codes.h \
+ insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \
+ insn-attr.h insn-attrtab.c insn-opinit.c insn-preds.c insn-constants.h \
+ tm-preds.h \
+ tree-check.h insn-conditions.c min-insn-modes.c insn-modes.c insn-modes.h \
+ genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-gen.h
+
+# Files to be moved away after each stage in building.
+STAGEMOVESTUFF = *$(objext) s-* \
+ xgcc$(exeext) cpp$(exeext) cc1$(exeext) cc1*-dummy$(exeext) $(EXTRA_PASSES) \
+ $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) \
+ protoize$(exeext) unprotoize$(exeext) \
+ $(SPECS) collect2$(exeext) \
+ gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \
+ *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a libgcc.mk \
+ $(LANG_STAGESTUFF)
+
+# Defined in libgcc2.c, included only in the static library.
+LIB2FUNCS_ST = _eprintf __gcc_bcmp
+
+# Defined in libgcov.c, included only in gcov library
+LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \
+    _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \
+    _gcov_execv _gcov_execvp _gcov_execve \
+    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler
+
+FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \
+    _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \
+    _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \
+    _sf_to_df _sf_to_tf _thenan_sf _sf_to_usi _usi_to_sf
+
+DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \
+    _fpcmp_parts_df _compare_df _eq_df _ne_df _gt_df _ge_df \
+    _lt_df _le_df _unord_df _si_to_df _df_to_si _negate_df _make_df \
+    _df_to_sf _df_to_tf _thenan_df _df_to_usi _usi_to_df
+
+TPBIT_FUNCS = _pack_tf _unpack_tf _addsub_tf _mul_tf _div_tf \
+    _fpcmp_parts_tf _compare_tf _eq_tf _ne_tf _gt_tf _ge_tf \
+    _lt_tf _le_tf _unord_tf _si_to_tf _tf_to_si _negate_tf _make_tf \
+    _tf_to_df _tf_to_sf _thenan_tf _tf_to_usi _usi_to_tf
+
+# These might cause a divide overflow trap and so are compiled with
+# unwinder info.
+LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4
+
+#
+# Language makefile fragments.
+
+# The following targets define the interface between us and the languages.
+#
+# all.cross, start.encap, rest.encap,
+# install-normal, install-common, install-info, install-man,
+# uninstall,
+# mostlyclean, clean, distclean, maintainer-clean,
+# stage1, stage2, stage3, stage4
+#
+# Each language is linked in with a series of hooks.  The name of each
+# hooked is "lang.${target_name}" (eg: lang.info).  Configure computes
+# and adds these here.  We use double-colon rules for some of the hooks;
+# double-colon rules should be preferred for any new hooks.
+
+# language hooks, generated by configure
+@language_hooks@
+
+# per-language makefile fragments
+ifneq ($(LANG_MAKEFRAGS),)
+include $(LANG_MAKEFRAGS)
+endif
+
+# target and host overrides must follow the per-language makefile fragments
+# so they can override or augment language-specific variables
+
+# target overrides
+ifneq ($(tmake_file),)
+include $(tmake_file)
+endif
+
+# host overrides
+ifneq ($(xmake_file),)
+include $(xmake_file)
+endif
+
+#
+
+# -----------------------------
+# Rebuilding this configuration
+# -----------------------------
+
+Makefile: config.status $(srcdir)/Makefile.in $(LANG_MAKEFRAGS)
+	LANGUAGES="$(CONFIG_LANGUAGES)" \
+	CONFIG_HEADERS= \
+	CONFIG_SHELL="$(SHELL)" \
+	CONFIG_FILES=$@ $(SHELL) config.status
+
+config.h: cs-config.h ; @true
+bconfig.h: cs-bconfig.h ; @true
+tconfig.h: cs-tconfig.h ; @true
+tm.h: cs-tm.h ; @true
+tm_p.h: cs-tm_p.h ; @true
+
+cs-config.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(host_xm_include_list)" DEFINES="$(host_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh config.h
+
+cs-bconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(build_xm_include_list)" DEFINES="$(build_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh bconfig.h
+
+cs-tconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(xm_include_list)" DEFINES="USED_FOR_TARGET $(xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tconfig.h
+
+cs-tm.h: Makefile
+	TARGET_CPU_DEFAULT="$(target_cpu_default)" \
+	HEADERS="$(tm_include_list)" DEFINES="$(tm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm.h
+
+cs-tm_p.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(tm_p_include_list)" DEFINES="" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm_p.h
+
+# Don't automatically run autoconf, since configure.ac might be accidentally
+# newer than configure.  Also, this writes into the source directory which
+# might be on a read-only file system.  If configured for maintainer mode
+# then do allow autoconf to be run.
+
+$(srcdir)/configure: @MAINT@ $(srcdir)/configure.ac
+	(cd $(srcdir) && autoconf)
+
+gccbug:	$(srcdir)/gccbug.in
+	CONFIG_FILES=gccbug CONFIG_HEADERS= ./config.status
+
+mklibgcc: $(srcdir)/mklibgcc.in
+	CONFIG_FILES=mklibgcc CONFIG_HEADERS= ./config.status
+
+# cstamp-h.in controls rebuilding of config.in.
+# It is named cstamp-h.in and not stamp-h.in so the mostlyclean rule doesn't
+# delete it.  A stamp file is needed as autoheader won't update the file if
+# nothing has changed.
+# It remains in the source directory and is part of the distribution.
+# This follows what is done in shellutils, fileutils, etc.
+# "echo timestamp" is used instead of touch to be consistent with other
+# packages that use autoconf (??? perhaps also to avoid problems with patch?).
+# ??? Newer versions have a maintainer mode that may be useful here.
+
+# Don't run autoheader automatically either.
+# Only run it if maintainer mode is enabled.
+@MAINT@ $(srcdir)/config.in: $(srcdir)/cstamp-h.in
+@MAINT@ $(srcdir)/cstamp-h.in: $(srcdir)/configure.ac
+@MAINT@	(cd $(srcdir) && autoheader)
+@MAINT@	@rm -f $(srcdir)/cstamp-h.in
+@MAINT@	echo timestamp > $(srcdir)/cstamp-h.in
+auto-host.h: cstamp-h ; @true
+cstamp-h: config.in config.status
+	CONFIG_HEADERS=auto-host.h:config.in \
+	CONFIG_FILES= \
+	LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status
+
+# Really, really stupid make features, such as SUN's KEEP_STATE, may force
+# a target to build even if it is up-to-date.  So we must verify that
+# config.status does not exist before failing.
+config.status: $(srcdir)/configure $(srcdir)/config.gcc
+	@if [ ! -f config.status ] ; then \
+	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
+	  false; \
+	else \
+	  LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status --recheck; \
+	fi
+
+# --------
+# UNSORTED
+# --------
+
+all.internal: start.encap rest.encap doc
+# This is what to compile if making a cross-compiler.
+all.cross: native gcc-cross cpp$(exeext) specs \
+	$(LIBGCC) $(EXTRA_PARTS) lang.all.cross doc @GENINSRC@ srcextra
+# This is what must be made before installing GCC and converting libraries.
+start.encap: native xgcc$(exeext) cpp$(exeext) specs \
+	xlimits.h lang.start.encap @GENINSRC@ srcextra
+# These can't be made until after GCC can run.
+rest.encap: $(STMP_FIXPROTO) $(LIBGCC) $(EXTRA_PARTS) lang.rest.encap
+# This is what is made with the host's compiler
+# whether making a cross compiler or not.
+native: config.status auto-host.h build-@POSUB@ $(LANGUAGES) \
+	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2)
+
+# Define the names for selecting languages in LANGUAGES.
+C c: cc1$(exeext)
+PROTO: proto
+
+# Tell GNU make these are phony targets.
+.PHONY: C c PROTO proto
+
+# On the target machine, finish building a cross compiler.
+# This does the things that can't be done on the host machine.
+rest.cross: $(LIBGCC) specs
+
+# Recompile all the language-independent object files.
+# This is used only if the user explicitly asks for it.
+compilations: $(BACKEND)
+
+# This archive is strictly for the host.
+libbackend.a: $(OBJS@onestep@)
+	-rm -rf libbackend.a
+	$(AR) $(AR_FLAGS) libbackend.a $(OBJS@onestep@)
+	-$(RANLIB) $(RANLIB_FLAGS) libbackend.a
+
+# We call this executable `xgcc' rather than `gcc'
+# to avoid confusion if the current directory is in the path
+# and CC is `gcc'.  It is renamed to `gcc' when it is installed.
+xgcc$(exeext): gcc.o gccspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o gccspec.o intl.o \
+	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# cpp is to cpp0 as gcc is to cc1.
+# The only difference from xgcc is that it's linked with cppspec.o
+# instead of gccspec.o.
+cpp$(exeext): gcc.o cppspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o cppspec.o intl.o \
+	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# Create links to binutils, especially for in-tree builds, to make -B.
+# use them.  We need hard links so that directories can be shuffled
+# during toplevel bootstrap.
+# Go through an additional indirection, because the file we create
+# can be either `sometool' (if it is a script) or `sometool$(exeext)'
+# (if it is a hard link).
+stamp-as: $(ORIGINAL_AS_FOR_TARGET)
+	@echo creating as; \
+	case "$(ORIGINAL_AS_FOR_TARGET)" in \
+	  ./as) ;; \
+	  ../*) \
+	     rm -f as$(exeext); \
+	     echo $(LN) $< as$(exeext); \
+	     $(LN) $< as$(exeext) || cp $< as$(exeext) ;; \
+	  *) \
+	     rm -f as; \
+	     echo '#!$(SHELL)' > as; \
+	     echo 'exec $(ORIGINAL_AS_FOR_TARGET) "$$@"' >> as ; \
+	     chmod +x as ;; \
+	esac
+	echo timestamp > $@
+
+stamp-collect-ld: $(ORIGINAL_LD_FOR_TARGET)
+	@echo creating collect-ld; \
+	case "$(ORIGINAL_LD_FOR_TARGET)" in \
+	  ./collect-ld) ;; \
+	  ../*) \
+	     rm -f collect-ld$(exeext); \
+	     echo $(LN) $< collect-ld$(exeext); \
+	     $(LN) $< collect-ld$(exeext) || cp $< collect-ld$(exeext) ;; \
+	  *) \
+	     rm -f collect-ld$(exeext); \
+	     echo '#!$(SHELL)' > collect-ld; \
+	     echo 'exec $(ORIGINAL_LD_FOR_TARGET) "$$@"' >> collect-ld ; \
+	     chmod +x collect-ld ;; \
+	esac
+	echo timestamp > $@
+
+stamp-nm: $(ORIGINAL_NM_FOR_TARGET)
+	@echo creating nm; \
+	case "$(ORIGINAL_NM_FOR_TARGET)" in \
+	  ./nm) ;; \
+	  ../*) \
+	     rm -f nm$(exeext); \
+	     echo $(LN) $< nm$(exeext); \
+	     $(LN) $< nm$(exeext) || cp $< nm$(exeext) ;; \
+	  *) \
+	     rm -f nm$(exeext); \
+	     echo '#!$(SHELL)' > nm; \
+	     echo 'exec $(ORIGINAL_NM_FOR_TARGET) "$$@"' >> nm ; \
+	     chmod +x nm ;; \
+	esac
+	echo timestamp > $@
+
+# Dump a specs file to make -B./ read these specs over installed ones.
+$(SPECS): xgcc$(exeext)
+	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
+	mv tmp-specs $(SPECS)
+
+# We do want to create an executable named `xgcc', so we can use it to
+# compile libgcc2.a.
+# Also create gcc-cross, so that install-common will install properly.
+gcc-cross: xgcc$(exeext)
+	cp xgcc$(exeext) gcc-cross$(exeext)
+
+cc1-dummy$(exeext): $(C_OBJS) dummy-checksum.o $(BACKEND) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) dummy-checksum.o \
+	  $(BACKEND) $(LIBS)
+
+cc1-checksum.c : cc1-dummy$(exeext) build/genchecksum$(build_exeext)
+	build/genchecksum$(build_exeext) cc1-dummy$(exeext) > $@
+
+cc1-checksum.o : cc1-checksum.c
+
+cc1$(exeext): $(C_OBJS) cc1-checksum.o $(BACKEND) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) cc1-checksum.o \
+	  $(BACKEND) $(LIBS)
+
+# Build the version of limits.h that we will install.
+xlimits.h: glimits.h limitx.h limity.h
+	if $(LIMITS_H_TEST) ; then \
+	  cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
+	else \
+	  cat $(srcdir)/glimits.h > tmp-xlimits.h; \
+	fi
+	mv tmp-xlimits.h xlimits.h
+#
+# Build libgcc.a.
+
+LIB2ADD = $(LIB2FUNCS_EXTRA)
+LIB2ADD_ST = $(LIB2FUNCS_STATIC_EXTRA)
+
+libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) specs \
+		xgcc$(exeext) stamp-as stamp-collect-ld stamp-nm
+	objext='$(objext)' \
+	LIB1ASMFUNCS='$(LIB1ASMFUNCS)' \
+	LIB2FUNCS_ST='$(LIB2FUNCS_ST)' \
+	LIBGCOV='$(LIBGCOV)' \
+	LIB2ADD='$(LIB2ADD)' \
+	LIB2ADD_ST='$(LIB2ADD_ST)' \
+	LIB2ADDEH='$(LIB2ADDEH)' \
+	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC)' \
+	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED)' \
+	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
+	LIB2_SIDITI_CONV_FUNCS='$(LIB2_SIDITI_CONV_FUNCS)' \
+	LIBUNWIND='$(LIBUNWIND)' \
+	LIBUNWINDDEP='$(LIBUNWINDDEP)' \
+	SHLIBUNWIND_LINK='$(SHLIBUNWIND_LINK)' \
+	SHLIBUNWIND_INSTALL='$(SHLIBUNWIND_INSTALL)' \
+	FPBIT='$(FPBIT)' \
+	FPBIT_FUNCS='$(FPBIT_FUNCS)' \
+	LIB2_DIVMOD_FUNCS='$(LIB2_DIVMOD_FUNCS)' \
+	DPBIT='$(DPBIT)' \
+	DPBIT_FUNCS='$(DPBIT_FUNCS)' \
+	TPBIT='$(TPBIT)' \
+	TPBIT_FUNCS='$(TPBIT_FUNCS)' \
+	MULTILIBS=`$(GCC_FOR_TARGET) --print-multi-lib` \
+	EXTRA_MULTILIB_PARTS='$(EXTRA_MULTILIB_PARTS)' \
+	SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_INSTALL='$(SHLIB_INSTALL)' \
+	SHLIB_EXT='$(SHLIB_EXT)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)' \
+	SHLIB_MKMAP='$(SHLIB_MKMAP)' \
+	SHLIB_MKMAP_OPTS='$(SHLIB_MKMAP_OPTS)' \
+	SHLIB_MAPFILES='$(SHLIB_MAPFILES)' \
+	SHLIB_NM_FLAGS='$(SHLIB_NM_FLAGS)' \
+	MULTILIB_OSDIRNAMES='$(MULTILIB_OSDIRNAMES)' \
+	ASM_HIDDEN_OP='$(ASM_HIDDEN_OP)' \
+	GCC_FOR_TARGET='$(GCC_FOR_TARGET)' \
+	mkinstalldirs='$(mkinstalldirs)' \
+	  $(SHELL) mklibgcc > tmp-libgcc.mk
+	mv tmp-libgcc.mk libgcc.mk
+
+# All the things that might cause us to want to recompile bits of libgcc.
+LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \
+	libgcc.mk $(srcdir)/libgcc2.c $(srcdir)/libgcov.c $(TCONFIG_H) \
+	$(MACHMODE_H) longlong.h gbl-ctors.h config.status $(srcdir)/libgcc2.h \
+	tsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
+	$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \
+	$(srcdir)/config/$(LIB1ASMSRC) \
+	$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h
+
+libgcov.a: libgcc.a; @true
+
+libgcc.a: $(LIBGCC_DEPS)
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(TCONFIG_H)" TM_H="$(TM_H)" \
+	  INCLUDES="$(INCLUDES)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk all
+
+# Use the genmultilib shell script to generate the information the gcc
+# driver program needs to select the library directory based on the
+# switches.
+multilib.h: s-mlib; @true
+s-mlib: $(srcdir)/genmultilib Makefile
+	if test @enable_multilib@ = yes \
+	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
+	  $(SHELL) $(srcdir)/genmultilib \
+	    "$(MULTILIB_OPTIONS)" \
+	    "$(MULTILIB_DIRNAMES)" \
+	    "$(MULTILIB_MATCHES)" \
+	    "$(MULTILIB_EXCEPTIONS)" \
+	    "$(MULTILIB_EXTRA_OPTS)" \
+	    "$(MULTILIB_EXCLUSIONS)" \
+	    "$(MULTILIB_OSDIRNAMES)" \
+	    "@enable_multilib@" \
+	    > tmp-mlib.h; \
+	else \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	    > tmp-mlib.h; \
+	fi
+	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
+	$(STAMP) s-mlib
+
+# Build multiple copies of libgcc.a, one for each target switch.
+stmp-multilib: $(LIBGCC_DEPS)
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(CONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk all
+	$(STAMP) stmp-multilib
+
+# Compile two additional files that are linked with every program
+# linked using GCC on systems using COFF or ELF, for the sake of C++
+# constructors.
+$(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN \
+	  -o $(T)crtbegin$(objext)
+
+$(T)crtend.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_END \
+	  -o $(T)crtend$(objext)
+
+# These are versions of crtbegin and crtend for shared libraries.
+$(T)crtbeginS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFS_O \
+	  -o $(T)crtbeginS$(objext)
+
+$(T)crtendS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  -c $(srcdir)/crtstuff.c -DCRT_END -DCRTSTUFFS_O \
+	  -o $(T)crtendS$(objext)
+
+# This is a version of crtbegin for -static links.
+$(T)crtbeginT.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFT_O \
+	  -o $(T)crtbeginT$(objext)
+
+# Compile the start modules crt0.o and mcrt0.o that are linked with
+# every program
+crt0.o: s-crt0 ; @true
+mcrt0.o: s-crt0; @true
+
+s-crt0:	$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o crt0.o -c $(CRT0_S)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o mcrt0.o -c $(MCRT0_S)
+	$(STAMP) s-crt0
+#
+# Compiling object files from source files.
+
+# Note that dependencies on obstack.h are not written
+# because that file is not part of GCC.
+
+# C language specific files.
+
+c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TM_P_H)
+c-parser.o : c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(GGC_H) $(TIMEVAR_H) $(C_TREE_H) input.h $(FLAGS_H) toplev.h output.h \
+    $(CPPLIB_H) gt-c-parser.h langhooks.h $(C_COMMON_H) $(C_PRAGMA_H)
+
+srcextra: gcc.srcextra lang.srcextra
+
+gcc.srcextra: gengtype-lex.c gengtype-yacc.c gengtype-yacc.h
+	-cp -p $^ $(srcdir)
+
+c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
+		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \
+		$(MACHMODE_H)
+
+c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) function.h output.h \
+    $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \
+    opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h \
+    except.h $(LANGHOOKS_DEF_H) $(TREE_DUMP_H) $(C_COMMON_H) $(CPPLIB_H) \
+    $(DIAGNOSTIC_H) input.h langhooks.h $(TREE_GIMPLE_H) tree-mudflap.h  \
+    pointer-set.h
+c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(TREE_H) $(C_TREE_H) $(TARGET_H) $(FLAGS_H) intl.h output.h $(EXPR_H) \
+    $(RTL_H) toplev.h $(TM_P_H) langhooks.h $(GGC_H) $(TREE_FLOW_H) \
+    $(TREE_GIMPLE_H) tree-iterator.h
+c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(DIAGNOSTIC_H) \
+    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h \
+    c-objc-common.h $(C_PRAGMA_H) c-common.def tree-inline.h
+stub-objc.o : stub-objc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    $(C_COMMON_H)
+c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) debug.h $(C_TREE_H) $(C_COMMON_H) real.h $(SPLAY_TREE_H) \
+    $(C_PRAGMA_H) input.h intl.h $(FLAGS_H) toplev.h output.h \
+    $(CPPLIB_H) $(TIMEVAR_H) $(TM_P_H)
+c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(C_COMMON_H) $(TREE_H) $(CPPLIB_H) $(srcdir)/../libcpp/internal.h \
+    $(C_PRAGMA_H)
+c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+    $(TM_H) $(TREE_H) $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \
+    function.h $(FLAGS_H) toplev.h tree-inline.h $(DIAGNOSTIC_H) $(VARRAY_H) \
+    langhooks.h $(GGC_H) $(TARGET_H) $(C_PRETTY_PRINT_H) c-objc-common.h \
+    tree-mudflap.h
+c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(FLAGS_H) toplev.h
+c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(TREE_H) $(FLAGS_H) toplev.h $(C_COMMON_H) convert.h $(C_TREE_H) \
+    langhooks.h
+c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+    $(TREE_H) function.h $(C_PRAGMA_H) toplev.h output.h $(GGC_H) $(TM_P_H) \
+    $(C_COMMON_H) $(TARGET_H) gt-c-pragma.h $(CPPLIB_H) $(FLAGS_H)
+graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(FLAGS_H) output.h \
+    $(RTL_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(OBSTACK_H)
+sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H)
+
+COLLECT2_OBJS = collect2.o tlink.o intl.o version.o
+COLLECT2_LIBS = @COLLECT2_LIBS@
+collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
+# Don't try modifying collect2 (aka ld) in place--it might be linking this.
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o T$@ \
+		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS)
+	mv -f T$@ $@
+
+collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h \
+	$(OBSTACK_H) $(DEMANGLE_H) collect2.h version.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS)  \
+	-DTARGET_MACHINE=\"$(target_noncanonical)\" \
+	-c $(srcdir)/collect2.c $(OUTPUT_OPTION)
+
+tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(OBSTACK_H) collect2.h intl.h
+
+# A file used by all variants of C.
+
+c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(OBSTACK_H) $(C_COMMON_H) $(FLAGS_H) toplev.h output.h $(C_PRAGMA_H) \
+	$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \
+	$(DIAGNOSTIC_H) gt-c-common.h langhooks.h $(VARRAY_H) $(RTL_H) \
+	$(TARGET_H) $(C_TREE_H) tree-iterator.h langhooks.h tree-mudflap.h \
+	intl.h opts.h real.h $(CPPLIB_H) tree-inline.h $(HASHTAB_H) \
+	builtins.def
+
+c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \
+	$(C_TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h \
+	$(DIAGNOSTIC_H) tree-iterator.h
+
+c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)		\
+        $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h langhooks.h		\
+        tree-inline.h $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)	\
+        opts.h options.h $(MKDEPS_H) c-incpath.h cppdefault.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+		$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
+
+c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) version.h $(C_COMMON_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h \
+	output.h except.h real.h $(TARGET_H) $(TM_P_H)
+
+# A file used by all variants of C and some other languages.
+
+attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(FLAGS_H) toplev.h output.h $(RTL_H) $(GGC_H) $(TM_P_H) \
+	$(TARGET_H) langhooks.h $(CPPLIB_H)
+
+c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) langhooks.h \
+	$(C_COMMON_H) $(FLAGS_H) toplev.h intl.h $(DIAGNOSTIC_H) c-format.h
+
+c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(FLAGS_H) toplev.h output.h $(RTL_H) $(GGC_H) \
+	$(PREDICT_H) tree-inline.h $(C_COMMON_H) except.h function.h \
+	langhooks.h $(SPLAY_TREE_H) $(TIMEVAR_H) $(TREE_GIMPLE_H) \
+	$(VARRAY_H)
+
+c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(C_TREE_H) $(TREE_DUMP_H)
+
+c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \
+	$(C_COMMON_H) output.h toplev.h $(C_PRAGMA_H) $(GGC_H) debug.h \
+	langhooks.h $(FLAGS_H) hosthooks.h version.h $(TARGET_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  -DHOST_MACHINE=\"$(host)\" -DTARGET_MACHINE=\"$(target)\" \
+	  $< $(OUTPUT_OPTION)
+
+# Language-independent files.
+
+DRIVER_DEFINES = \
+  -DSTANDARD_STARTFILE_PREFIX=\"$(unlibsubdir)/\" \
+  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
+  -DSTANDARD_LIBEXEC_PREFIX=\"$(libexecdir)/gcc/\" \
+  -DDEFAULT_TARGET_VERSION=\"$(version)\" \
+  -DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\" \
+  -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
+  -DTOOLDIR_BASE_PREFIX=\"$(unlibsubdir)/../\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@ \
+  $(VALGRIND_DRIVER_DEFINES) \
+  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
+  `test "X$${SHLIB_MULTILIB}" = "X" || echo "-DNO_SHARED_LIBGCC_MULTILIB"`
+
+gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
+    Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \
+    configargs.h $(OBSTACK_H)
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gcc.c $(OUTPUT_OPTION))
+
+gccspec.o: gccspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gccspec.c $(OUTPUT_OPTION))
+
+cppspec.o: cppspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+
+build/genchecksum$(build_exeext) : build/genchecksum.o $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genchecksum.o $(BUILD_LIBS)
+
+build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)
+
+dummy-checksum.o : dummy-checksum.c
+
+tree-check.h: s-check ; @true
+s-check : build/gencheck$(build_exeext)
+	$(RUN_GEN) build/gencheck$(build_exeext) > tmp-check.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h
+	$(STAMP) s-check
+
+build/gencheck$(build_exeext) : build/gencheck.o $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/gencheck.o $(BUILD_LIBS)
+
+build/gencheck.o : gencheck.c gencheck.h tree.def $(BCONFIG_H) $(SYSTEM_H) \
+	coretypes.h $(GTM_H) $(lang_tree_files)
+
+gencheck.h : s-gencheck ; @true
+s-gencheck : Makefile
+	ltf="$(lang_tree_files)"; for f in $$ltf; do \
+	    echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' > tmp-gencheck.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-gencheck.h gencheck.h
+	$(STAMP) s-gencheck
+
+specs.h : s-specs ; @true
+s-specs : Makefile
+	lsf="$(lang_specs_files)"; for f in $$lsf; do \
+	    echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' > tmp-specs.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-specs.h specs.h
+	$(STAMP) s-specs
+
+optionlist: s-options ; @true
+s-options: $(ALL_OPT_FILES) Makefile $(srcdir)/opt-gather.awk
+	$(AWK) -f $(srcdir)/opt-gather.awk $(ALL_OPT_FILES) > tmp-optionlist
+	$(SHELL) $(srcdir)/../move-if-change tmp-optionlist optionlist
+	$(STAMP) s-options
+
+options.c: optionlist $(srcdir)/opt-functions.awk $(srcdir)/optc-gen.awk
+	$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/optc-gen.awk \
+	       -v header_name="config.h system.h coretypes.h tm.h" < $< > $@ 
+
+options.h: s-options-h ; @true
+s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk
+	$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opth-gen.awk \
+	       < $< > tmp-options.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-options.h options.h
+	$(STAMP) $@
+
+options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) opts.h intl.h
+
+dumpvers: dumpvers.c
+
+version.o: version.c version.h $(DATESTAMP) $(BASEVER) $(DEVPHASE)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+	-DDEVPHASE=$(DEVPHASE_s) -c $(srcdir)/version.c $(OUTPUT_OPTION)
+
+gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) bitmap.h $(TREE_H) $(RTL_H) \
+	function.h insn-config.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+	cselib.h insn-addr.h $(OPTABS_H) libfuncs.h debug.h $(GGC_H) \
+	$(CGRAPH_H) $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)
+
+ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \
+	$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h $(HOSTHOOKS_DEF_H)
+
+ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+	$(FLAGS_H) toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) $(TREE_FLOW_H)
+
+ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+	$(TREE_H) $(FLAGS_H) toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) \
+	$(PARAMS_H) bitmap.h $(VARRAY_H)
+
+ggc-none.o: ggc-none.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \
+	$(BCONFIG_H)
+
+stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(GGC_H) gt-stringpool.h $(CPPLIB_H) $(SYMTAB_H)
+
+prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \
+	Makefile $(BASEVER)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	-DPREFIX=\"$(prefix)\" -DBASEVER=$(BASEVER_s) \
+	  -c $(srcdir)/prefix.c $(OUTPUT_OPTION)
+
+convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(FLAGS_H) convert.h toplev.h langhooks.h real.h
+
+langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) toplev.h tree-inline.h $(RTL_H) insn-config.h $(INTEGRATE_H) \
+   langhooks.h $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) intl.h \
+   $(TREE_GIMPLE_H)
+tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(FLAGS_H) function.h $(PARAMS_H) \
+   toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \
+   real.h gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
+   $(OBSTACK_H) pointer-set.h
+tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h toplev.h $(SPLAY_TREE_H) $(TREE_DUMP_H) \
+   tree-iterator.h tree-pass.h $(DIAGNOSTIC_H)
+tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h insn-config.h \
+   $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \
+   langhooks.h tree-inline.h $(CGRAPH_H) intl.h function.h $(TREE_GIMPLE_H) \
+   debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \
+   ipa-prop.h
+print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(GGC_H) langhooks.h real.h tree-iterator.h
+stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(PARAMS_H) $(FLAGS_H) function.h $(EXPR_H) $(RTL_H) \
+   $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \
+   toplev.h
+tree-ssa-structalias.o: tree-ssa-structalias.c tree-ssa-structalias.h \
+   $(SYSTEM_H) $(CONFIG_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \
+   $(TM_H) coretypes.h cgraph.h tree-pass.h $(TIMEVAR_H) $(PARAMS_H) \
+   gt-tree-ssa-structalias.h
+tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \
+   toplev.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) langhooks.h tree-pass.h $(BASIC_BLOCK_H) bitmap.h \
+   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \
+   $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H)
+tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \
+   function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   langhooks.h domwalk.h tree-pass.h $(GGC_H) $(PARAMS_H) $(BASIC_BLOCK_H) \
+   bitmap.h $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \
+   $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H)
+tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \
+   function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   langhooks.h tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h \
+   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) $(TREE_GIMPLE_H) \
+   tree-inline.h $(VARRAY_H) toplev.h
+tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) domwalk.h $(FLAGS_H) \
+   $(DIAGNOSTIC_H) $(TIMEVAR_H)
+tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   langhooks.h
+tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \
+   $(DIAGNOSTIC_H) $(TIMEVAR_H)
+tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(RTL_H) function.h $(BASIC_BLOCK_H) $(EXPR_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) tree-pass.h \
+   langhooks.h
+tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) tree-pass.h langhooks.h tree-ssa-propagate.h $(FLAGS_H)
+tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \
+   tree-ssa-propagate.h vec.h gt-tree-ssa-propagate.h $(FLAGS_H) $(VARRAY_H)
+tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h \
+   tree-ssa-propagate.h $(CFGLOOP_H) $(PARAMS_H)
+tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) \
+   langhooks.h tree-ssa-propagate.h
+tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) function.h $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) $(FLAGS_H) tree-pass.h $(CFGLOOP_H)
+tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) gt-tree-ssanames.h  $(TREE_FLOW_H)
+tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
+   gt-tree-phinodes.h $(RTL_H) toplev.h
+domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)
+tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \
+   bitmap.h $(FLAGS_H) $(HASHTAB_H) $(TREE_GIMPLE_H) tree-inline.h \
+   $(VARRAY_H) toplev.h
+tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) tree-pass.h \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \
+   bitmap.h $(FLAGS_H) $(HASHTAB_H) langhooks.h $(TREE_GIMPLE_H) \
+   tree-inline.h
+tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \
+   alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \
+   tree-inline.h tree-iterator.h
+tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \
+   $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \
+   $(TREE_DUMP_H) $(DIAGNOSTIC_H)
+tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \
+   $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \
+   $(CFGLOOP_H) $(SCEV_H) tree-chrec.h $(TIMEVAR_H)
+tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \
+   $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \
+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \
+   tree-ssa-propagate.h
+tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \
+   $(DIAGNOSTIC_H) errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \
+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \
+   tree-ssa-propagate.h $(SCEV_H)
+tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) function.h $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(DIAGNOSTIC_H) except.h tree-pass.h $(FLAGS_H) langhooks.h \
+   $(BASIC_BLOCK_H) hard-reg-set.h
+tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) alloc-pool.h \
+   $(BASIC_BLOCK_H) bitmap.h $(CFGLOOP_H) $(FIBHEAP_H) $(HASHTAB_H) \
+   langhooks.h real.h $(TREE_GIMPLE_H) tree-inline.h tree-iterator.h
+tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \
+   $(RTL_H) $(TM_P_H) function.h $(TREE_DUMP_H) tree-inline.h \
+   tree-iterator.h $(TREE_GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \
+   $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H)
+tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(FLAGS_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
+   $(CFGLOOP_H) $(RTL_H) $(C_COMMON_H) tree-chrec.h $(TREE_DATA_REF_H) \
+   $(SCEV_H) tree-pass.h $(DIAGNOSTIC_H) $(TARGET_H) $(TREE_DUMP_H) \
+   $(VARRAY_H)
+tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   coretypes.h $(GGC_H) tree-iterator.h $(TREE_GIMPLE_H) gt-tree-iterator.h
+tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   tree-inline.h $(HASHTAB_H) pointer-set.h $(FLAGS_H) function.h \
+   $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h $(TREE_DUMP_H) \
+   tree-pass.h $(PARAMS_H) $(CGRAPH_H) $(BASIC_BLOCK_H) hard-reg-set.h \
+   $(TREE_GIMPLE_H) 
+tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h tree-inline.h \
+   $(FLAGS_H) function.h $(TM_H) $(TIMEVAR_H) tree-pass.h toplev.h \
+   gt-tree-ssa-operands.h coretypes.h langhooks.h tree-ssa-opfinalize.h \
+   $(IPA_REFERENCE_H)
+tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) function.h except.h langhooks.h \
+   $(GGC_H) tree-pass.h coretypes.h $(TIMEVAR_H) $(TM_P_H) \
+   $(TREE_DUMP_H) tree-inline.h tree-iterator.h toplev.h
+tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   tree-pass.h $(FLAGS_H) tree-inline.h $(SCEV_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h
+tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \
+   $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \
+   domwalk.h $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(TREE_DUMP_H) tree-pass.h $(BASIC_BLOCK_H) hard-reg-set.h
+tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \
+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   tree-pass.h $(FLAGS_H) tree-inline.h $(RECOG_H) insn-config.h $(EXPR_H) \
+   gt-tree-ssa-address.h $(GGC_H)
+tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \
+   tree-inline.h output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(FLAGS_H) tree-pass.h $(SCEV_H) $(TREE_DATA_REF_H) $(BASIC_BLOCK_H) \
+   $(GGC_H) hard-reg-set.h tree-chrec.h intl.h
+tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \
+   tree-inline.h output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(FLAGS_H) tree-pass.h $(SCEV_H) $(BASIC_BLOCK_H) $(GGC_H) hard-reg-set.h \
+   tree-chrec.h
+tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) hard-reg-set.h
+tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \
+   $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \
+   tree-chrec.h $(VARRAY_H)
+tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   tree-pass.h $(CFGLAYOUT_H) $(SCEV_H) $(BASIC_BLOCK_H) hard-reg-set.h
+tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \
+   $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) real.h $(BASIC_BLOCK_H) \
+   hard-reg-set.h
+tree-ssa-math-opts.o : tree-ssa-math-opts.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(TIMEVAR_H) tree-pass.h $(TM_H) $(FLAGS_H) \
+   alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H)
+tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \
+   function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \
+   $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   hard-reg-set.h $(TREE_GIMPLE_H) vec.h tree-ssa-structalias.h \
+   $(IPA_TYPE_ESCAPE_H)
+tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\
+   $(BASIC_BLOCK_H) $(HASHTAB_H) $(TREE_GIMPLE_H) tree-inline.h
+tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h \
+   function.h langhooks.h $(FLAGS_H) $(CGRAPH_H) tree-inline.h \
+   tree-mudflap.h $(GGC_H) $(CGRAPH_H) tree-pass.h $(CFGLOOP_H) \
+   $(BASIC_BLOCK_H) graph.h hard-reg-set.h
+c-gimplify.o : c-gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   $(C_TREE_H) $(C_COMMON_H) $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(VARRAY_H) \
+   $(FLAGS_H) langhooks.h toplev.h $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \
+   $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h $(TREE_DUMP_H) tree-inline.h
+gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
+   $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) output.h \
+   $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h
+gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
+   $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) tree-pass.h \
+   $(HASHTAB_H) toplev.h
+tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) tree-inline.h $(DIAGNOSTIC_H) $(HASHTAB_H) \
+   $(TM_H) coretypes.h
+tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) real.h $(SCEV_H) tree-pass.h $(PARAMS_H) \
+   $(DIAGNOSTIC_H) $(VARRAY_H) $(CFGLOOP_H) $(TREE_FLOW_H)
+tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) real.h $(RTL_H) \
+   $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+   $(TIMEVAR_H) $(CFGLOOP_H) $(SCEV_H) tree-pass.h $(FLAGS_H) tree-chrec.h
+tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h
+tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) tree-chrec.h
+tree-vect-transform.o: tree-vect-transform.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(OPTABS_H) $(RECOG_H) $(TREE_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+   $(TIMEVAR_H) $(CFGLOOP_H) $(TARGET_H) tree-pass.h $(EXPR_H) \
+   tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) langhooks.h toplev.h \
+   tree-chrec.h
+tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(EXPR_H) tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) \
+   input.h $(TARGET_H) $(CFGLAYOUT_H) toplev.h tree-chrec.h
+tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) $(LAMBDA_H) \
+   $(TARGET_H) tree-chrec.h $(VARRAY_H)
+tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) function.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \
+   tree-stdarg.h $(TARGET_H) langhooks.h
+tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \
+   tree-ssa-propagate.h
+tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \
+   $(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H) \
+   output.h $(TREE_FLOW_H)
+tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) tree-inline.h \
+   $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(CGRAPH_H) $(GGC_H) \
+   gt-tree-mudflap.h $(BASIC_BLOCK_H) $(FLAGS_H) function.h hard-reg-set.h \
+   $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) toplev.h
+tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) tree-inline.h \
+   $(C_TREE_H) $(C_COMMON_H) $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \
+   output.h $(VARRAY_H) langhooks.h tree-mudflap.h $(TM_H) coretypes.h \
+   $(GGC_H) gt-tree-mudflap.h tree-pass.h toplev.h
+tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) real.h $(HASHTAB_H) $(TREE_FLOW_H) \
+   $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h
+fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(FLAGS_H) real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \
+   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H)
+diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) input.h toplev.h intl.h \
+   $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h
+opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \
+   output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \
+   $(FLAGS_H) $(PARAMS_H) tree-pass.h
+targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+   $(EXPR_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h output.h toplev.h \
+   $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H) $(GGC_H) gt-targhooks.h
+
+toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   version.h $(RTL_H) function.h $(FLAGS_H) xcoffout.h input.h \
+   $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) debug.h insn-config.h intl.h \
+   $(RECOG_H) Makefile toplev.h dwarf2out.h sdbout.h dbxout.h $(EXPR_H) \
+   hard-reg-set.h $(BASIC_BLOCK_H) graph.h except.h $(REGS_H) $(TIMEVAR_H) \
+   value-prof.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \
+   langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) hosthooks.h \
+   $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \
+   $(CPPLIB_H) opts.h params.def tree-mudflap.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
+
+passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) function.h $(FLAGS_H) xcoffout.h input.h $(INSN_ATTR_H) output.h \
+   $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) toplev.h \
+   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+   graph.h except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \
+   $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \
+   langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \
+   hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \
+   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h tree-flow.h tree-inline.h
+
+main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h
+
+host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   hosthooks.h $(HOSTHOOKS_DEF_H)
+
+rtl-error.o: rtl-error.c $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(INSN_ATTR_H) insn-config.h input.h toplev.h intl.h $(DIAGNOSTIC_H) \
+   $(CONFIG_H)
+
+rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) real.h \
+  $(GGC_H) $(BCONFIG_H) insn-notes.def reg-notes.def toplev.h
+
+print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h $(FLAGS_H) \
+    $(BCONFIG_H)
+rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
+   $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h \
+   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) function.h
+
+varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(FLAGS_H) function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \
+   output.h $(C_PRAGMA_H) toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \
+   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h real.h $(BASIC_BLOCK_H) \
+   $(CFGLAYOUT_H) $(CGRAPH_H) tree-mudflap.h
+function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(CFGLAYOUT_H) $(TREE_GIMPLE_H) $(FLAGS_H) function.h $(EXPR_H) \
+   $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \
+   output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \
+   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \
+   tree-pass.h
+stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) function.h insn-config.h hard-reg-set.h $(EXPR_H) \
+   libfuncs.h except.h $(RECOG_H) toplev.h output.h $(GGC_H) $(TM_P_H) \
+   langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H) $(MACHMODE_H) \
+   $(REGS_H)
+except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) except.h function.h $(EXPR_H) libfuncs.h \
+   langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \
+   dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H) \
+   gt-except.h $(CGRAPH_H) $(INTEGRATE_H) $(DIAGNOSTIC_H) dwarf2.h \
+   $(TARGET_H) $(TM_P_H) tree-pass.h timevar.h
+expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) \
+   libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
+   typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \
+   $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H) \
+   tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
+   tree-pass.h
+dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
+   langhooks.h $(GGC_H) gt-dojump.h
+builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(TREE_GIMPLE_H) $(FLAGS_H) $(TARGET_H) function.h $(REGS_H) \
+   $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \
+   hard-reg-set.h toplev.h hard-reg-set.h except.h $(TM_P_H) $(PREDICT_H) \
+   libfuncs.h real.h langhooks.h $(BASIC_BLOCK_H) tree-mudflap.h \
+   builtins.def $(MACHMODE_H)
+calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \
+   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) \
+   $(CGRAPH_H) except.h sbitmap.h
+expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) real.h \
+   toplev.h $(TM_P_H) langhooks.h
+explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
+   toplev.h function.h $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h target.h
+optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
+   $(RECOG_H) reload.h toplev.h $(GGC_H) real.h $(TM_P_H) except.h \
+   gt-optabs.h $(BASIC_BLOCK_H) $(TARGET_H) function.h
+dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(FLAGS_H) $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) function.h \
+   langhooks.h insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h \
+   toplev.h $(GGC_H) $(OBSTACK_H) $(EXPR_H) gt-dbxout.h
+debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
+sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) debug.h \
+   $(TREE_H) $(GGC_H) $(RTL_H) $(REGS_H) $(FLAGS_H) insn-config.h \
+   output.h toplev.h $(TM_P_H) gsyms.h langhooks.h $(TARGET_H) sdbout.h \
+   gt-sdbout.h reload.h $(VARRAY_H)
+dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) version.h $(RTL_H) dwarf2.h debug.h $(FLAGS_H) insn-config.h \
+   output.h $(DIAGNOSTIC_H) real.h hard-reg-set.h $(REGS_H) $(EXPR_H) \
+   libfuncs.h toplev.h dwarf2out.h reload.h $(GGC_H) except.h dwarf2asm.h \
+   $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) \
+   $(MD5_H) input.h function.h $(VARRAY_H)
+dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \
+   gt-dwarf2asm.h dwarf2.h $(SPLAY_TREE_H) $(TARGET_H)
+vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) version.h \
+   $(RTL_H) $(FLAGS_H) output.h vmsdbg.h debug.h langhooks.h function.h $(TARGET_H)
+xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) toplev.h output.h dbxout.h \
+   $(GGC_H) $(TARGET_H) gstab.h xcoff.h
+emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \
+   $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \
+   $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h tree-pass.h gt-emit-rtl.h
+real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   toplev.h $(TM_P_H) real.h
+integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \
+   $(EXPR_H) real.h $(REGS_H) intl.h function.h output.h $(RECOG_H) \
+   except.h toplev.h $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h \
+   gt-integrate.h $(GGC_H) tree-pass.h
+jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \
+   hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h \
+   function.h tree-pass.h \
+   toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H) $(TIMEVAR_H) \
+   $(DIAGNOSTIC_H)
+
+simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \
+   $(RECOG_H) $(EXPR_H) toplev.h output.h function.h $(GGC_H) $(TM_P_H) \
+   $(TREE_H) $(TARGET_H)
+cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   langhooks.h toplev.h $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \
+   gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \
+   tree-inline.h $(VARRAY_H) tree-dump.h
+cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H) \
+   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h function.h $(TREE_GIMPLE_H) \
+   $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \
+   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h \
+   gt-cgraphunit.h
+ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) 
+ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \
+   langhooks.h $(GGC_H) target.h $(CGRAPH_H) ipa-prop.h \
+   tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H)
+ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \
+   langhooks.h target.h $(CGRAPH_H) ipa-prop.h  \
+   tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) \
+   diagnostic.h
+ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h tree-inline.h $(FLAGS_H) $(CGRAPH_H) intl.h \
+   $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \
+   $(COVERAGE_H) $(HASHTAB_H)
+ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \
+   pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \
+   $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H) 
+ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(C_COMMON_H) \
+   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  
+ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(C_COMMON_H) $(TARGET_H) \
+   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  
+ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(C_COMMON_H) \
+   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  
+coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \
+   function.h toplev.h $(GGC_H) langhooks.h $(COVERAGE_H) gt-coverage.h \
+   $(HASHTAB_H) $(CGRAPH_H) tree-iterator.h
+cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(RECOG_H) \
+   $(EMIT_RTL_H) toplev.h output.h function.h cselib.h $(GGC_H) $(TM_P_H) \
+   gt-cselib.h $(PARAMS_H) alloc-pool.h $(HASHTAB_H)
+cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \
+   output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \
+   except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h tree-pass.h
+web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \
+   $(DF_H) $(OBSTACK_H) timevar.h tree-pass.h
+gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(GGC_H) \
+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \
+   $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h $(TREE_H) cselib.h $(TIMEVAR_H) \
+   intl.h $(OBSTACK_H) tree-pass.h
+resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(REGS_H) $(FLAGS_H) output.h $(RESOURCE_H) \
+   function.h toplev.h $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)
+lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) \
+   $(BASIC_BLOCK_H) $(TM_P_H) function.h output.h
+mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \
+   $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) function.h output.h \
+   tree-pass.h timevar.h
+tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
+    coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \
+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(TREE_GIMPLE_H) $(CFGLOOP_H) \
+    $(SCEV_H)
+tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \
+   tree-ssa-propagate.h $(FLAGS_H) $(TARGET_H)
+tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \
+    $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) tree-inline.h \
+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \
+    langhooks.h tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) \
+    bitmap.h $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(PARAMS_H) $(TARGET_H)
+tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    $(TM_H) $(RTL_H) real.h $(FLAGS_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) \
+    tree-iterator.h tree-pass.h tree-ssa-propagate.h $(DIAGNOSTIC_H)
+tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+    $(TM_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) tree-iterator.h tree-pass.h \
+    $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \
+    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \
+    coretypes.h insn-codes.h
+df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \
+   $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H)
+var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \
+   $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \
+   $(REGS_H) $(EXPR_H) timevar.h tree-pass.h
+conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \
+   $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)
+profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \
+   toplev.h $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \
+   cfgloop.h timevar.h tree-pass.h
+tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \
+   function.h toplev.h $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \
+   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h
+value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \
+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \
+   $(TREE_H) $(COVERAGE_H) $(RTL_H) $(GCOV_IO_H) $(TREE_FLOW_H) \
+   tree-flow-inline.h timevar.h tree-pass.h
+loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \
+   real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h $(CFGLOOP_H) \
+   toplev.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H) insn-flags.h \
+   timevar.h tree-pass.h
+loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \
+   toplev.h $(CFGLOOP_H) output.h $(PARAMS_H)
+alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)
+flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \
+   hard-reg-set.h output.h toplev.h $(RECOG_H) function.h except.h \
+   $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H) tree-pass.h
+cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \
+   $(REGS_H) hard-reg-set.h output.h toplev.h function.h except.h $(GGC_H) \
+   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H)
+cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h
+cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(TREE_DUMP_H) except.h langhooks.h tree-pass.h $(RTL_H) \
+   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H)
+cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   output.h toplev.h function.h except.h $(TM_P_H) insn-config.h $(EXPR_H) \
+   $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \
+   tree-pass.h
+cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \
+   $(TIMEVAR_H) $(OBSTACK_H) toplev.h
+cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \
+   function.h except.h $(TIMEVAR_H) $(TREE_H)
+cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \
+   toplev.h insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \
+   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h cfgloop.h expr.h
+cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) function.h \
+   $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H)
+cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) \
+   $(OBSTACK_H) output.h
+loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \
+   output.h intl.h
+loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h \
+   $(TM_H) $(TM_P_H) function.h $(FLAGS_H) $(DF_H) $(OBSTACK_H) output.h
+cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h \
+   coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H)
+loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \
+   coretypes.h $(TM_H) $(OBSTACK_H) tree-pass.h timevar.h $(FLAGS_H)
+loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)
+loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) $(VARRAY_H) \
+   $(OBSTACK_H)
+dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) toplev.h
+et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   et-forest.h alloc-pool.h $(BASIC_BLOCK_H)
+combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \
+   rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h \
+   toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \
+   insn-codes.h timevar.h tree-pass.h
+regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \
+   $(RECOG_H) reload.h real.h toplev.h function.h output.h $(GGC_H) \
+   $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-regclass.h $(HASHTAB_H)
+local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \
+   output.h function.h $(INSN_ATTR_H) toplev.h  except.h reload.h $(TM_P_H) \
+   $(GGC_H) $(INTEGRATE_H) timevar.h tree-pass.h
+bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(GGC_H) gt-bitmap.h bitmap.h $(OBSTACK_H)
+global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) reload.h function.h $(RECOG_H) $(REGS_H) hard-reg-set.h \
+   insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \
+   timevar.h
+varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \
+   $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) toplev.h
+vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h $(GGC_H) \
+   toplev.h
+reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) output.h $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \
+   hard-reg-set.h insn-config.h $(REGS_H) function.h real.h toplev.h \
+   $(TM_P_H) $(PARAMS_H) $(TARGET_H)
+reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \
+   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h $(TM_P_H) \
+   except.h $(TREE_H) real.h $(FLAGS_H) $(MACHMODE_H) $(OBSTACK_H)
+rtlhooks.o :  rtlhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   rtlhooks-def.h $(EXPR_H) $(RECOG_H)
+postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) real.h $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \
+   hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \
+   function.h toplev.h cselib.h $(TM_P_H) except.h $(TREE_H) $(MACHMODE_H) \
+   $(OBSTACK_H) timevar.h tree-pass.h
+postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \
+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \
+   $(TM_P_H) except.h $(TREE_H) $(TARGET_H) $(HASHTAB_H) intl.h $(OBSTACK_H) \
+   $(PARAMS_H) timevar.h tree-pass.h
+caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \
+   $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)
+bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) except.h \
+   $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h $(EXPR_H) \
+   $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) function.h tree-pass.h toplev.h
+reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   conditions.h hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \
+   $(INSN_ATTR_H) except.h $(RECOG_H) function.h $(FLAGS_H) output.h \
+   $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H) $(OBSTACK_H) $(RESOURCE_H) \
+   timevar.h target.h tree-pass.h
+alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h \
+   $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) \
+   langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \
+   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) tree-pass.h
+regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h timevar.h tree-pass.h \
+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) function.h \
+   $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h
+ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \
+   toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) function.h \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \
+   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) bitmap.h $(DF_H) \
+   hard-reg-set.h sbitmap.h $(TM_H)
+modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TARGET_H) toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) function.h \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \
+   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \
+   cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H) timevar.h tree-pass.h
+haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h function.h \
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)
+sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h \
+   $(PARAMS_H) $(TM_P_H) $(DF_H)
+sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(PARAMS_H) \
+   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) timevar.h tree-pass.h
+sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) \
+   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H)
+sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) \
+   $(REGS_H) $(TM_P_H) $(TARGET_H) real.h toplev.h
+final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) intl.h $(REGS_H) $(RECOG_H) conditions.h \
+   insn-config.h $(INSN_ATTR_H) function.h real.h output.h hard-reg-set.h \
+   except.h debug.h xcoffout.h toplev.h reload.h dwarf2out.h tree-pass.h \
+   $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) $(CFGLAYOUT_H) dbxout.h \
+   timevar.h cgraph.h $(COVERAGE_H)
+recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   function.h $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) real.h toplev.h output.h reload.h \
+   $(TM_P_H) timevar.h tree-pass.h
+reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \
+   insn-config.h toplev.h reload.h function.h $(TM_P_H) $(GGC_H) \
+   gt-reg-stack.h $(BASIC_BLOCK_H) output.h $(VARRAY_H) timevar.h tree-pass.h \
+   target.h
+sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h
+predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \
+   hard-reg-set.h output.h toplev.h $(RECOG_H) function.h except.h $(EXPR_H) \
+   $(TM_P_H) $(PREDICT_H) sreal.h $(PARAMS_H) $(TARGET_H) $(CFGLOOP_H) \
+   $(COVERAGE_H) $(SCEV_H) $(GGC_H) predict.def $(TIMEVAR_H) $(TREE_DUMP_H) \
+   $(TREE_FLOW_H) tree-pass.h
+lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
+   $(RTL_H) $(GGC_H) gt-lists.h
+bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \
+   $(TARGET_H) function.h $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) \
+   $(PARAMS_H) toplev.h tree-pass.h
+tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h $(CFGLAYOUT_H) \
+   $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H) \
+   tree-pass.h
+cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \
+   function.h $(CFGLAYOUT_H) $(CFGLOOP_H) $(TARGET_H) gt-cfglayout.h \
+   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) tree-pass.h
+timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TIMEVAR_H) $(FLAGS_H) intl.h toplev.h $(RTL_H) timevar.def
+regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   output.h $(RECOG_H) function.h $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \
+   reload.h toplev.h timevar.h tree-pass.h
+ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) toplev.h $(FLAGS_H) insn-config.h function.h $(RECOG_H) \
+   $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) \
+   real.h $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h timevar.h tree-pass.h
+lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) coretypes.h $(TREE_H) $(VARRAY_H)
+lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H) $(VARRAY_H)
+lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) coretypes.h $(TARGET_H) \
+   tree-chrec.h tree-pass.h vec.h
+params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h
+pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)
+hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)
+pretty-print.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h $(PRETTY_PRINT_H) \
+   $(TREE_H)
+errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h $(BCONFIG_H)
+
+$(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) $(GGC_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \
+   output.h $(INSN_ATTR_H) $(SYSTEM_H) toplev.h $(TARGET_H) libfuncs.h \
+   $(TARGET_DEF_H) function.h $(SCHED_INT_H) $(TM_P_H) $(EXPR_H) $(OPTABS_H) \
+   langhooks.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+		$(out_file) $(OUTPUT_OPTION)
+
+# Build auxiliary files that support ecoff format.
+mips-tfile: mips-tfile.o version.o $(LIBDEPS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mips-tfile.o version.o $(LIBS)
+
+mips-tfile.o : mips-tfile.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) version.h $(srcdir)/../include/getopt.h gstab.h intl.h
+
+mips-tdump: mips-tdump.o version.o $(LIBDEPS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mips-tdump.o version.o $(LIBS)
+
+mips-tdump.o : mips-tdump.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) version.h $(srcdir)/../include/getopt.h stab.def
+
+# FIXME: writing proper dependencies for this is a *LOT* of work.
+libbackend.o : $(OBJS-common:.o=.c) $(out_file) \
+  insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-attr.h  $(DATESTAMP) $(BASEVER) $(DEVPHASE)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(filter %.c,$^) -o $@  \
+	  -DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+	  -DDEVPHASE=$(DEVPHASE_s) -combine
+
+#
+# Generate header and source files from the machine description,
+# and compile them.
+
+.PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \
+  insn-attr.h insn-attrtab.c insn-preds.c
+
+# Dependencies for the md file.  The first time through, we just assume
+# the md file itself and the generated dependency file (in order to get
+# it built).  The second time through we have the dependency file.
+-include mddeps.mk
+MD_DEPS = s-mddeps $(md_file) $(MD_INCLUDES)
+
+s-mddeps: $(md_file) $(MD_INCLUDES) build/genmddeps$(build_exeext)
+	$(RUN_GEN) build/genmddeps$(build_exeext) $(md_file) > tmp-mddeps
+	$(SHELL) $(srcdir)/../move-if-change tmp-mddeps mddeps.mk
+	$(STAMP) s-mddeps
+
+# The following pair of rules has this effect:
+# genconfig is run only if the md has changed since genconfig was last run;
+# but the file insn-config.h is touched only when its contents actually change.
+
+# Each of the other insn-* files is handled by a similar pair of rules.
+
+# This causes an anomaly in the results of make -n
+# because insn-* is older than s-*
+# and thus make -n thinks that insn-* will be updated
+# and force recompilation of things that depend on it.
+# We use move-if-change precisely to avoid such recompilation.
+# But there is no way to teach make -n that it will be avoided.
+
+# Each of the insn-*.[ch] rules has a semicolon at the end,
+# for otherwise the system Make on SunOS 4.1 never tries
+# to recompile insn-*.o.  To avoid problems and extra noise from
+# versions of make which don't like empty commands (nothing after the
+# trailing `;'), we call true for each.
+
+insn-config.h: s-config ; @true
+s-config : $(MD_DEPS) build/genconfig$(build_exeext)
+	$(RUN_GEN) build/genconfig$(build_exeext) $(md_file) > tmp-config.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-config.h insn-config.h
+	$(STAMP) s-config
+
+insn-conditions.c: s-conditions ; @true
+s-conditions : $(MD_DEPS) build/genconditions$(build_exeext)
+	$(RUN_GEN) build/genconditions$(build_exeext) $(md_file) > tmp-conditions.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-conditions.c insn-conditions.c
+	$(STAMP) s-conditions
+
+build/insn-conditions.o : insn-conditions.c $(CONFIG_H) $(SYSTEM_H) \
+  $(GTM_H) $(RTL_H) $(TM_P_H) $(REGS_H) function.h $(RECOG_H) real.h output.h \
+  $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) toplev.h reload.h gensupport.h \
+  insn-constants.h coretypes.h
+
+build/dummy-conditions.o : dummy-conditions.c
+
+insn-flags.h: s-flags ; @true
+s-flags : $(MD_DEPS) build/genflags$(build_exeext)
+	$(RUN_GEN) build/genflags$(build_exeext) $(md_file) > tmp-flags.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-flags.h insn-flags.h
+	$(STAMP) s-flags
+
+insn-codes.h: s-codes ; @true
+s-codes : $(MD_DEPS) build/gencodes$(build_exeext)
+	$(RUN_GEN) build/gencodes$(build_exeext) $(md_file) > tmp-codes.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-codes.h insn-codes.h
+	$(STAMP) s-codes
+
+insn-constants.h: s-constants ; @true
+s-constants : $(MD_DEPS) build/genconstants$(build_exeext)
+	$(RUN_GEN) build/genconstants$(build_exeext) $(md_file) > tmp-constants.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-constants.h insn-constants.h
+	$(STAMP) s-constants
+
+insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(EXPR_H) real.h output.h insn-config.h $(OPTABS_H) reload.h \
+  $(RECOG_H) toplev.h function.h $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) \
+  $(TM_P_H) $(BASIC_BLOCK_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-emit.c \
+	  $(OUTPUT_OPTION)
+
+insn-emit.c: s-emit ; @true
+s-emit : $(MD_DEPS) build/genemit$(build_exeext)
+	$(RUN_GEN) build/genemit$(build_exeext) $(md_file) > tmp-emit.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-emit.c insn-emit.c
+	$(STAMP) s-emit
+
+insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) insn-config.h $(RECOG_H) real.h output.h $(FLAGS_H)  function.h \
+  hard-reg-set.h $(RESOURCE_H) $(TM_P_H) toplev.h reload.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-recog.c \
+	  $(OUTPUT_OPTION)
+
+insn-recog.c: s-recog ; @true
+s-recog : $(MD_DEPS) build/genrecog$(build_exeext)
+	$(RUN_GEN) build/genrecog$(build_exeext) $(md_file) > tmp-recog.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-recog.c insn-recog.c
+	$(STAMP) s-recog
+
+insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) insn-config.h $(FLAGS_H) $(RECOG_H) $(EXPR_H) $(OPTABS_H) reload.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-opinit.c \
+	  $(OUTPUT_OPTION)
+
+insn-opinit.c: s-opinit ; @true
+s-opinit : $(MD_DEPS) build/genopinit$(build_exeext)
+	$(RUN_GEN) build/genopinit$(build_exeext) $(md_file) > tmp-opinit.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-opinit.c insn-opinit.c
+	$(STAMP) s-opinit
+
+insn-extract.o : insn-extract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) toplev.h insn-config.h $(RECOG_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-extract.c \
+	  $(OUTPUT_OPTION)
+
+insn-extract.c: s-extract ; @true
+s-extract : $(MD_DEPS) build/genextract$(build_exeext)
+	$(RUN_GEN) build/genextract$(build_exeext) $(md_file) > tmp-extract.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-extract.c insn-extract.c
+	$(STAMP) s-extract
+
+insn-peep.o : insn-peep.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(REGS_H) output.h real.h insn-config.h $(RECOG_H) except.h \
+  function.h $(TM_P_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-peep.c \
+	  $(OUTPUT_OPTION)
+
+insn-peep.c: s-peep ; @true
+s-peep : $(MD_DEPS) build/genpeep$(build_exeext)
+	$(RUN_GEN) build/genpeep$(build_exeext) $(md_file) > tmp-peep.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-peep.c insn-peep.c
+	$(STAMP) s-peep
+
+insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(REGS_H) real.h output.h $(INSN_ATTR_H) insn-config.h toplev.h \
+  $(RECOG_H) $(TM_P_H) $(FLAGS_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-attrtab.c \
+	  $(OUTPUT_OPTION)
+
+insn-attr.h: s-attr ; @true
+s-attr : $(MD_DEPS) build/genattr$(build_exeext)
+	$(RUN_GEN) build/genattr$(build_exeext) $(md_file) > tmp-attr.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-attr.h insn-attr.h
+	$(STAMP) s-attr
+
+insn-attrtab.c: s-attrtab ; @true
+s-attrtab : $(MD_DEPS) build/genattrtab$(build_exeext)
+	$(RUN_GEN) build/genattrtab$(build_exeext) $(md_file) > tmp-attrtab.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-attrtab.c insn-attrtab.c
+	$(STAMP) s-attrtab
+
+insn-output.o : insn-output.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(GGC_H) $(REGS_H) real.h conditions.h hard-reg-set.h \
+  insn-config.h $(INSN_ATTR_H) $(EXPR_H) output.h $(RECOG_H) function.h \
+  toplev.h $(FLAGS_H) insn-codes.h $(TM_P_H) $(TARGET_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) -c insn-output.c \
+	  $(OUTPUT_OPTION)
+
+insn-output.c: s-output ; @true
+s-output : $(MD_DEPS) build/genoutput$(build_exeext)
+	$(RUN_GEN) build/genoutput$(build_exeext) $(md_file) > tmp-output.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-output.c insn-output.c
+	$(STAMP) s-output
+
+genrtl.o : genrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+  $(GGC_H)
+genrtl.c genrtl.h : s-genrtl
+	@true	# force gnu make to recheck modification times.
+
+s-genrtl: build/gengenrtl$(build_exeext)
+	$(RUN_GEN) build/gengenrtl$(build_exeext) -h > tmp-genrtl.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-genrtl.h genrtl.h
+	$(RUN_GEN) build/gengenrtl$(build_exeext) > tmp-genrtl.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-genrtl.c genrtl.c
+	$(STAMP) s-genrtl
+
+insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	       $(MACHMODE_H) real.h
+min-insn-modes.c insn-modes.c insn-modes.h : s-modes ; @true
+
+s-modes: build/genmodes$(build_exeext)
+	$(RUN_GEN) build/genmodes$(build_exeext) -h > tmp-modes.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes.h insn-modes.h
+	$(RUN_GEN) build/genmodes$(build_exeext) -m > tmp-min-modes.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-min-modes.c min-insn-modes.c
+	$(RUN_GEN) build/genmodes$(build_exeext) > tmp-modes.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes.c insn-modes.c
+	$(STAMP) s-modes
+
+insn-preds.c tm-preds.h: s-preds; @true
+
+s-preds: $(MD_DEPS) build/genpreds$(build_exeext)
+	$(RUN_GEN) build/genpreds$(build_exeext) -h $(md_file) > tmp-preds.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-preds.h tm-preds.h
+	$(RUN_GEN) build/genpreds$(build_exeext) $(md_file) > tmp-preds.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-preds.c insn-preds.c
+	$(STAMP) s-preds
+
+insn-preds.o : insn-preds.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(TREE_H) insn-config.h $(RECOG_H) real.h output.h $(FLAGS_H) \
+  function.h hard-reg-set.h $(RESOURCE_H) $(TM_P_H) toplev.h reload.h \
+  $(REGS_H)
+
+GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \
+  $(CPP_ID_DATA_H) $(host_xm_file_list) \
+  $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \
+  $(srcdir)/coverage.c $(srcdir)/function.h $(srcdir)/rtl.h \
+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(SYMTAB_H) \
+  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \
+  $(srcdir)/ipa-reference.h \
+  $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \
+  $(srcdir)/c-common.h $(srcdir)/c-tree.h $(srcdir)/reload.h \
+  $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \
+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/cgraphunit.c \
+  $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \
+  $(srcdir)/dojump.c $(srcdir)/tree-profile.c \
+  $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \
+  $(srcdir)/function.c $(srcdir)/except.h \
+  $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \
+  $(srcdir)/profile.c $(srcdir)/regclass.c \
+  $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c \
+  $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \
+  $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \
+  $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \
+  $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parser.c \
+  $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \
+  $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \
+  $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \
+  $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \
+  $(srcdir)/tree-chrec.h $(srcdir)/tree-vect-generic.c \
+  $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \
+  $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \
+  $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \
+  $(srcdir)/tree-ssa-structalias.c \
+  $(srcdir)/targhooks.c $(out_file) \
+  @all_gtfiles@
+
+GTFILES_FILES_LANGS = @all_gtfiles_files_langs@
+GTFILES_FILES_FILES = @all_gtfiles_files_files@
+GTFILES_LANG_DIR_NAMES = @subdirs@
+GTFILES_SRCDIR = @srcdir@
+
+gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \
+gt-function.h gt-integrate.h gt-tree.h gt-varasm.h \
+gt-emit-rtl.h gt-explow.h gt-stor-layout.h gt-regclass.h \
+gt-lists.h gt-alias.h gt-cselib.h gt-gcse.h \
+gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
+gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \
+gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \
+gt-c-pragma.h gtype-c.h gt-cfglayout.h \
+gt-tree-mudflap.h gt-tree-vect-generic.h \
+gt-tree-profile.h gt-tree-ssa-address.h \
+gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \
+gt-tree-phinodes.h gt-tree-nested.h \
+gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \
+gt-tree-ssa-structalias.h gt-cgraphunit.h \
+gt-stringpool.h gt-targhooks.h : s-gtype ; @true
+
+define echo_quoted_to_gtyp
+ echo "\"$(gtyp)\", " >> tmp-gtyp.h
+
+endef
+
+gtyp-gen.h: s-gtyp-gen ; @true
+s-gtyp-gen: Makefile
+	echo "/* This file is machine generated.  Do not edit.  */" > tmp-gtyp.h
+	echo "static const char *const srcdir = "  >> tmp-gtyp.h
+	echo "\"$(GTFILES_SRCDIR)\"" >> tmp-gtyp.h
+	echo ";" >> tmp-gtyp.h
+	echo "static const char *const lang_files[] = {" >> tmp-gtyp.h
+	$(foreach gtyp,$(GTFILES_FILES_FILES),$(echo_quoted_to_gtyp))
+	echo "NULL};" >> tmp-gtyp.h
+	echo "static const char *const langs_for_lang_files[] = {" >> tmp-gtyp.h
+	$(foreach gtyp,$(GTFILES_FILES_LANGS),$(echo_quoted_to_gtyp))
+	echo "NULL};" >> tmp-gtyp.h
+	echo "static const char *const all_files[] = {" >> tmp-gtyp.h
+	$(foreach gtyp,$(GTFILES),$(echo_quoted_to_gtyp))
+	echo " NULL};" >> tmp-gtyp.h
+	echo "static const char *const lang_dir_names[] = { \"c\", " >> tmp-gtyp.h
+	$(foreach gtyp,$(GTFILES_LANG_DIR_NAMES),$(echo_quoted_to_gtyp))
+	echo "NULL};" >> tmp-gtyp.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-gtyp.h gtyp-gen.h
+	$(STAMP) s-gtyp-gen
+
+s-gtype: build/gengtype$(build_exeext) $(GTFILES)
+	$(RUN_GEN) build/gengtype$(build_exeext)
+	$(STAMP) s-gtype
+
+#
+# Compile the programs that generate insn-* from the machine description.
+# They are compiled with $(CC_FOR_BUILD), and associated libraries,
+# since they need to run on this machine
+# even if GCC is being compiled to run on some other machine.
+
+# $(CONFIG_H) is omitted from the deps of the gen*.o
+# because these programs don't really depend on anything
+# about the target machine.  They do depend on config.h itself,
+# since that describes the host machine.
+
+# The names of programs that run on the "build" machine.
+genprognames=genconfig genflags gencodes genemit genopinit genrecog \
+	     genextract genpeep genattr genoutput
+
+# The names of the executable files for those programs.
+genprogs=$(genprognames:%=build/%$(build_exeext))
+
+# Object files used in those programs.
+genobjnames=$(genprognames:%=%.o) read-rtl.o gensupport.o genattrtab.o \
+        genautomata.o gengenrtl.o genmodes.o genpreds.o gengtype.o \
+	genconstants.o gen-protos.o scan.o fix-header.o scan-decls.o \
+	gencheck.o dummy-conditions.o genconditions.o errors.o ggc-none.o \
+	min-insn-modes.o rtl.o print-rtl.o varray.o gcov-iov.o \
+	insn-conditions.o gengtype-lex.o gengtype-yacc.o genmddeps.o \
+	genchecksum.o
+
+genobjs=$(genobjnames:%=build/%)
+
+$(genprogs): %$(build_exeext): %.o  $(BUILD_RTL) $(BUILD_SUPPORT) \
+			       $(BUILD_PRINT) $(BUILD_ERRORS) \
+	                       $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+		$< $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) \
+		$(BUILD_ERRORS) $(BUILD_LIBS)
+
+$(genobjs): %.o :  # dependencies provided by explicit rule later
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) -o $@ $<
+
+build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H)
+
+build/gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) errors.h $(HASHTAB_H) gensupport.h
+
+build/genconfig.o : genconfig.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/gencodes.o : gencodes.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genmddeps$(build_exeext) : build/genmddeps.o $(BUILD_RTL) \
+  $(BUILD_EARLY_SUPPORT) $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genmddeps.o $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) \
+	 $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) $(RTL_BASE_H) errors.h gensupport.h
+
+build/genconstants$(build_exeext) : build/genconstants.o $(BUILD_RTL) \
+  $(BUILD_EARLY_SUPPORT) $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genconstants.o $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) \
+	 $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/genconstants.o : genconstants.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) errors.h
+
+build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genrecog.o : genrecog.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) insn-config.h errors.h gensupport.h
+
+build/genpeep.o : genpeep.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/genattrtab$(build_exeext) : build/genattrtab.o build/genautomata.o \
+  $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) $(BUILD_ERRORS) \
+  $(BUILD_VARRAY) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genattrtab.o build/genautomata.o \
+	 $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) $(BUILD_ERRORS) \
+	 $(BUILD_VARRAY) $(BUILD_LIBS) -lm
+
+build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H) gensupport.h genattrtab.h
+
+build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VARRAY_H) genattrtab.h \
+  $(HASHTAB_H)
+
+build/genoutput.o : genoutput.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+build/gengenrtl$(build_exeext) : build/gengenrtl.o $(BUILD_ERRORS) \
+  $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/gengenrtl.o $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def
+
+build/genmodes$(build_exeext) : build/genmodes.o $(BUILD_ERRORS) \
+  $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genmodes.o $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h $(HASHTAB_H) \
+	     machmode.def $(extra_modes_file)
+
+build/genpreds$(build_exeext) : build/genpreds.o $(BUILD_RTL) \
+  $(BUILD_EARLY_SUPPORT) $(BUILD_PRINT) $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genpreds.o $(BUILD_RTL) $(BUILD_EARLY_SUPPORT) $(BUILD_PRINT) \
+	 $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) errors.h gensupport.h $(OBSTACK_H)
+
+build/gengtype$(build_exeext) : build/gengtype.o build/gengtype-lex.o \
+  build/gengtype-yacc.o $(BUILD_LIBDEPS) $(BUILD_ERRORS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/gengtype.o build/gengtype-lex.o build/gengtype-yacc.o \
+	 $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  gengtype.h gtyp-gen.h rtl.def insn-notes.def errors.h
+
+build/gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h \
+  $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) vec.h
+
+build/gengtype-yacc.o : gengtype-yacc.c gengtype.h $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H)
+
+gengtype-lex.c : gengtype-lex.l
+	-$(FLEX) $(FLEXFLAGS) -o$@ $<
+
+gengtype-yacc.c gengtype-yacc.h: gengtype-yacc.y
+	-$(BISON) $(BISONFLAGS) -d -o gengtype-yacc.c $<
+
+build/genconditions$(build_exeext) : build/genconditions.o \
+  $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/genconditions.o $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) \
+	 $(BUILD_ERRORS) $(BUILD_LIBS)
+
+build/genconditions.o : genconditions.c $(RTL_BASE_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h
+
+build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h
+build/ggc-none.o : ggc-none.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H)
+build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H) \
+  $(MACHMODE_H)
+build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) $(RTL_H) \
+  real.h $(GGC_H) errors.h
+build/print-rtl.o: print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  $(RTL_BASE_H)
+build/varray.o: varray.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) \
+  $(VARRAY_H) $(RTL_BASE_H) $(GGC_H) $(TREE_H) bitmap.h errors.h
+
+#
+# Remake internationalization support.
+intl.o: intl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h Makefile
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(srcdir)/intl.c $(OUTPUT_OPTION)
+
+#
+# Remake cpp and protoize.
+
+PREPROCESSOR_DEFINES = \
+  -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
+  -DGPLUSPLUS_INCLUDE_DIR=\"$(gcc_gxx_include_dir)\" \
+  -DGPLUSPLUS_TOOL_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/$(target_noncanonical)\" \
+  -DGPLUSPLUS_BACKWARD_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/backward\" \
+  -DLOCAL_INCLUDE_DIR=\"$(local_includedir)\" \
+  -DCROSS_INCLUDE_DIR=\"$(CROSS_SYSTEM_HEADER_DIR)\" \
+  -DTOOL_INCLUDE_DIR=\"$(gcc_tooldir)/include\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@
+
+cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	cppdefault.h Makefile
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  $(PREPROCESSOR_DEFINES) \
+	  -c $(srcdir)/cppdefault.c $(OUTPUT_OPTION)
+
+# Note for the stamp targets, we run the program `true' instead of
+# having an empty command (nothing following the semicolon).
+
+proto: config.status protoize$(exeext) unprotoize$(exeext) SYSCALLS.c.X
+
+PROTO_OBJS = intl.o version.o cppdefault.o errors.o
+
+protoize$(exeext): protoize.o $(PROTO_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ protoize.o $(PROTO_OBJS) $(LIBS)
+
+unprotoize$(exeext): unprotoize.o $(PROTO_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ unprotoize.o $(PROTO_OBJS) $(LIBS)
+
+protoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) Makefile version.h cppdefault.h intl.h
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  $(DRIVER_DEFINES) \
+	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
+
+unprotoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) \
+    $(SYSTEM_H) coretypes.h $(TM_H) Makefile version.h cppdefault.h intl.h
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) -c -DUNPROTOIZE $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+	  $(DRIVER_DEFINES) \
+	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
+
+# This info describes the target machine, so compile with GCC just built.
+SYSCALLS.c.X: $(srcdir)/sys-types.h $(srcdir)/sys-protos.h $(GCC_PASSES) \
+   stmp-int-hdrs
+	-rm -f SYSCALLS.c tmp-SYSCALLS.s
+	sed -e s/TARGET_GETGROUPS_T/$(TARGET_GETGROUPS_T)/ \
+	  $(srcdir)/sys-types.h $(srcdir)/sys-protos.h > SYSCALLS.c
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) \
+	  -aux-info $@ -S -o tmp-SYSCALLS.s SYSCALLS.c
+	-rm -f SYSCALLS.c tmp-SYSCALLS.s
+
+
+test-protoize-simple: ./protoize ./unprotoize $(GCC_PASSES)
+	-rm -f tmp-proto.[cso]
+	cp $(srcdir)/protoize.c tmp-proto.c
+	chmod u+w tmp-proto.c
+	./protoize -N -B ./ -x getopt.h -c "-B./ -Wall -Wwrite-strings \
+	  $(GCC_CFLAGS) $(INCLUDES) \
+	  -DGCC_INCLUDE_DIR=0 \
+	  -DGPLUSPLUS_INCLUDE_DIR=0 \
+	  -DCROSS_INCLUDE_DIR=0 \
+	  -DTOOL_INCLUDE_DIR=0 \
+	  -DSTANDARD_EXEC_PREFIX=0 \
+	  -DDEFAULT_TARGET_MACHINE=0 \
+	  -DDEFAULT_TARGET_VERSION=0" tmp-proto.c
+	@echo '**********' Expect 400 lines of differences.
+	-diff $(srcdir)/protoize.c tmp-proto.c > tmp-proto.diff
+	-wc -l tmp-proto.diff
+	./unprotoize -N -x getopt.h -c "-B./ -Wall -Wwrite-strings \
+	  $(GCC_CFLAGS) $(INCLUDES) \
+	  -DGCC_INCLUDE_DIR=0 \
+	  -DGPLUSPLUS_INCLUDE_DIR=0 \
+	  -DCROSS_INCLUDE_DIR=0 \
+	  -DTOOL_INCLUDE_DIR=0 \
+	  -DSTANDARD_EXEC_PREFIX=0 \
+	  -DDEFAULT_TARGET_MACHINE=0 \
+	  -DDEFAULT_TARGET_VERSION=0" tmp-proto.c
+	@echo Expect zero differences.
+	diff $(srcdir)/protoize.c tmp-proto.c | cat
+	-rm -f tmp-proto.[cs] tmp-proto$(objext)
+
+# gcov-iov.c is run on the build machine to generate gcov-iov.h from version.c
+build/gcov-iov.o: gcov-iov.c $(BCONFIG_H) coretypes.h $(GTM_H) \
+  $(SYSTEM_H) coretypes.h $(TM_H)
+ 
+build/gcov-iov$(build_exeext): build/gcov-iov.o
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) build/gcov-iov.o -o $@
+
+gcov-iov.h: s-iov
+s-iov: build/gcov-iov$(build_exeext) $(BASEVER) $(DEVPHASE)
+	build/gcov-iov$(build_exeext) '$(BASEVER_c)' '$(DEVPHASE_c)' \
+	    > tmp-gcov-iov.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-gcov-iov.h gcov-iov.h
+	$(STAMP) s-iov
+
+gcov.o: gcov.c gcov-io.c $(GCOV_IO_H) intl.h $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(CONFIG_H) version.h
+gcov-dump.o: gcov-dump.c gcov-io.c $(GCOV_IO_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(CONFIG_H)
+
+GCOV_OBJS = gcov.o intl.o version.o errors.o
+gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@
+GCOV_DUMP_OBJS = gcov-dump.o version.o errors.o
+gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) $(LIBS) -o $@
+#
+# Build the include directory.  The stamp files are stmp-* rather than
+# s-* so that mostlyclean does not force the include directory to
+# be rebuilt.
+
+# Build the include directory
+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h $(UNWIND_H)
+# Copy in the headers provided with gcc.
+# The sed command gets just the last file name component;
+# this is necessary because VPATH could add a dirname.
+# Using basename would be simpler, but some systems don't have it.
+# The touch command is here to workaround an AIX/Linux NFS bug.
+	-if [ -d include ] ; then true; else mkdir include; chmod a+rx include; fi
+	for file in .. $(USER_H); do \
+	  if [ X$$file != X.. ]; then \
+	    realfile=`echo $$file | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(STAMP) include/$$realfile; \
+	    rm -f include/$$realfile; \
+	    cp $$file include; \
+	    chmod a+r include/$$realfile; \
+	  fi; \
+	done
+	rm -f include/limits.h
+	cp xlimits.h include/limits.h
+	cp $(UNWIND_H) include/unwind.h
+	chmod a+r include/limits.h
+# Install the README
+	rm -f include/README
+	cp $(srcdir)/../fixincludes/README-fixinc include/README
+	chmod a+r include/README
+	$(STAMP) $@
+
+.PHONY: install-gcc-tooldir
+install-gcc-tooldir:
+	$(mkinstalldirs) $(DESTDIR)$(gcc_tooldir)
+
+macro_list: s-macro_list; @true
+s-macro_list : $(GCC_PASSES) 
+	echo | $(GCC_FOR_TARGET) -E -dM - | \
+	  sed -n -e 's/^#define \([^_][a-zA-Z0-9_]*\).*/\1/p' \
+		-e 's/^#define \(_[^_A-Z][a-zA-Z0-9_]*\).*/\1/p' | \
+	  sort -u > tmp-macro_list
+	$(SHELL) $(srcdir)/../move-if-change tmp-macro_list macro_list
+	$(STAMP) s-macro_list
+
+# The line below is supposed to avoid accidentally matching the
+# built-in suffix rule `.o:' to build fixincl out of fixincl.o.  You'd
+# expect fixincl to be newer than fixincl.o, such that this situation
+# would never come up.  As it turns out, if you use ccache with
+# CCACHE_HARDLINK enabled, the compiler doesn't embed the current
+# working directory in object files (-g absent, or -fno-working-dir
+# present), and build and host are the same, fixincl for the host will
+# build after fixincl for the build machine, getting a cache hit,
+# thereby updating the timestamp of fixincl.o in the host tree.
+# Because of CCACHE_HARDLINK, this will also update the timestamp in
+# the build tree, and so fixincl in the build tree will appear to be
+# out of date.  Yuck.
+../$(build_subdir)/fixincludes/fixincl: ; @ :
+
+# Build fixed copies of system files.
+# Abort if no system headers available, unless building a crosscompiler.
+# FIXME: abort unless building --without-headers would be more accurate and less ugly
+stmp-fixinc: gsyslimits.h macro_list \
+  $(build_objdir)/fixincludes/fixincl \
+  $(build_objdir)/fixincludes/fixinc.sh
+	@if ! $(inhibit_libc) && test ! -d ${SYSTEM_HEADER_DIR}; then \
+	  echo The directory that should contain system headers does not exist: >&2 ; \
+	  echo "  ${SYSTEM_HEADER_DIR}" >&2 ; \
+	  tooldir_sysinc=`echo "${gcc_tooldir}/sys-include" | sed -e :a -e "s,[^/]*/\.\.\/,," -e ta`; \
+	  if test "x${SYSTEM_HEADER_DIR}" = "x${tooldir_sysinc}"; \
+	  then sleep 1; else exit 1; fi; \
+	fi
+	rm -rf include; mkdir include
+	-chmod a+rx include
+	(TARGET_MACHINE='$(target)'; srcdir=`cd $(srcdir); ${PWD_COMMAND}`; \
+	  SHELL='$(SHELL)'; MACRO_LIST=`${PWD_COMMAND}`/macro_list ; \
+	  export TARGET_MACHINE srcdir SHELL MACRO_LIST && \
+	  cd $(build_objdir)/fixincludes && \
+	  $(SHELL) ./fixinc.sh ../../gcc/include \
+	    $(SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS) )
+	rm -f include/syslimits.h
+	if [ -f include/limits.h ]; then \
+	  mv include/limits.h include/syslimits.h; \
+	else \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi
+	chmod a+r include/syslimits.h
+	$(STAMP) stmp-fixinc
+
+# Files related to the fixproto script.
+# gen-protos and fix-header are compiled with CC_FOR_BUILD, but they are only
+# used in native and host-x-target builds, so it's safe to link them with
+# libiberty.a.
+
+deduced.h: $(GCC_PASSES) $(srcdir)/scan-types.sh stmp-int-hdrs
+	if [ -d "$(SYSTEM_HEADER_DIR)" ]; \
+	then \
+	  CC="$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -I. -I$(srcdir) -isystem include -isystem ${SYSTEM_HEADER_DIR}"; \
+	  export CC; \
+	  $(SHELL) $(srcdir)/scan-types.sh "$(srcdir)" >tmp-deduced.h; \
+	  mv tmp-deduced.h deduced.h; \
+	else \
+	  $(STAMP) deduced.h; \
+	fi
+
+GEN_PROTOS_OBJS = build/gen-protos.o build/scan.o $(BUILD_ERRORS)
+build/gen-protos$(build_exeext): $(GEN_PROTOS_OBJS)
+	${CC_FOR_BUILD} $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	  $(GEN_PROTOS_OBJS) $(BUILD_LIBS)
+
+build/gen-protos.o: gen-protos.c scan.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) errors.h
+
+build/scan.o: scan.c scan.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h \
+  build/gen-protos$(build_exeext) Makefile
+	sed -e s/TARGET_GETGROUPS_T/$(TARGET_GETGROUPS_T)/ \
+	  deduced.h $(srcdir)/sys-protos.h > tmp-fixtmp.c
+	mv tmp-fixtmp.c fixtmp.c
+	$(GCC_FOR_TARGET) fixtmp.c -w -U__SIZE_TYPE__ -U__PTRDIFF_TYPE__ -U__WCHAR_TYPE__ -E \
+	  | sed -e 's/	/ /g' -e 's/ *(/ (/g' -e 's/ [ ]*/ /g' -e 's/( )/()/' \
+	  | $(RUN_GEN) build/gen-protos >xsys-protos.hT
+	mv xsys-protos.hT xsys-protos.h
+	rm -rf fixtmp.c
+
+# This is nominally a 'build' program, but it's run only when host==build,
+# so we can (indeed, must) use $(LIBDEPS) and $(LIBS).
+build/fix-header$(build_exeext): build/fix-header.o build/scan-decls.o \
+  build/scan.o xsys-protos.h c-incpath.o cppdefault.o prefix.o \
+  $(BUILD_ERRORS) $(LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 build/fix-header.o c-incpath.o cppdefault.o build/scan-decls.o prefix.o \
+	 build/scan.o $(BUILD_ERRORS) $(LIBS)
+
+build/fix-header.o: fix-header.c $(OBSTACK_H) scan.h errors.h \
+	xsys-protos.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(CPPLIB_H)
+
+build/scan-decls.o: scan-decls.c scan.h $(CPPLIB_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+# stmp-fixproto depends on this, not on fix-header directly.
+# The idea is to make sure fix-header gets built,
+# but not rerun fixproto after each stage
+# just because fix-header's mtime has changed.
+fixhdr.ready: build/fix-header$(build_exeext)
+	-if [ -f fixhdr.ready ] ; then \
+		true; \
+	else \
+		$(STAMP) fixhdr.ready; \
+	fi
+
+# stmp-int-hdrs is to make sure fixincludes has already finished.
+# The if statement is so that we don't run fixproto a second time
+# if it has already been run on the files in `include'.
+stmp-fixproto: fixhdr.ready fixproto stmp-int-hdrs
+	if [ -f include/fixed ] ; then true; \
+	else \
+	  : This line works around a 'make' bug in BSDI 1.1.; \
+	  FIXPROTO_DEFINES="$(FIXPROTO_DEFINES)"; export FIXPROTO_DEFINES; \
+	  FIX_HEADER="build/fix-header$(build_exeext)"; export FIX_HEADER; \
+	  mkinstalldirs="$(mkinstalldirs)"; \
+	    export mkinstalldirs; \
+	  if [ -d "$(SYSTEM_HEADER_DIR)" ]; then \
+	    $(SHELL) ${srcdir}/fixproto include include $(SYSTEM_HEADER_DIR); \
+	    if [ $$? -eq 0 ] ; then true ; else exit 1 ; fi ; \
+	  else true; fi; \
+	  $(STAMP) include/fixed; \
+	fi
+	$(STAMP) stmp-fixproto
+
+# We can't run fixproto (it's being built for a different host), but we still
+# need to install it so that the user can run it when the compiler is
+# installed.
+stmp-install-fixproto: fixproto
+	$(STAMP) $@
+#
+# Remake the info files.
+
+doc: $(BUILD_INFO) $(GENERATED_MANPAGES) gccbug
+
+INFOFILES = doc/cpp.info doc/gcc.info doc/gccint.info \
+            doc/gccinstall.info doc/cppinternals.info
+
+info: $(INFOFILES) lang.info @GENINSRC@ srcinfo lang.srcinfo
+
+srcinfo: $(INFOFILES)
+	-cp -p $^ $(srcdir)/doc
+
+TEXI_CPP_FILES = cpp.texi fdl.texi cppenv.texi cppopts.texi		\
+	 gcc-common.texi gcc-vers.texi
+
+TEXI_GCC_FILES = gcc.texi gcc-common.texi gcc-vers.texi frontends.texi	\
+	 standards.texi invoke.texi extend.texi md.texi objc.texi	\
+	 gcov.texi trouble.texi bugreport.texi service.texi		\
+	 contribute.texi compat.texi funding.texi gnu.texi gpl.texi	\
+	 fdl.texi contrib.texi cppenv.texi cppopts.texi			\
+	 implement-c.texi
+
+TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi		\
+	 contribute.texi makefile.texi configterms.texi options.texi	\
+	 portability.texi interface.texi passes.texi c-tree.texi	\
+	 rtl.texi md.texi tm.texi hostconfig.texi fragments.texi	\
+	 configfiles.texi collect2.texi headerdirs.texi funding.texi	\
+	 gnu.texi gpl.texi fdl.texi contrib.texi languages.texi		\
+	 sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi
+
+TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi
+
+TEXI_CPPINT_FILES = cppinternals.texi gcc-common.texi gcc-vers.texi
+
+# gcc-vers.texi is generated from the version files.
+gcc-vers.texi: $(BASEVER) $(DEVPHASE)
+	(echo "@set version-GCC $(BASEVER_c)"; \
+	 if [ "$(DEVPHASE_c)" = "experimental" ]; \
+	 then echo "@set DEVELOPMENT"; \
+	 else echo "@clear DEVELOPMENT"; \
+	 fi) > $@T
+	mv -f $@T $@
+
+
+# The *.1, *.7, *.info, and *.dvi files are being generated from implicit
+# patterns.  To use them, put each of the specific targets with its
+# specific dependencies but no build commands.
+
+doc/cpp.info: $(TEXI_CPP_FILES)
+doc/gcc.info: $(TEXI_GCC_FILES)
+doc/gccint.info: $(TEXI_GCCINT_FILES)
+doc/cppinternals.info: $(TEXI_CPPINT_FILES)
+
+doc/%.info: %.texi
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I . -I $(docdir) \
+			-I $(docdir)/include -o $@ $<; \
+	fi
+
+# Duplicate entry to handle renaming of gccinstall.info
+doc/gccinstall.info: $(TEXI_GCCINSTALL_FILES)
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(docdir) \
+			-I $(docdir)/include -o $@ $<; \
+	fi
+
+doc/cpp.dvi: $(TEXI_CPP_FILES)
+doc/gcc.dvi: $(TEXI_GCC_FILES)
+doc/gccint.dvi: $(TEXI_GCCINT_FILES)
+doc/cppinternals.dvi: $(TEXI_CPPINT_FILES)
+
+$(htmldir)/cpp/index.html: $(TEXI_CPP_FILES)
+$(htmldir)/gcc/index.html: $(TEXI_GCC_FILES)
+$(htmldir)/gccint/index.html: $(TEXI_GCCINT_FILES)
+$(htmldir)/cppinternals/index.html: $(TEXI_CPPINT_FILES)
+
+dvi:: doc/gcc.dvi doc/gccint.dvi doc/gccinstall.dvi doc/cpp.dvi \
+      doc/cppinternals.dvi
+
+doc/%.dvi: %.texi
+	$(TEXI2DVI) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+# Duplicate entry to handle renaming of gccinstall.dvi
+doc/gccinstall.dvi: $(TEXI_GCCINSTALL_FILES)
+	$(TEXI2DVI) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+html:: $(htmldir)/cpp/index.html $(htmldir)/gcc/index.html \
+       $(htmldir)/gccinstall/index.html $(htmldir)/gccint/index.html \
+       $(htmldir)/cppinternals/index.html
+
+$(htmldir)/%/index.html: %.texi
+	$(mkinstalldirs) $(@D)
+	rm -f $(@D)/*
+	$(TEXI2HTML) -I $(abs_docdir) -I $(abs_docdir)/include -o $(@D) $<
+
+# Duplicate entry to handle renaming of gccinstall
+$(htmldir)/gccinstall/index.html: $(TEXI_GCCINSTALL_FILES)
+	$(mkinstalldirs) $(@D)
+	echo rm -f $(@D)/*
+	$(TEXI2HTML) -I $(abs_docdir) -I $(abs_docdir)/include -o $(@D) $<
+
+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7
+
+generated-manpages: man
+
+man: $(MANFILES) lang.man @GENINSRC@ srcman lang.srcman
+
+srcman: $(MANFILES)
+	-cp -p $^ $(srcdir)/doc
+
+doc/%.1: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=1 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+doc/%.7: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=7 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+%.pod: %.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+
+.INTERMEDIATE: cpp.pod gcc.pod gfdl.pod fsf-funding.pod
+cpp.pod: cpp.texi cppenv.texi cppopts.texi
+
+# These next rules exist because the output name is not the same as
+# the input name, so our implicit %.pod rule will not work.
+
+gcc.pod: invoke.texi cppenv.texi cppopts.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+gfdl.pod: fdl.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+fsf-funding.pod: funding.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+
+#
+# Deletion of files made during compilation.
+# There are four levels of this:
+#   `mostlyclean', `clean', `distclean' and `maintainer-clean'.
+# `mostlyclean' is useful while working on a particular type of machine.
+# It deletes most, but not all, of the files made by compilation.
+# It does not delete libgcc.a or its parts, so it won't have to be recompiled.
+# `clean' deletes everything made by running `make all'.
+# `distclean' also deletes the files made by config.
+# `maintainer-clean' also deletes everything that could be regenerated
+# automatically, except for `configure'.
+# We remove as much from the language subdirectories as we can
+# (less duplicated code).
+
+mostlyclean: lang.mostlyclean
+	-rm -f $(STAGECOPYSTUFF) $(STAGEMOVESTUFF)
+	-rm -f *$(coverageexts)
+	-rm -rf libgcc
+# Delete build programs
+	-rm -f build/*
+	-rm -f mddeps.mk
+# Delete the temp files made in the course of building libgcc.a.
+	-rm -f xlimits.h
+# Delete other built files.
+	-rm -f xsys-protos.hT
+	-rm -f specs.h gencheck.h options.c options.h
+# Delete the stamp and temporary files.
+	-rm -f s-* tmp-* stamp-* stmp-*
+	-rm -f */stamp-* */tmp-*
+# Delete debugging dump files.
+	-rm -f *.[0-9][0-9].* */*.[0-9][0-9].*
+# Delete some files made during installation.
+	-rm -f specs $(SPECS) SYSCALLS.c.X SYSCALLS.c
+	-rm -f collect collect2 mips-tfile mips-tdump
+# Delete files generated for fixproto
+	-rm -rf $(build_exeext) xsys-protos.h deduced.h tmp-deduced.h \
+	  gen-protos$(build_exeext) fixproto.list fixtmp.* fixhdr.ready
+# Delete unwanted output files from TeX.
+	-rm -f *.toc *.log *.vr *.fn *.cp *.tp *.ky *.pg
+	-rm -f */*.toc */*.log */*.vr */*.fn */*.cp */*.tp */*.ky */*.pg
+# Delete sorted indices we don't actually use.
+	-rm -f gcc.vrs gcc.kys gcc.tps gcc.pgs gcc.fns
+# Delete core dumps.
+	-rm -f core */core
+# Delete file generated for gengtype.c
+	-rm -f gtyp-gen.h
+# Delete files generated by gengtype.c
+	-rm -f gtype-*
+	-rm -f gt-*
+# Delete genchecksum outputs
+	-rm -f *-checksum.c
+
+# Delete all files made by compilation
+# that don't exist in the distribution.
+clean: mostlyclean lang.clean
+	-rm -f libgcc.a libgcc_eh.a libgcov.a
+	-rm -f libgcc_s*
+	-rm -f libunwind*
+	-rm -f config.h tconfig.h bconfig.h tm_p.h tm.h
+	-rm -f options.c options.h optionlist
+	-rm -f cs-*
+	-rm -rf libgcc
+	-rm -f doc/*.dvi
+# Delete the include directory.
+	-rm -rf include
+# Delete files used by the "multilib" facility (including libgcc subdirs).
+	-rm -f multilib.h tmpmultilib*
+	-if [ "x$(MULTILIB_DIRNAMES)" != x ] ; then \
+	  rm -rf $(MULTILIB_DIRNAMES); \
+	else if [ "x$(MULTILIB_OPTIONS)" != x ] ; then \
+	  rm -rf `echo $(MULTILIB_OPTIONS) | sed -e 's/\// /g'`; \
+	fi ; fi
+	-rm -fr stage1 stage2 stage3 stage4 stageprofile stagefeedback
+# Delete stamps of bootstrap stages
+	-rm -f stage?_*
+	-rm -f clean?_*
+	-rm -f stage_last
+
+# Delete all files that users would normally create
+# while building and installing GCC.
+distclean: clean lang.distclean
+	-rm -f auto-host.h auto-build.h
+	-rm -f cstamp-h
+	-rm -f config.status config.run config.cache config.bak
+	-rm -f Make-lang Make-hooks Make-host Make-target
+	-rm -f Makefile *.oaux
+	-rm -f gthr-default.h
+	-rm -f */stage1 */stage2 */stage3 */stage4 */include */stageprofile */stagefeedback
+	-rm -f TAGS */TAGS
+	-rm -f *.asm
+	-rm -f site.exp site.bak testsuite/site.exp testsuite/site.bak
+	-rm -f testsuite/*.log testsuite/*.sum
+	-cd testsuite && rm -f x *.x *.x? *.exe *.rpo *.o *.s *.S *.c
+	-cd testsuite && rm -f *.out *.gcov *$(coverageexts)
+	-rm -rf ${QMTEST_DIR} stamp-qmtest
+	-rm -f cxxmain.c
+	-rm -f mklibgcc gccbug .gdbinit configargs.h
+	-rm -f gcov.pod
+# Delete po/*.gmo only if we are not building in the source directory.
+	-if [ ! -f po/exgettext ]; then rm -f po/*.gmo; fi
+	-rmdir ada cp f java objc intl po testsuite 2>/dev/null
+
+# Get rid of every file that's generated from some other file, except for `configure'.
+# Most of these files ARE PRESENT in the GCC distribution.
+maintainer-clean:
+	@echo 'This command is intended for maintainers to use; it'
+	@echo 'deletes files that may need special tools to rebuild.'
+	$(MAKE) lang.maintainer-clean distclean
+	-rm -f cpp.??s cpp.*aux
+	-rm -f gcc.??s gcc.*aux
+	-rm -f $(docdir)/*.info $(docdir)/*.1 $(docdir)/*.7 $(docdir)/*.dvi
+#
+# Entry points `install' and `uninstall'.
+# Also use `install-collect2' to install collect2 when the config files don't.
+
+# Copy the compiler files into directories where they will be run.
+# Install the driver last so that the window when things are
+# broken is small.
+install: install-common $(INSTALL_HEADERS) $(INSTALL_LIBGCC) \
+    install-cpp install-man install-info install-@POSUB@ \
+    lang.install-normal install-driver
+
+# Handle cpp installation.
+install-cpp: installdirs cpp$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+
+# Create the installation directories.
+# $(libdir)/gcc/include isn't currently searched by cpp.
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libsubdir)
+	$(mkinstalldirs) $(DESTDIR)$(libexecsubdir)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	$(mkinstalldirs) $(DESTDIR)$(includedir)
+	$(mkinstalldirs) $(DESTDIR)$(infodir)
+	$(mkinstalldirs) $(DESTDIR)$(slibdir)
+	$(mkinstalldirs) $(DESTDIR)$(man1dir)
+	$(mkinstalldirs) $(DESTDIR)$(man7dir)
+
+# Install the compiler executables built during cross compilation.
+install-common: native $(EXTRA_PARTS) lang.install-common installdirs
+	for file in $(COMPILERS); do \
+	  if [ -f $$file ] ; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; \
+	  fi; \
+	done
+	for file in $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2) ..; do \
+	  if [ x"$$file" != x.. ]; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; fi; \
+	done
+	for file in $(EXTRA_PARTS) ..; do \
+	  if [ x"$$file" != x.. ]; then \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_DATA) $$file $(DESTDIR)$(libsubdir)/$$file; \
+	    chmod a-x $(DESTDIR)$(libsubdir)/$$file; \
+	  else true; fi; \
+	done
+# We no longer install the specs file because its presence makes the
+# driver slower, and because people who need it can recreate it by
+# using -dumpspecs.  We remove any old version because it would
+# otherwise override the specs built into the driver.
+	rm -f $(DESTDIR)$(libsubdir)/specs
+# Install protoize if it was compiled.
+	-if [ -f protoize$(exeext) ]; then \
+	  rm -f $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) protoize$(exeext) $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) unprotoize$(exeext) $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  $(INSTALL_DATA) SYSCALLS.c.X $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	fi
+# Install gcov if it was compiled.
+	-if [ -f gcov$(exeext) ]; \
+	then \
+	    rm -f $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) gcov$(exeext) $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	fi
+	$(INSTALL_SCRIPT) gccbug $(DESTDIR)$(bindir)/$(GCCBUG_INSTALL_NAME)
+
+# Install the driver program as $(target_noncanonical)-gcc,
+# $(target_noncanonical)-gcc-$(version)
+# and also as either gcc (if native) or $(gcc_tooldir)/bin/gcc.
+install-driver: installdirs xgcc$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext)
+	-( cd $(DESTDIR)$(bindir) && \
+	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) )
+	-if [ -f gcc-cross$(exeext) ] ; then \
+	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	    $(INSTALL_PROGRAM) gcc-cross$(exeext) $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	  else true; fi; \
+	else \
+	  rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-tmp$(exeext); \
+	  ( cd $(DESTDIR)$(bindir) && \
+	    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-tmp$(exeext) && \
+	    mv -f $(target_noncanonical)-gcc-tmp$(exeext) $(GCC_TARGET_INSTALL_NAME)$(exeext) ); \
+	fi
+
+# Install the info files.
+# $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir
+# to do the install.
+install-info:: doc installdirs \
+	$(DESTDIR)$(infodir)/cpp.info \
+	$(DESTDIR)$(infodir)/gcc.info \
+	$(DESTDIR)$(infodir)/cppinternals.info \
+	$(DESTDIR)$(infodir)/gccinstall.info \
+	$(DESTDIR)$(infodir)/gccint.info
+
+$(DESTDIR)$(infodir)/%.info: doc/%.info installdirs
+	rm -f $@
+	if [ -f $< ]; then \
+	  for f in $(<)*; do \
+	    realfile=`echo $$f | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$realfile; \
+	    chmod a-x $(DESTDIR)$(infodir)/$$realfile; \
+	  done; \
+	else true; fi
+	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+	  if [ -f $@ ]; then \
+	    install-info --dir-file=$(DESTDIR)$(infodir)/dir $@; \
+	  else true; fi; \
+	else true; fi;
+
+# Install the man pages.
+install-man: lang.install-man \
+	$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man7dir)/fsf-funding$(man7ext) \
+	$(DESTDIR)$(man7dir)/gfdl$(man7ext) \
+	$(DESTDIR)$(man7dir)/gpl$(man7ext)
+
+$(DESTDIR)$(man7dir)/%$(man7ext): doc/%.7 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext): doc/gcc.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext): doc/cpp.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext): doc/gcov.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+# Install the library.
+install-libgcc: libgcc.mk libgcc.a libgcov.a installdirs
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(TCONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  mkinstalldirs='$(mkinstalldirs)' \
+	  -f libgcc.mk install
+
+# Install multiple versions of libgcc.a, libgcov.a.
+install-multilib: stmp-multilib installdirs
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(CONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  mkinstalldirs='$(mkinstalldirs)' \
+	  -f libgcc.mk install
+
+# Install all the header files built in the include subdirectory.
+install-headers: $(INSTALL_HEADERS_DIR)
+# Fix symlinks to absolute paths in the installed include directory to
+# point to the installed directory, not the build directory.
+# Don't need to use LN_S here since we really do need ln -s and no substitutes.
+	-files=`cd $(DESTDIR)$(libsubdir)/include; find . -type l -print 2>/dev/null`; \
+	if [ $$? -eq 0 ]; then \
+	  dir=`cd include; ${PWD_COMMAND}`; \
+	  for i in $$files; do \
+	    dest=`ls -ld $(DESTDIR)$(libsubdir)/include/$$i | sed -n 's/.*-> //p'`; \
+	    if expr "$$dest" : "$$dir.*" > /dev/null; then \
+	      rm -f $(DESTDIR)$(libsubdir)/include/$$i; \
+	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(DESTDIR)$(libsubdir)/include/$$i; \
+	    fi; \
+	  done; \
+	fi
+
+# Create or recreate the gcc private include file directory.
+install-include-dir: installdirs
+	-rm -rf $(DESTDIR)$(libsubdir)/include
+	mkdir $(DESTDIR)$(libsubdir)/include
+	-chmod a+rx $(DESTDIR)$(libsubdir)/include
+
+# Create or recreate the install-tools include file directory.
+itoolsdir = $(libexecsubdir)/install-tools
+itoolsdatadir = $(libsubdir)/install-tools
+install-itoolsdirs: installdirs
+	$(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include
+	$(mkinstalldirs) $(DESTDIR)$(itoolsdir)
+
+# Install the include directory using tar.
+install-headers-tar: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+# We use `pwd`/include instead of just include to problems with CDPATH
+# Unless a full pathname is provided, some shells would print the new CWD,
+# found in CDPATH, corrupting the output.  We could just redirect the
+# output of `cd', but some shells lose on redirection within `()'s
+	(cd `${PWD_COMMAND}`/include ; \
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include; tar xpf - )
+# /bin/sh on some systems returns the status of the first tar,
+# and that can lose with GNU tar which always writes a full block.
+# So use `exit 0' to ignore its exit status.
+
+# Install the include directory using cpio.
+install-headers-cpio: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+# See discussion about the use of `pwd` above
+	cd `${PWD_COMMAND}`/include ; \
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include
+
+# Install the include directory using cp.
+install-headers-cp: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+	cp -p -r include $(DESTDIR)$(libsubdir)
+
+# Install supporting files for fixincludes to be run later.
+install-mkheaders: stmp-int-hdrs $(STMP_FIXPROTO) install-itoolsdirs \
+  macro_list xlimits.h
+	for file in $(USER_H); do \
+	  realfile=`echo $$file | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	  $(INSTALL_DATA) $$file \
+	    $(DESTDIR)$(itoolsdatadir)/include/$$realfile ; \
+	done
+	$(INSTALL_DATA) xlimits.h $(DESTDIR)$(itoolsdatadir)/include/limits.h
+	$(INSTALL_DATA) $(UNWIND_H) $(DESTDIR)$(itoolsdatadir)/include/unwind.h
+	$(INSTALL_DATA) $(srcdir)/gsyslimits.h \
+	  $(DESTDIR)$(itoolsdatadir)/gsyslimits.h
+	$(INSTALL_DATA) macro_list $(DESTDIR)$(itoolsdatadir)/macro_list
+	if [ x$(STMP_FIXPROTO) != x ] ; then \
+	  $(INSTALL_SCRIPT) $(mkinstalldirs) \
+		$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \
+	  $(INSTALL_SCRIPT) $(srcdir)/fixproto $(DESTDIR)$(itoolsdir)/fixproto ; \
+	  $(INSTALL_PROGRAM) build/fix-header$(build_exeext) \
+		$(DESTDIR)$(itoolsdir)/fix-header$(build_exeext) ; \
+	else :; fi
+	echo 'SYSTEM_HEADER_DIR="'"$(SYSTEM_HEADER_DIR)"'"' \
+		> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'OTHER_FIXINCLUDES_DIRS="$(OTHER_FIXINCLUDES_DIRS)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'FIXPROTO_DEFINES="$(FIXPROTO_DEFINES)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'STMP_FIXPROTO="$(STMP_FIXPROTO)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'STMP_FIXINC="$(STMP_FIXINC)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+
+# Use this target to install the program `collect2' under the name `collect2'.
+install-collect2: collect2 installdirs
+	$(INSTALL_PROGRAM) collect2$(exeext) $(DESTDIR)$(libexecsubdir)/collect2$(exeext)
+# Install the driver program as $(libsubdir)/gcc for collect2.
+	$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(libexecsubdir)/gcc$(exeext)
+
+# Cancel installation by deleting the installed files.
+uninstall: lang.uninstall
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(libexecsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+	-rm -rf $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/cpp$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/protoize$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/unprotoize$(man1ext)
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
+	-rm -f $(DESTDIR)$(infodir)/cppinternals.info* $(DESTDIR)$(infodir)/gccint.info*
+#
+# These targets are for the dejagnu testsuites. The file site.exp
+# contains global variables that all the testsuites will use.
+
+target_subdir = @target_subdir@
+
+site.exp: ./config.status Makefile
+	@echo "Making a new config file..."
+	-@rm -f ./tmp?
+	@$(STAMP) site.exp
+	-@mv site.exp site.bak
+	@echo "## these variables are automatically generated by make ##" > ./tmp0
+	@echo "# Do not edit here. If you wish to override these values" >> ./tmp0
+	@echo "# add them to the last section" >> ./tmp0
+	@echo "set rootme \"`${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set srcdir \"`cd ${srcdir}; ${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set host_triplet $(host)" >> ./tmp0
+	@echo "set build_triplet $(build)" >> ./tmp0
+	@echo "set target_triplet $(target)" >> ./tmp0
+	@echo "set target_alias $(target_noncanonical)" >> ./tmp0
+	@echo "set libiconv \"$(LIBICONV)\"" >> ./tmp0
+# CFLAGS is set even though it's empty to show we reserve the right to set it.
+	@echo "set CFLAGS \"\"" >> ./tmp0
+	@echo "set CXXFLAGS \"\"" >> ./tmp0
+	@echo "set HOSTCC \"$(CC)\"" >> ./tmp0
+	@echo "set HOSTCFLAGS \"$(CFLAGS)\"" >> ./tmp0
+	@echo "set TESTING_IN_BUILD_TREE 1" >> ./tmp0
+	@echo "set HAVE_LIBSTDCXX_V3 1" >> ./tmp0
+# If newlib has been configured, we need to pass -B to gcc so it can find
+# newlib's crt0.o if it exists.  This will cause a "path prefix not used"
+# message if it doesn't, but the testsuite is supposed to ignore the message -
+# it's too difficult to tell when to and when not to pass -B (not all targets
+# have crt0's).  We could only add the -B if ../newlib/crt0.o exists, but that
+# seems like too selective a test.
+# ??? Another way to solve this might be to rely on linker scripts.  Then
+# theoretically the -B won't be needed.
+# We also need to pass -L ../ld so that the linker can find ldscripts.
+	@if [ -d $(objdir)/../$(target_subdir)/newlib ] \
+	    && [ "${host}" != "${target}" ]; then \
+	  echo "set newlib_cflags \"-I$(objdir)/../$(target_subdir)/newlib/targ-include -I\$$srcdir/../newlib/libc/include\"" >> ./tmp0; \
+	  echo "set newlib_ldflags \"-B$(objdir)/../$(target_subdir)/newlib/\"" >> ./tmp0; \
+	  echo "append CFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append CXXFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append LDFLAGS \" \$$newlib_ldflags\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ -d $(objdir)/../ld ] ; then \
+	  echo "append LDFLAGS \" -L$(objdir)/../ld\"" >> ./tmp0; \
+	else true; \
+	fi
+	echo "set tmpdir $(objdir)/testsuite" >> ./tmp0
+	@echo "set srcdir \"\$${srcdir}/testsuite\"" >> ./tmp0
+	@if [ "X$(ALT_CC_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CC_UNDER_TEST \"$(ALT_CC_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(ALT_CXX_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CXX_UNDER_TEST \"$(ALT_CXX_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(COMPAT_OPTIONS)" != "X" ] ; then \
+	  echo "set COMPAT_OPTIONS \"$(COMPAT_OPTIONS)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@echo "## All variables above are generated by configure. Do Not Edit ##" >> ./tmp0
+	@cat ./tmp0 > site.exp
+	@cat site.bak | sed \
+		-e '1,/^## All variables above are.*##/ d' >> site.exp
+	-@rm -f ./tmp?
+
+CHECK_TARGETS = check-gcc @check_languages@
+
+check: $(CHECK_TARGETS)
+
+# The idea is to parallelize testing of multilibs, for example:
+#   make -j3 check-gcc//sh-hms-sim/{-m1,-m2,-m3,-m3e,-m4}/{,-nofpu}
+# will run 3 concurrent sessions of check-gcc, eventually testing
+# all 10 combinations.  GNU make is required, as is a shell that expands
+# alternations within braces.
+lang_checks_parallel = $(lang_checks:=//%)
+$(lang_checks_parallel): site.exp
+	target=`echo "$@" | sed 's,//.*,,'`; \
+	variant=`echo "$@" | sed 's,^[^/]*//,,'`; \
+	vardots=`echo "$$variant" | sed 's,/,.,g'`; \
+	$(MAKE) TESTSUITEDIR="testsuite.$$vardots" \
+	  RUNTESTFLAGS="--target_board=$$variant $(RUNTESTFLAGS)" \
+	  "$$target"
+
+TESTSUITEDIR = testsuite
+
+$(TESTSUITEDIR)/site.exp: site.exp
+	test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	-rm -f $@
+	sed '/set tmpdir/ s|testsuite|$(TESTSUITEDIR)|' < site.exp > $@
+
+$(lang_checks): check-% : site.exp
+	-test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	test -d $(TESTSUITEDIR)/$* || mkdir $(TESTSUITEDIR)/$*
+	-(rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd $(TESTSUITEDIR)/$*; \
+	rm -f tmp-site.exp; \
+	sed '/set tmpdir/ s|testsuite|$(TESTSUITEDIR)/$*|' \
+		< ../../site.exp > tmp-site.exp; \
+	$(SHELL) $${srcdir}/../move-if-change tmp-site.exp site.exp; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd $${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	    export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool $* $(RUNTESTFLAGS))
+
+check-consistency: testsuite/site.exp
+	-rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd testsuite; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd ${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	   export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool consistency $(RUNTESTFLAGS)
+
+# QMTest targets
+
+# The path to qmtest.
+QMTEST_PATH=qmtest
+
+# The flags to pass to qmtest.
+QMTESTFLAGS=
+
+# The flags to pass to "qmtest run".
+QMTESTRUNFLAGS=-f none --result-stream dejagnu_stream.DejaGNUStream
+
+# The command to use to invoke qmtest.
+QMTEST=${QMTEST_PATH} ${QMTESTFLAGS}
+
+# The tests (or suites) to run.
+QMTEST_GPP_TESTS=g++
+
+# The subdirectory of the OBJDIR that will be used to store the QMTest
+# test database configuration and that will be used for temporary
+# scratch space during QMTest's execution.
+QMTEST_DIR=qmtestsuite
+
+# Create the QMTest database configuration.
+${QMTEST_DIR} stamp-qmtest:
+	${QMTEST} -D ${QMTEST_DIR} create-tdb \
+	    -c gcc_database.GCCDatabase \
+            -a srcdir=`cd ${srcdir}/testsuite && ${PWD_COMMAND}` && \
+	    $(STAMP) stamp-qmtest
+
+# Create the QMTest context file.
+${QMTEST_DIR}/context: stamp-qmtest
+	rm -f $@
+	echo "CompilerTable.languages=c cplusplus" >> $@
+	echo "CompilerTable.c_kind=GCC" >> $@
+	echo "CompilerTable.c_path=${objdir}/xgcc" >> $@
+	echo "CompilerTable.c_options=-B${objdir}/" >> $@
+	echo "CompilerTable.cplusplus_kind=GCC" >> $@
+	echo "CompilerTable.cplusplus_path=${objdir}/g++" >> $@
+	echo "CompilerTable.cplusplus_options=-B${objdir}/" >> $@
+	echo "DejaGNUTest.target=${target_noncanonical}" >> $@
+
+# Run the G++ testsuite using QMTest.
+qmtest-g++: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} run ${QMTESTRUNFLAGS} -C context \
+	   -o g++.qmr ${QMTEST_GPP_TESTS}
+
+# Use the QMTest GUI.
+qmtest-gui: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} gui -C context
+
+.PHONY: qmtest-g++
+
+# Run Paranoia on real.c.
+
+paranoia.o: $(srcdir)/../contrib/paranoia.cc $(CONFIG_H) $(SYSTEM_H) \
+  real.h $(TREE_H)
+	g++ -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
+
+paranoia: paranoia.o real.o $(LIBIBERTY)
+	g++ -o $@ paranoia.o real.o $(LIBIBERTY)
+
+# These exist for maintenance purposes.
+
+# Update the tags table.
+TAGS: lang.tags
+	(cd $(srcdir);					\
+	incs= ;						\
+	list='$(SUBDIRS)'; for dir in $$list; do	\
+	  if test -f $$dir/TAGS; then			\
+	    incs="$$incs --include $$dir/TAGS.sub";	\
+	  fi;						\
+	done;						\
+	etags -o TAGS.sub *.y *.h *.c; \
+	etags --include TAGS.sub $$incs)
+
+# ------------------------------------------------------
+# Bootstrap-related targets (not used during 'make all')
+# ------------------------------------------------------
+
+# A list of files to be destroyed during "lean" builds.
+VOL_FILES=`echo $(BACKEND) $(OBJS) $(C_OBJS) *.c *.h gen*`
+
+# Flags to pass to stage2 and later recursive makes.  Note that the
+# WARN_CFLAGS setting can't be to the expansion of GCC_WARN_CFLAGS in
+# the context of the stage_x rule.
+
+POSTSTAGE1_FLAGS_TO_PASS = \
+	ADAFLAGS="$(BOOT_ADAFLAGS)" \
+	CFLAGS="$(BOOT_CFLAGS)" \
+	LDFLAGS="$(BOOT_LDFLAGS)" \
+	WARN_CFLAGS="\$$(GCC_WARN_CFLAGS)" \
+	STRICT_WARN="$(STRICT2_WARN)" \
+	libdir=$(libdir) \
+	LANGUAGES="$(LANGUAGES)" \
+	MAKEINFO="$(MAKEINFO)" \
+	MAKEINFOFLAGS="$(MAKEINFOFLAGS)" \
+	MAKEOVERRIDES= \
+	OUTPUT_OPTION="-o \$$@"
+
+STAGE2_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS)" \
+	WERROR="$(WERROR_FLAGS)" \
+
+STAGEPROFILE_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS) -fprofile-generate"
+
+# Files never linked into the final executable produces warnings about missing
+# profile.
+STAGEFEEDBACK_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS) -fprofile-use -freorder-blocks-and-partition"
+
+# Only build the C compiler for stage1, because that is the only one that
+# we can guarantee will build with the native compiler, and also it is the
+# only thing useful for building stage2. STAGE1_CFLAGS (via CFLAGS),
+# MAKEINFO and MAKEINFOFLAGS are explicitly passed here to make them
+# overrideable (for a bootstrap build stage1 also builds gcc.info).
+# The stage1 compiler is always built with checking enabled.
+stage1_build:
+	$(MAKE) CC="$(CC)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)" \
+		CFLAGS="$(STAGE1_CFLAGS) $(STAGE1_CHECKING)" \
+		MAKEINFO="$(MAKEINFO)" MAKEINFOFLAGS="$(MAKEINFOFLAGS)" \
+		COVERAGE_FLAGS= OBJS-onestep="$(OBJS)"
+	$(STAMP) stage1_build
+	echo stage1_build > stage_last
+
+stage1_copy: stage1_build
+	$(MAKE) stage1
+	$(STAMP) stage1_copy
+	echo stage2_build > stage_last
+
+stage2_build: stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage2_build
+	echo stage2_build > stage_last
+
+stage2_copy: stage2_build
+	$(MAKE) stage2
+	$(STAMP) stage2_copy
+	echo stage3_build > stage_last
+
+stageprofile_build: stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGEPROFILE_FLAGS_TO_PASS)
+	$(STAMP) stageprofile_build
+	echo stageprofile_build > stage_last
+
+stageprofile_copy: stageprofile_build
+	$(MAKE) stageprofile
+	$(STAMP) stageprofile_copy
+	echo stagefeedback_build > stage_last
+
+stage3_build: stage2_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage2/xgcc$(exeext) -Bstage2/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage2/xgcc$(exeext) -Bstage2/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage2/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage3_build
+	echo stage3_build > stage_last
+
+stagefeedback_build: stageprofile_copy stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGEFEEDBACK_FLAGS_TO_PASS)
+	$(STAMP) stagefeedback_build
+	echo stagefeedback_build > stage_last
+
+stagefeedback_copy: stagefeedback_build
+	$(MAKE) stagefeedback
+	$(STAMP) stagefeedback_copy
+	echo stagefeedback2_build > stage_last
+
+# For bootstrap4:
+stage3_copy: stage3_build
+	$(MAKE) stage3
+	$(STAMP) stage3_copy
+	echo stage4_build > stage_last
+
+stage4_build: stage3_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage3/xgcc$(exeext) -Bstage3/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage3/xgcc$(exeext) -Bstage3/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage3/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage4_build
+	echo stage4_build > stage_last
+
+# Additional steps for *-lean targets:
+clean_s1: stage1_copy
+	-(cd stage1 && rm -f $(VOL_FILES))
+	$(STAMP) clean_s1
+
+clean_s2: stage2_copy
+	-rm -rf stage1
+	$(STAMP) clean_s2
+
+# The various entry points for bootstrapping.
+
+bootstrap: stage3_build
+	@echo
+	@echo Bootstrap complete - make \"quickstrap\" to redo last build,
+	@echo \"restage1\" through \"restage3\" to rebuild specific stages,
+	@echo \"restrap\" to redo the bootstrap from stage1, or
+	@echo \"cleanstrap\" to redo the bootstrap from scratch.
+
+bootstrap-lean : clean_s1 clean_s2 stage3_build
+	@echo
+	@echo Bootstrap complete - make \"quickstrap\" to redo last build,
+	@echo or \"cleanstrap\" to redo the bootstrap from scratch.
+
+bootstrap2: bootstrap
+
+bootstrap2-lean : bootstrap-lean
+
+bootstrap3 bootstrap3-lean: bootstrap
+
+bootstrap4 bootstrap4-lean: stage4_build
+
+unstage1 unstage2 unstage3 unstage4 unstageprofile unstagefeedback:
+	-set -vx; stage=`echo $@ | sed -e 's/un//'`; \
+	rm -f $$stage/as$(exeext); \
+	rm -f $$stage/nm$(exeext); \
+	rm -f $$stage/collect-ld$(exeext); \
+	if test -d $$stage; then \
+	  mv $$stage/specs $(SPECS) 2>/dev/null || :; \
+	  mv $$stage/* . 2>/dev/null; \
+	  for i in `cd $$stage; echo *` ; do \
+	    if test -d $$stage/$$i; then \
+	      mv $$stage/$$i/* $$i/. 2>/dev/null; \
+	    else \
+	      mv $$stage/$$i .; \
+	    fi; \
+	  done \
+	fi ; \
+	rm -f $${stage}_build $${stage}_copy ;\
+	echo $${stage}_build > stage_last
+
+restage1: unstage1
+	$(MAKE) $(REMAKEFLAGS) stage1_build
+
+restage2: unstage2
+	$(MAKE) $(REMAKEFLAGS) stage2_build
+
+restage3: unstage3
+	$(MAKE) $(REMAKEFLAGS) stage3_build
+
+restage4: unstage4
+	$(MAKE) $(REMAKEFLAGS) stage4_build
+
+restageprofile: unstageprofile
+	$(MAKE) $(REMAKEFLAGS) stageprofile_build
+
+restagefeedback: unstagefeedback
+	$(MAKE) $(REMAKEFLAGS) stagefeedback_build
+
+# Bubble up a bugfix through all the stages.  Primarily useful for fixing
+# bugs that cause the compiler to crash while building stage 2.
+bubblestrap:
+	if test -f stage_last; then \
+	  LAST=`sed -e 's/_build//' < stage_last`; \
+	  if test "$$LAST" != "stage1"; then \
+	    $(MAKE) $(REMAKEFLAGS) $$LAST; \
+	    $(STAMP) $${LAST}_copy; \
+	  fi; \
+	fi
+	if test -f stage1_copy; then $(MAKE) unstage1; fi
+	$(MAKE) $(REMAKEFLAGS) stage1_copy
+	if test -f stage2_copy; then $(MAKE) unstage2; fi
+	$(MAKE) $(REMAKEFLAGS) stage2_copy
+	if test -f stage3_copy; then $(MAKE) unstage3; fi
+	$(MAKE) $(REMAKEFLAGS) stage3_build
+	if test -f stage4_copy; then \
+	  $(MAKE) $(REMAKEFLAGS) stage3_copy; $(MAKE) unstage4; \
+	  $(MAKE) $(REMAKEFLAGS) stage4_build || exit 1; \
+	fi
+
+quickstrap:
+	if test -f stage_last ; then \
+	  LAST=`cat stage_last`; rm $$LAST; $(MAKE) $(REMAKEFLAGS) $$LAST; \
+	else \
+	  $(MAKE) $(REMAKEFLAGS) stage1_build; \
+	fi
+
+cleanstrap:
+	-$(MAKE) clean
+	$(MAKE) $(REMAKEFLAGS) bootstrap
+
+unstrap:
+	-rm -rf stage[234]*
+	$(MAKE) unstage1
+	-rm -f stage_last
+
+# Differs from cleanstrap in that it starts from the earlier stage1 build,
+# not from scratch.
+restrap:
+	$(MAKE) unstrap
+	$(MAKE) $(REMAKEFLAGS) bootstrap
+
+# These targets compare the object files in the current directory with
+# those in a stage directory.  We need to skip the first N bytes of
+# each object file.  The "slow" mechanism assumes nothing special
+# about cmp and uses the tail command to skip.  ./ avoids a bug in
+# some versions of tail.  The "gnu" targets use gnu cmp (diffutils
+# v2.4 or later), to avoid running tail and the overhead of twice
+# copying each object file.  Likewise, the "fast" targets use the skip
+# parameter of cmp available on some systems to accomplish the same
+# thing.  An exit status of 1 is precisely the result we're looking
+# for (other values mean other problems).
+slowcompare slowcompare3 slowcompare4 slowcompare-lean slowcompare3-lean slowcompare4-lean \
+fastcompare fastcompare3 fastcompare4 fastcompare-lean fastcompare3-lean fastcompare4-lean \
+ gnucompare  gnucompare3  gnucompare4  gnucompare-lean  gnucompare3-lean  gnucompare4-lean: force
+	-rm -f .bad_compare
+	case "$@" in *compare | *compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^[a-z]*compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
+	for dir in . $(SUBDIRS) libgcc; do \
+	  if [ "`echo $$dir/*$(objext)`" != "$$dir/*$(objext)" ] ; then \
+	    for file in $$dir/*$(objext); do \
+	      case "$@" in \
+		slowcompare* ) \
+		  tail +16c ./$$file > tmp-foo1; \
+		  tail +16c stage$$stage/$$file > tmp-foo2; \
+		  cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1; \
+		  cmpret=$$?; \
+		  ;; \
+		fastcompare* ) \
+		  cmp $$file stage$$stage/$$file 16 16 > /dev/null 2>&1; \
+		  cmpret=$$?; \
+		  ;; \
+		gnucompare* ) \
+		  cmp --ignore-initial=16 $$file stage$$stage/$$file > /dev/null 2>&1; \
+		  cmpret=$$?; \
+		  ;; \
+	      esac ; \
+	      if test $$cmpret -eq 1; then \
+		case $$file in \
+		  ./cc*-checksum$(objext) | libgcc/* ) \
+		    echo warning: $$file differs;; \
+		  *) \
+		    echo $$file differs >> .bad_compare;; \
+		esac ; \
+	      fi; \
+	    done; \
+	  else true; fi; \
+	done
+	-rm -f tmp-foo*
+	case "$@" in *compare | *compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^[a-z]*compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
+	if [ -f .bad_compare ]; then \
+	  echo "Bootstrap comparison failure!"; \
+	  cat .bad_compare; \
+	  exit 1; \
+	else \
+	  case "$@" in \
+	    *-lean ) rm -rf stage$$stage ;; \
+	    *) ;; \
+	  esac; true; \
+	fi
+
+# Forwarding wrappers to the most appropriate version.
+compare: @make_compare_target@
+compare3: @make_compare_target@3
+compare4: @make_compare_target@4
+compare-lean: @make_compare_target@-lean
+compare3-lean: @make_compare_target@3-lean
+compare4-lean: @make_compare_target@4-lean
+
+# Copy the object files from a particular stage into a subdirectory.
+stage1-start:
+	-if [ -d stage1 ] ; then true ; else mkdir stage1 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage1
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage1/$$dir ] ; then true ; else mkdir stage1/$$dir ; fi ; \
+	 done
+	-rm -f stage1/libgcc.a stage1/libgcc_eh.a stage1/libgcov.a
+	-rm -f stage1/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage1/libunwind.a stage1/libunwind*$(SHLIB_EXT)
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage1/specs
+	-mv $(STAGEMOVESTUFF) stage1
+	-mv build/* stage1/build
+	-cp -p $(STAGECOPYSTUFF) stage1
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage1 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-cp libgcc.a stage1
+	-$(RANLIB_FOR_TARGET) stage1/libgcc.a
+	-cp libgcov.a stage1
+	-$(RANLIB_FOR_TARGET) stage1/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage1; \
+	   $(RANLIB_FOR_TARGET) stage1/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage1
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage1
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage1/$${f} . ; \
+	else true; \
+	fi; done
+stage1: force stage1-start lang.stage1
+	-for dir in . $(SUBDIRS) ; \
+	do \
+	  rm -f $$dir/*$(coverageexts) ; \
+	done
+
+stage2-start:
+	-if [ -d stage2 ] ; then true ; else mkdir stage2 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage2
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage2/$$dir ] ; then true ; else mkdir stage2/$$dir ; fi ; \
+	 done
+	-rm -f stage2/libgcc.a stage2/libgcov.a stage2/libgcc_eh.a
+	-rm -f stage2/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage2/libunwind.a stage2/libunwind*$(SHLIB_EXT)
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage2/specs
+	-mv $(STAGEMOVESTUFF) stage2
+	-mv build/* stage2/build
+	-cp -p $(STAGECOPYSTUFF) stage2
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage2 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-cp libgcc.a stage2
+	-$(RANLIB_FOR_TARGET) stage2/libgcc.a
+	-cp libgcov.a stage2
+	-$(RANLIB_FOR_TARGET) stage2/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage2; \
+	   $(RANLIB_FOR_TARGET) stage2/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage2
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage2
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage2/$${f} . ; \
+	else true; \
+	fi; done
+stage2: force stage2-start lang.stage2
+
+stage3-start:
+	-if [ -d stage3 ] ; then true ; else mkdir stage3 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage3
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage3/$$dir ] ; then true ; else mkdir stage3/$$dir ; fi ; \
+	 done
+	-rm -f stage3/libgcc.a stage3/libgcov.a stage3/libgcc_eh.a
+	-rm -f stage3/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage3/libunwind.a stage3/libunwind*$(SHLIB_EXT)
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage3/specs
+	-mv $(STAGEMOVESTUFF) stage3
+	-mv build/* stage3/build
+	-cp -p $(STAGECOPYSTUFF) stage3
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage3 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-cp libgcc.a stage3
+	-$(RANLIB_FOR_TARGET) stage3/libgcc.a
+	-cp libgcov.a stage3
+	-$(RANLIB_FOR_TARGET) stage3/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage3; \
+	   $(RANLIB_FOR_TARGET) stage3/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage3
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage3
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage3/$${f} . ; \
+	else true; \
+	fi; done
+stage3: force stage3-start lang.stage3
+
+stage4-start:
+	-if [ -d stage4 ] ; then true ; else mkdir stage4 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage4
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage4/$$dir ] ; then true ; else mkdir stage4/$$dir ; fi ; \
+	 done
+	-rm -f stage4/libgcc.a stage4/libgcov.a stage4/libgcc_eh.a
+	-rm -f stage4/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage4/libunwind.a stage4/libunwind*$(SHLIB_EXT)
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage4/specs
+	-mv $(STAGEMOVESTUFF) stage4
+	-mv build/* stage4/build
+	-cp -p $(STAGECOPYSTUFF) stage4
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage4 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-cp libgcc.a stage4
+	-$(RANLIB_FOR_TARGET) stage4/libgcc.a
+	-cp libgcov.a stage4
+	-$(RANLIB_FOR_TARGET) stage4/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage4; \
+	   $(RANLIB_FOR_TARGET) stage4/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage4
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage4
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage4/$${f} . ; \
+	else true; \
+	fi; done
+stage4: force stage4-start lang.stage4
+
+stageprofile-start:
+	-if [ -d stageprofile ] ; then true ; else mkdir stageprofile ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stageprofile
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stageprofile/$$dir ] ; then true ; else mkdir stageprofile/$$dir ; fi ; \
+	 done
+	-rm -f stageprofile/libgcc.a stageprofile/libgcov.a stageprofile/libgcc_eh.a
+	-rm -f stageprofile/libgcc_s*$(SHLIB_EXT)
+	-rm -f stageprofile/libunwind.a stageprofile/libunwind*$(SHLIB_EXT)
+	-mv $(STAGEMOVESTUFF) stageprofile
+	-mv build/* stageprofile/build
+	-cp -p $(STAGECOPYSTUFF) stageprofile
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stageprofile && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stageprofile && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stageprofile && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-cp libgcc.a stageprofile
+	-$(RANLIB_FOR_TARGET) stageprofile/libgcc.a
+	-cp libgcov.a stageprofile
+	-$(RANLIB_FOR_TARGET) stageprofile/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stageprofile; \
+	   $(RANLIB_FOR_TARGET) stageprofile/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stageprofile
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stageprofile
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stageprofile/$${f} . ; \
+	else true; \
+	fi; done
+stageprofile: force stageprofile-start lang.stageprofile
+
+stagefeedback-start:
+	-if [ -d stagefeedback ] ; then true ; else mkdir stagefeedback ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stagefeedback
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stagefeedback/$$dir ] ; then true ; else mkdir stagefeedback/$$dir ; fi ; \
+	 done
+	-rm -f stagefeedback/libgcc.a stagefeedback/libgcov.a stagefeedback/libgcc_eh.a
+	-rm -f stagefeedback/libgcc_s*$(SHLIB_EXT)
+	-rm -f stagefeedback/libunwind.a stagefeedback/libunwind*$(SHLIB_EXT)
+	-rm -f *.da
+	-mv $(STAGEMOVESTUFF) stagefeedback
+	-mv build/* stagefeedback/build
+	-cp -p $(STAGECOPYSTUFF) stagefeedback
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-for dir in fixinc po testsuite $(SUBDIRS); \
+	 do \
+	   rm -f $$dir/*.da ; \
+	 done
+	-cp libgcc.a stagefeedback
+	-$(RANLIB_FOR_TARGET) stagefeedback/libgcc.a
+	-cp libgcov.a stagefeedback
+	-$(RANLIB_FOR_TARGET) stagefeedback/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stagefeedback; \
+	   $(RANLIB_FOR_TARGET) stagefeedback/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stagefeedback
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stagefeedback
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stagefeedback/$${f} . ; \
+	else true; \
+	fi; done
+stagefeedback: force stagefeedback-start lang.stagefeedback
+
+# Copy just the executable files from a particular stage into a subdirectory,
+# and delete the object files.  Use this if you're just verifying a version
+# that is pretty sure to work, and you are short of disk space.
+risky-stage1: stage1
+	-$(MAKE) clean
+
+risky-stage2: stage2
+	-$(MAKE) clean
+
+risky-stage3: stage3
+	-$(MAKE) clean
+
+risky-stage4: stage4
+	-$(MAKE) clean
+
+#In GNU Make, ignore whether `stage*' exists.
+.PHONY: stage1 stage2 stage3 stage4 clean maintainer-clean TAGS bootstrap
+.PHONY: risky-stage1 risky-stage2 risky-stage3 risky-stage4
+.PHONY: stagefeedback stageprofile
+
+# -----------------------------------------------------
+# Rules for generating translated message descriptions.
+# Disabled by autoconf if the tools are not available.
+# -----------------------------------------------------
+
+XGETTEXT = @XGETTEXT@
+GMSGFMT = @GMSGFMT@
+MSGMERGE = msgmerge
+CATALOGS = @CATALOGS@
+
+.PHONY: build- install- build-po install-po update-po
+
+# Dummy rules to deal with dependencies produced by use of
+# "build-@POSUB@" and "install-@POSUB@" above, when NLS is disabled.
+build-: ; @true
+install-: ; @true
+
+build-po: $(CATALOGS)
+
+# This notation should be acceptable to all Make implementations used
+# by people who are interested in updating .po files.
+update-po: $(CATALOGS:.gmo=.pox)
+
+# N.B. We do not attempt to copy these into $(srcdir).  The snapshot
+# script does that.
+.po.gmo:
+	-test -d po || mkdir po
+	$(GMSGFMT) --statistics -o $@ $<
+
+# The new .po has to be gone over by hand, so we deposit it into
+# build/po with a different extension.
+# If build/po/gcc.pot exists, use it (it was just created),
+# else use the one in srcdir.
+.po.pox:
+	-test -d po || mkdir po
+	$(MSGMERGE) $< `if test -f po/gcc.pot; \
+			then echo po/gcc.pot; \
+			else echo $(srcdir)/po/gcc.pot; fi` -o $@
+
+# This rule has to look for .gmo modules in both srcdir and
+# the cwd, and has to check that we actually have a catalog
+# for each language, in case they weren't built or included
+# with the distribution.
+install-po:
+	$(mkinstalldirs) $(DESTDIR)$(datadir)
+	cats="$(CATALOGS)"; for cat in $$cats; do \
+	  lang=`basename $$cat | sed 's/\.gmo$$//'`; \
+	  if [ -f $$cat ]; then :; \
+	  elif [ -f $(srcdir)/$$cat ]; then cat=$(srcdir)/$$cat; \
+	  else continue; \
+	  fi; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  echo $(mkinstalldirs) $(DESTDIR)$$dir; \
+	  $(mkinstalldirs) $(DESTDIR)$$dir || exit 1; \
+	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
+	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
+	done
+
+# Rule for regenerating the message template (gcc.pot).
+# Instead of forcing everyone to edit POTFILES.in, which proved impractical,
+# this rule has no dependencies and always regenerates gcc.pot.  This is
+# relatively harmless since the .po files do not directly depend on it.
+# Note that exgettext has an awk script embedded in it which requires a
+# fairly modern (POSIX-compliant) awk.
+# The .pot file is left in the build directory.
+gcc.pot: po/gcc.pot
+po/gcc.pot: force
+	-test -d po || mkdir po
+	$(MAKE) srcextra
+	AWK=$(AWK) $(SHELL) $(srcdir)/po/exgettext \
+		$(XGETTEXT) gcc $(srcdir)
diff --git a/gcc/common.opt b/gcc/common.opt
index 6ac77fd..4913e6f 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -1050,11 +1050,11 @@ Common JoinedOrMissing
 Generate debug information in default format
 
 gcoff
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gdwarf-2)
 Generate debug information in COFF format
 
 gdwarf-2
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gstabs)
 Generate debug information in DWARF v2 format
 
 ggdb
@@ -1062,23 +1062,23 @@ Common JoinedOrMissing
 Generate debug information in default extended format
 
 gstabs
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gstabs+)
 Generate debug information in STABS format
 
 gstabs+
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gvms)
 Generate debug information in extended STABS format
 
 gvms
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gxcoff)
 Generate debug information in VMS format
 
 gxcoff
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gxcoff+)
 Generate debug information in XCOFF format
 
 gxcoff+
-Common JoinedOrMissing
+Common JoinedOrMissing Negative(gcoff)
 Generate debug information in extended XCOFF format
 
 o
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index 2a51fcb..ea5151f 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -24,7 +24,7 @@ Target RejectNegative Report Mask(128BIT_LONG_DOUBLE)
 sizeof(long double) is 16
 
 m32
-Target RejectNegative Report InverseMask(64BIT)
+Target RejectNegative Negative(m64) Report InverseMask(64BIT)
 Generate 32bit i386 code
 
 m386
@@ -40,7 +40,7 @@ Target RejectNegative Undocumented
 ;; Deprecated
 
 m64
-Target RejectNegative Report Mask(64BIT)
+Target RejectNegative Negative(m32) Report Mask(64BIT)
 Generate 64bit x86-64 code
 
 m80387
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index 7b9b7d9..d54a02c 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -60,7 +60,7 @@ g++spec.o: $(srcdir)/cp/g++spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) $(CON
 		$(INCLUDES) $(srcdir)/cp/g++spec.c)
 
 # Create the compiler driver for g++.
-GXX_OBJS = gcc.o g++spec.o intl.o prefix.o version.o
+GXX_OBJS = $(GCC_OBJS) g++spec.o intl.o prefix.o version.o
 g++$(exeext): $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)
 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
 	  $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 0a6fe74..f708e02 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -92,7 +92,7 @@ gfortranspec.o: $(srcdir)/fortran/gfortranspec.c $(SYSTEM_H) $(TM_H) $(GCC_H) $(
 		$(INCLUDES) $(srcdir)/fortran/gfortranspec.c)
 
 # Create the compiler driver gfortran.
-GFORTRAN_D_OBJS = gcc.o gfortranspec.o version.o prefix.o intl.o
+GFORTRAN_D_OBJS = $(GCC_OBJS) gfortranspec.o version.o prefix.o intl.o
 gfortran$(exeext): $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)
 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
 	  $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 08fc3a8..81faf22 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -86,6 +86,7 @@ compilation is specified by a string called a "spec".  */
 #include "prefix.h"
 #include "gcc.h"
 #include "flags.h"
+#include "opts.h"
 
 /* By default there is no special suffix for target executables.  */
 /* FIXME: when autoconf is fixed, remove the host check - dj */
@@ -6035,6 +6036,8 @@ main (int argc, const char **argv)
 
   xmalloc_set_program_name (programname);
 
+  prune_options (&argc, &argv);
+
 #ifdef GCC_DRIVER_HOST_INITIALIZATION
   /* Perform host dependent initialization when needed.  */
   GCC_DRIVER_HOST_INITIALIZATION;
diff --git a/gcc/gcc.c.orig b/gcc/gcc.c.orig
new file mode 100644
index 0000000..08fc3a8
--- /dev/null
+++ b/gcc/gcc.c.orig
@@ -0,0 +1,7757 @@
+/* Compiler driver program that can handle many languages.
+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
+   Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.
+
+This paragraph is here to try to keep Sun CC from dying.
+The number of chars here seems crucial!!!!  */
+
+/* This program is the user interface to the C compiler and possibly to
+other compilers.  It is used because compilation is a complicated procedure
+which involves running several programs and passing temporary files between
+them, forwarding the users switches to those programs selectively,
+and deleting the temporary files at the end.
+
+CC recognizes how to compile each input file by suffixes in the file names.
+Once it knows which kind of compilation to perform, the procedure for
+compilation is specified by a string called a "spec".  */
+
+/* A Short Introduction to Adding a Command-Line Option.
+
+   Before adding a command-line option, consider if it is really
+   necessary.  Each additional command-line option adds complexity and
+   is difficult to remove in subsequent versions.
+
+   In the following, consider adding the command-line argument
+   `--bar'.
+
+   1. Each command-line option is specified in the specs file.  The
+   notation is described below in the comment entitled "The Specs
+   Language".  Read it.
+
+   2. In this file, add an entry to "option_map" equating the long
+   `--' argument version and any shorter, single letter version.  Read
+   the comments in the declaration of "struct option_map" for an
+   explanation.  Do not omit the first `-'.
+
+   3. Look in the "specs" file to determine which program or option
+   list should be given the argument, e.g., "cc1_options".  Add the
+   appropriate syntax for the shorter option version to the
+   corresponding "const char *" entry in this file.  Omit the first
+   `-' from the option.  For example, use `-bar', rather than `--bar'.
+
+   4. If the argument takes an argument, e.g., `--baz argument1',
+   modify either DEFAULT_SWITCH_TAKES_ARG or
+   DEFAULT_WORD_SWITCH_TAKES_ARG in gcc.h.  Omit the first `-'
+   from `--baz'.
+
+   5. Document the option in this file's display_help().  If the
+   option is passed to a subprogram, modify its corresponding
+   function, e.g., cppinit.c:print_help() or toplev.c:display_help(),
+   instead.
+
+   6. Compile and test.  Make sure that your new specs file is being
+   read.  For example, use a debugger to investigate the value of
+   "specs_file" in main().  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "multilib.h" /* before tm.h */
+#include "tm.h"
+#include <signal.h>
+#if ! defined( SIGCHLD ) && defined( SIGCLD )
+#  define SIGCHLD SIGCLD
+#endif
+#include "xregex.h"
+#include "obstack.h"
+#include "intl.h"
+#include "prefix.h"
+#include "gcc.h"
+#include "flags.h"
+
+/* By default there is no special suffix for target executables.  */
+/* FIXME: when autoconf is fixed, remove the host check - dj */
+#if defined(TARGET_EXECUTABLE_SUFFIX) && defined(HOST_EXECUTABLE_SUFFIX)
+#define HAVE_TARGET_EXECUTABLE_SUFFIX
+#endif
+
+/* By default there is no special suffix for host executables.  */
+#ifdef HOST_EXECUTABLE_SUFFIX
+#define HAVE_HOST_EXECUTABLE_SUFFIX
+#else
+#define HOST_EXECUTABLE_SUFFIX ""
+#endif
+
+/* By default, the suffix for target object files is ".o".  */
+#ifdef TARGET_OBJECT_SUFFIX
+#define HAVE_TARGET_OBJECT_SUFFIX
+#else
+#define TARGET_OBJECT_SUFFIX ".o"
+#endif
+
+static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };
+
+/* Most every one is fine with LIBRARY_PATH.  For some, it conflicts.  */
+#ifndef LIBRARY_PATH_ENV
+#define LIBRARY_PATH_ENV "LIBRARY_PATH"
+#endif
+
+#ifndef HAVE_KILL
+#define kill(p,s) raise(s)
+#endif
+
+/* If a stage of compilation returns an exit status >= 1,
+   compilation of that file ceases.  */
+
+#define MIN_FATAL_STATUS 1
+
+/* Flag set by cppspec.c to 1.  */
+int is_cpp_driver;
+
+/* Flag saying to pass the greatest exit code returned by a sub-process
+   to the calling program.  */
+static int pass_exit_codes;
+
+/* Definition of string containing the arguments given to configure.  */
+#include "configargs.h"
+
+/* Flag saying to print the directories gcc will search through looking for
+   programs, libraries, etc.  */
+
+static int print_search_dirs;
+
+/* Flag saying to print the full filename of this file
+   as found through our usual search mechanism.  */
+
+static const char *print_file_name = NULL;
+
+/* As print_file_name, but search for executable file.  */
+
+static const char *print_prog_name = NULL;
+
+/* Flag saying to print the relative path we'd use to
+   find libgcc.a given the current compiler flags.  */
+
+static int print_multi_directory;
+
+/* Flag saying to print the relative path we'd use to
+   find OS libraries given the current compiler flags.  */
+
+static int print_multi_os_directory;
+
+/* Flag saying to print the list of subdirectories and
+   compiler flags used to select them in a standard form.  */
+
+static int print_multi_lib;
+
+/* Flag saying to print the command line options understood by gcc and its
+   sub-processes.  */
+
+static int print_help_list;
+
+/* Flag indicating whether we should print the command and arguments */
+
+static int verbose_flag;
+
+/* Flag indicating whether we should ONLY print the command and
+   arguments (like verbose_flag) without executing the command.
+   Displayed arguments are quoted so that the generated command
+   line is suitable for execution.  This is intended for use in
+   shell scripts to capture the driver-generated command line.  */
+static int verbose_only_flag;
+
+/* Flag indicating to print target specific command line options.  */
+
+static int target_help_flag;
+
+/* Flag indicating whether we should report subprocess execution times
+   (if this is supported by the system - see pexecute.c).  */
+
+static int report_times;
+
+/* Nonzero means place this string before uses of /, so that include
+   and library files can be found in an alternate location.  */
+
+#ifdef TARGET_SYSTEM_ROOT
+static const char *target_system_root = TARGET_SYSTEM_ROOT;
+#else
+static const char *target_system_root = 0;
+#endif
+
+/* Nonzero means pass the updated target_system_root to the compiler.  */
+
+static int target_system_root_changed;
+
+/* Nonzero means append this string to target_system_root.  */
+
+static const char *target_sysroot_suffix = 0;
+
+/* Nonzero means append this string to target_system_root for headers.  */
+
+static const char *target_sysroot_hdrs_suffix = 0;
+
+/* Nonzero means write "temp" files in source directory
+   and use the source file's name in them, and don't delete them.  */
+
+static int save_temps_flag;
+
+/* Nonzero means pass multiple source files to the compiler at one time.  */
+
+static int combine_flag = 0;
+
+/* Nonzero means use pipes to communicate between subprocesses.
+   Overridden by either of the above two flags.  */
+
+static int use_pipes;
+
+/* The compiler version.  */
+
+static const char *compiler_version;
+
+/* The target version specified with -V */
+
+static const char *const spec_version = DEFAULT_TARGET_VERSION;
+
+/* The target machine specified with -b.  */
+
+static const char *spec_machine = DEFAULT_TARGET_MACHINE;
+
+/* Nonzero if cross-compiling.
+   When -b is used, the value comes from the `specs' file.  */
+
+#ifdef CROSS_COMPILE
+static const char *cross_compile = "1";
+#else
+static const char *cross_compile = "0";
+#endif
+
+#ifdef MODIFY_TARGET_NAME
+
+/* Information on how to alter the target name based on a command-line
+   switch.  The only case we support now is simply appending or deleting a
+   string to or from the end of the first part of the configuration name.  */
+
+static const struct modify_target
+{
+  const char *const sw;
+  const enum add_del {ADD, DELETE} add_del;
+  const char *const str;
+}
+modify_target[] = MODIFY_TARGET_NAME;
+#endif
+
+/* The number of errors that have occurred; the link phase will not be
+   run if this is nonzero.  */
+static int error_count = 0;
+
+/* Greatest exit code of sub-processes that has been encountered up to
+   now.  */
+static int greatest_status = 1;
+
+/* This is the obstack which we use to allocate many strings.  */
+
+static struct obstack obstack;
+
+/* This is the obstack to build an environment variable to pass to
+   collect2 that describes all of the relevant switches of what to
+   pass the compiler in building the list of pointers to constructors
+   and destructors.  */
+
+static struct obstack collect_obstack;
+
+/* Forward declaration for prototypes.  */
+struct path_prefix;
+struct prefix_list;
+
+static void init_spec (void);
+static void store_arg (const char *, int, int);
+static char *load_specs (const char *);
+static void read_specs (const char *, int);
+static void set_spec (const char *, const char *);
+static struct compiler *lookup_compiler (const char *, size_t, const char *);
+static char *build_search_list (struct path_prefix *, const char *, int);
+static void putenv_from_prefixes (struct path_prefix *, const char *);
+static int access_check (const char *, int);
+static char *find_a_file (struct path_prefix *, const char *, int, int);
+static void add_prefix (struct path_prefix *, const char *, const char *,
+			int, int, int);
+static void add_sysrooted_prefix (struct path_prefix *, const char *,
+				  const char *, int, int, int);
+static void translate_options (int *, const char *const **);
+static char *skip_whitespace (char *);
+static void delete_if_ordinary (const char *);
+static void delete_temp_files (void);
+static void delete_failure_queue (void);
+static void clear_failure_queue (void);
+static int check_live_switch (int, int);
+static const char *handle_braces (const char *);
+static inline bool input_suffix_matches (const char *, const char *);
+static inline bool switch_matches (const char *, const char *, int);
+static inline void mark_matching_switches (const char *, const char *, int);
+static inline void process_marked_switches (void);
+static const char *process_brace_body (const char *, const char *, const char *, int, int);
+static const struct spec_function *lookup_spec_function (const char *);
+static const char *eval_spec_function (const char *, const char *);
+static const char *handle_spec_function (const char *);
+static char *save_string (const char *, int);
+static void set_collect_gcc_options (void);
+static void do_spec_path (struct prefix_list *, const char *, int, int, int, const char *, const char *);
+static int do_spec_1 (const char *, int, const char *);
+static int do_spec_2 (const char *);
+static void do_option_spec (const char *, const char *);
+static void do_self_spec (const char *);
+static const char *find_file (const char *);
+static int is_directory (const char *, const char *, int);
+static const char *validate_switches (const char *);
+static void validate_all_switches (void);
+static inline void validate_switches_from_spec (const char *);
+static void give_switch (int, int);
+static int used_arg (const char *, int);
+static int default_arg (const char *, int);
+static void set_multilib_dir (void);
+static void print_multilib_info (void);
+static void perror_with_name (const char *);
+static void notice (const char *, ...) ATTRIBUTE_PRINTF_1;
+static void display_help (void);
+static void add_preprocessor_option (const char *, int);
+static void add_assembler_option (const char *, int);
+static void add_linker_option (const char *, int);
+static void process_command (int, const char **);
+static int execute (void);
+static void alloc_args (void);
+static void clear_args (void);
+static void fatal_error (int);
+#if defined(ENABLE_SHARED_LIBGCC) && !defined(REAL_LIBGCC_SPEC)
+static void init_gcc_specs (struct obstack *, const char *, const char *,
+			    const char *);
+#endif
+#if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+static const char *convert_filename (const char *, int, int);
+#endif
+
+static const char *if_exists_spec_function (int, const char **);
+static const char *if_exists_else_spec_function (int, const char **);
+static const char *replace_outfile_spec_function (int, const char **);
+static const char *version_compare_spec_function (int, const char **);
+
+/* The Specs Language
+
+Specs are strings containing lines, each of which (if not blank)
+is made up of a program name, and arguments separated by spaces.
+The program name must be exact and start from root, since no path
+is searched and it is unreliable to depend on the current working directory.
+Redirection of input or output is not supported; the subprograms must
+accept filenames saying what files to read and write.
+
+In addition, the specs can contain %-sequences to substitute variable text
+or for conditional text.  Here is a table of all defined %-sequences.
+Note that spaces are not generated automatically around the results of
+expanding these sequences; therefore, you can concatenate them together
+or with constant text in a single argument.
+
+ %%	substitute one % into the program name or argument.
+ %i     substitute the name of the input file being processed.
+ %b     substitute the basename of the input file being processed.
+	This is the substring up to (and not including) the last period
+	and not including the directory.
+ %B	same as %b, but include the file suffix (text after the last period).
+ %gSUFFIX
+	substitute a file name that has suffix SUFFIX and is chosen
+	once per compilation, and mark the argument a la %d.  To reduce
+	exposure to denial-of-service attacks, the file name is now
+	chosen in a way that is hard to predict even when previously
+	chosen file names are known.  For example, `%g.s ... %g.o ... %g.s'
+	might turn into `ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s'.  SUFFIX matches
+	the regexp "[.0-9A-Za-z]*%O"; "%O" is treated exactly as if it
+	had been pre-processed.  Previously, %g was simply substituted
+	with a file name chosen once per compilation, without regard
+	to any appended suffix (which was therefore treated just like
+	ordinary text), making such attacks more likely to succeed.
+ %|SUFFIX
+	like %g, but if -pipe is in effect, expands simply to "-".
+ %mSUFFIX
+        like %g, but if -pipe is in effect, expands to nothing.  (We have both
+	%| and %m to accommodate differences between system assemblers; see
+	the AS_NEEDS_DASH_FOR_PIPED_INPUT target macro.)
+ %uSUFFIX
+	like %g, but generates a new temporary file name even if %uSUFFIX
+	was already seen.
+ %USUFFIX
+	substitutes the last file name generated with %uSUFFIX, generating a
+	new one if there is no such last file name.  In the absence of any
+	%uSUFFIX, this is just like %gSUFFIX, except they don't share
+	the same suffix "space", so `%g.s ... %U.s ... %g.s ... %U.s'
+	would involve the generation of two distinct file names, one
+	for each `%g.s' and another for each `%U.s'.  Previously, %U was
+	simply substituted with a file name chosen for the previous %u,
+	without regard to any appended suffix.
+ %jSUFFIX
+        substitutes the name of the HOST_BIT_BUCKET, if any, and if it is
+        writable, and if save-temps is off; otherwise, substitute the name
+        of a temporary file, just like %u.  This temporary file is not
+        meant for communication between processes, but rather as a junk
+        disposal mechanism.
+ %.SUFFIX
+        substitutes .SUFFIX for the suffixes of a matched switch's args when
+        it is subsequently output with %*. SUFFIX is terminated by the next
+        space or %.
+ %d	marks the argument containing or following the %d as a
+	temporary file name, so that that file will be deleted if CC exits
+	successfully.  Unlike %g, this contributes no text to the argument.
+ %w	marks the argument containing or following the %w as the
+	"output file" of this compilation.  This puts the argument
+	into the sequence of arguments that %o will substitute later.
+ %V	indicates that this compilation produces no "output file".
+ %W{...}
+	like %{...} but mark last argument supplied within
+	as a file to be deleted on failure.
+ %o	substitutes the names of all the output files, with spaces
+	automatically placed around them.  You should write spaces
+	around the %o as well or the results are undefined.
+	%o is for use in the specs for running the linker.
+	Input files whose names have no recognized suffix are not compiled
+	at all, but they are included among the output files, so they will
+	be linked.
+ %O	substitutes the suffix for object files.  Note that this is
+        handled specially when it immediately follows %g, %u, or %U
+	(with or without a suffix argument) because of the need for
+	those to form complete file names.  The handling is such that
+	%O is treated exactly as if it had already been substituted,
+	except that %g, %u, and %U do not currently support additional
+	SUFFIX characters following %O as they would following, for
+	example, `.o'.
+ %I	Substitute any of -iprefix (made from GCC_EXEC_PREFIX), -isysroot
+	(made from TARGET_SYSTEM_ROOT), and -isystem (made from COMPILER_PATH
+	and -B options) as necessary.
+ %s     current argument is the name of a library or startup file of some sort.
+        Search for that file in a standard list of directories
+	and substitute the full name found.
+ %eSTR  Print STR as an error message.  STR is terminated by a newline.
+        Use this when inconsistent options are detected.
+ %nSTR  Print STR as a notice.  STR is terminated by a newline.
+ %x{OPTION}	Accumulate an option for %X.
+ %X	Output the accumulated linker options specified by compilations.
+ %Y	Output the accumulated assembler options specified by compilations.
+ %Z	Output the accumulated preprocessor options specified by compilations.
+ %a     process ASM_SPEC as a spec.
+        This allows config.h to specify part of the spec for running as.
+ %A	process ASM_FINAL_SPEC as a spec.  A capital A is actually
+	used here.  This can be used to run a post-processor after the
+	assembler has done its job.
+ %D	Dump out a -L option for each directory in startfile_prefixes.
+	If multilib_dir is set, extra entries are generated with it affixed.
+ %l     process LINK_SPEC as a spec.
+ %L     process LIB_SPEC as a spec.
+ %G     process LIBGCC_SPEC as a spec.
+ %R     Output the concatenation of target_system_root and
+        target_sysroot_suffix.
+ %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.
+ %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.
+ %C     process CPP_SPEC as a spec.
+ %1	process CC1_SPEC as a spec.
+ %2	process CC1PLUS_SPEC as a spec.
+ %*	substitute the variable part of a matched option.  (See below.)
+	Note that each comma in the substituted string is replaced by
+	a single space.
+ %<S    remove all occurrences of -S from the command line.
+        Note - this command is position dependent.  % commands in the
+        spec string before this one will see -S, % commands in the
+        spec string after this one will not.
+ %<S*	remove all occurrences of all switches beginning with -S from the
+        command line.
+ %:function(args)
+	Call the named function FUNCTION, passing it ARGS.  ARGS is
+	first processed as a nested spec string, then split into an
+	argument vector in the usual fashion.  The function returns
+	a string which is processed as if it had appeared literally
+	as part of the current spec.
+ %{S}   substitutes the -S switch, if that switch was given to CC.
+	If that switch was not specified, this substitutes nothing.
+	Here S is a metasyntactic variable.
+ %{S*}  substitutes all the switches specified to CC whose names start
+	with -S.  This is used for -o, -I, etc; switches that take
+	arguments.  CC considers `-o foo' as being one switch whose
+	name starts with `o'.  %{o*} would substitute this text,
+	including the space; thus, two arguments would be generated.
+ %{S*&T*} likewise, but preserve order of S and T options (the order
+	of S and T in the spec is not significant).  Can be any number
+	of ampersand-separated variables; for each the wild card is
+	optional.  Useful for CPP as %{D*&U*&A*}.
+
+ %{S:X}   substitutes X, if the -S switch was given to CC.
+ %{!S:X}  substitutes X, if the -S switch was NOT given to CC.
+ %{S*:X}  substitutes X if one or more switches whose names start
+          with -S was given to CC.  Normally X is substituted only
+          once, no matter how many such switches appeared.  However,
+          if %* appears somewhere in X, then X will be substituted
+          once for each matching switch, with the %* replaced by the
+          part of that switch that matched the '*'.
+ %{.S:X}  substitutes X, if processing a file with suffix S.
+ %{!.S:X} substitutes X, if NOT processing a file with suffix S.
+
+ %{S|T:X} substitutes X if either -S or -T was given to CC.  This may be
+	  combined with !, ., and * as above binding stronger than the OR.
+	  If %* appears in X, all of the alternatives must be starred, and
+	  only the first matching alternative is substituted.
+ %{S:X;   if S was given to CC, substitutes X;
+   T:Y;   else if T was given to CC, substitutes Y;
+    :D}   else substitutes D.  There can be as many clauses as you need.
+          This may be combined with ., !, |, and * as above.
+
+ %(Spec) processes a specification defined in a specs file as *Spec:
+ %[Spec] as above, but put __ around -D arguments
+
+The conditional text X in a %{S:X} or similar construct may contain
+other nested % constructs or spaces, or even newlines.  They are
+processed as usual, as described above.  Trailing white space in X is
+ignored.  White space may also appear anywhere on the left side of the
+colon in these constructs, except between . or * and the corresponding
+word.
+
+The -O, -f, -m, and -W switches are handled specifically in these
+constructs.  If another value of -O or the negated form of a -f, -m, or
+-W switch is found later in the command line, the earlier switch
+value is ignored, except with {S*} where S is just one letter; this
+passes all matching options.
+
+The character | at the beginning of the predicate text is used to indicate
+that a command should be piped to the following command, but only if -pipe
+is specified.
+
+Note that it is built into CC which switches take arguments and which
+do not.  You might think it would be useful to generalize this to
+allow each compiler's spec to say which switches take arguments.  But
+this cannot be done in a consistent fashion.  CC cannot even decide
+which input files have been specified without knowing which switches
+take arguments, and it must know which input files to compile in order
+to tell which compilers to run.
+
+CC also knows implicitly that arguments starting in `-l' are to be
+treated as compiler output files, and passed to the linker in their
+proper position among the other output files.  */
+
+/* Define the macros used for specs %a, %l, %L, %S, %C, %1.  */
+
+/* config.h can define ASM_SPEC to provide extra args to the assembler
+   or extra switch-translations.  */
+#ifndef ASM_SPEC
+#define ASM_SPEC ""
+#endif
+
+/* config.h can define ASM_FINAL_SPEC to run a post processor after
+   the assembler has run.  */
+#ifndef ASM_FINAL_SPEC
+#define ASM_FINAL_SPEC ""
+#endif
+
+/* config.h can define CPP_SPEC to provide extra args to the C preprocessor
+   or extra switch-translations.  */
+#ifndef CPP_SPEC
+#define CPP_SPEC ""
+#endif
+
+/* config.h can define CC1_SPEC to provide extra args to cc1 and cc1plus
+   or extra switch-translations.  */
+#ifndef CC1_SPEC
+#define CC1_SPEC ""
+#endif
+
+/* config.h can define CC1PLUS_SPEC to provide extra args to cc1plus
+   or extra switch-translations.  */
+#ifndef CC1PLUS_SPEC
+#define CC1PLUS_SPEC ""
+#endif
+
+/* config.h can define LINK_SPEC to provide extra args to the linker
+   or extra switch-translations.  */
+#ifndef LINK_SPEC
+#define LINK_SPEC ""
+#endif
+
+/* config.h can define LIB_SPEC to override the default libraries.  */
+#ifndef LIB_SPEC
+#define LIB_SPEC "%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"
+#endif
+
+/* mudflap specs */
+#ifndef MFWRAP_SPEC
+/* XXX: valid only for GNU ld */
+/* XXX: should exactly match hooks provided by libmudflap.a */
+#define MFWRAP_SPEC " %{static: %{fmudflap|fmudflapth: \
+ --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\
+ --wrap=mmap --wrap=munmap --wrap=alloca\
+} %{fmudflapth: --wrap=pthread_create\
+}} %{fmudflap|fmudflapth: --wrap=main}"
+#endif
+#ifndef MFLIB_SPEC
+#define MFLIB_SPEC "%{fmudflap|fmudflapth: -export-dynamic}"
+#endif
+
+/* config.h can define LIBGCC_SPEC to override how and when libgcc.a is
+   included.  */
+#ifndef LIBGCC_SPEC
+#if defined(REAL_LIBGCC_SPEC)
+#define LIBGCC_SPEC REAL_LIBGCC_SPEC
+#elif defined(LINK_LIBGCC_SPECIAL_1)
+/* Have gcc do the search for libgcc.a.  */
+#define LIBGCC_SPEC "libgcc.a%s"
+#else
+#define LIBGCC_SPEC "-lgcc"
+#endif
+#endif
+
+/* config.h can define STARTFILE_SPEC to override the default crt0 files.  */
+#ifndef STARTFILE_SPEC
+#define STARTFILE_SPEC  \
+  "%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}"
+#endif
+
+/* config.h can define SWITCHES_NEED_SPACES to control which options
+   require spaces between the option and the argument.  */
+#ifndef SWITCHES_NEED_SPACES
+#define SWITCHES_NEED_SPACES ""
+#endif
+
+/* config.h can define ENDFILE_SPEC to override the default crtn files.  */
+#ifndef ENDFILE_SPEC
+#define ENDFILE_SPEC ""
+#endif
+
+#ifndef LINKER_NAME
+#define LINKER_NAME "collect2"
+#endif
+
+/* Define ASM_DEBUG_SPEC to be a spec suitable for translating '-g'
+   to the assembler.  */
+#ifndef ASM_DEBUG_SPEC
+# if defined(DBX_DEBUGGING_INFO) && defined(DWARF2_DEBUGGING_INFO) \
+     && defined(HAVE_AS_GDWARF2_DEBUG_FLAG) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
+#  define ASM_DEBUG_SPEC					\
+      (PREFERRED_DEBUGGING_TYPE == DBX_DEBUG			\
+       ? "%{gdwarf-2*:--gdwarf2}%{!gdwarf-2*:%{g*:--gstabs}}"	\
+       : "%{gstabs*:--gstabs}%{!gstabs*:%{g*:--gdwarf2}}")
+# else
+#  if defined(DBX_DEBUGGING_INFO) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
+#   define ASM_DEBUG_SPEC "%{g*:--gstabs}"
+#  endif
+#  if defined(DWARF2_DEBUGGING_INFO) && defined(HAVE_AS_GDWARF2_DEBUG_FLAG)
+#   define ASM_DEBUG_SPEC "%{g*:--gdwarf2}"
+#  endif
+# endif
+#endif
+#ifndef ASM_DEBUG_SPEC
+# define ASM_DEBUG_SPEC ""
+#endif
+
+/* Here is the spec for running the linker, after compiling all files.  */
+
+/* This is overridable by the target in case they need to specify the
+   -lgcc and -lc order specially, yet not require them to override all
+   of LINK_COMMAND_SPEC.  */
+#ifndef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC "%G %L %G"
+#endif
+
+#ifndef LINK_SSP_SPEC
+#ifdef TARGET_LIBC_PROVIDES_SSP
+#define LINK_SSP_SPEC "%{fstack-protector:}"
+#else
+#define LINK_SSP_SPEC "%{fstack-protector|fstack-protector-all:-lssp_nonshared -lssp}"
+#endif
+#endif
+
+#ifndef LINK_PIE_SPEC
+#ifdef HAVE_LD_PIE
+#define LINK_PIE_SPEC "%{pie:-pie} "
+#else
+#define LINK_PIE_SPEC "%{pie:} "
+#endif
+#endif
+
+/* -u* was put back because both BSD and SysV seem to support it.  */
+/* %{static:} simply prevents an error message if the target machine
+   doesn't handle -static.  */
+/* We want %{T*} after %{L*} and %D so that it can be used to specify linker
+   scripts which exist in user specified directories, or in standard
+   directories.  */
+#ifndef LINK_COMMAND_SPEC
+#define LINK_COMMAND_SPEC "\
+%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
+    %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o %(mflib)\
+    %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
+#endif
+
+#ifndef LINK_LIBGCC_SPEC
+/* Generate -L options for startfile prefix list.  */
+# define LINK_LIBGCC_SPEC "%D"
+#endif
+
+#ifndef STARTFILE_PREFIX_SPEC
+# define STARTFILE_PREFIX_SPEC ""
+#endif
+
+#ifndef SYSROOT_SPEC
+# define SYSROOT_SPEC "--sysroot=%R"
+#endif
+
+#ifndef SYSROOT_SUFFIX_SPEC
+# define SYSROOT_SUFFIX_SPEC ""
+#endif
+
+#ifndef SYSROOT_HEADERS_SUFFIX_SPEC
+# define SYSROOT_HEADERS_SUFFIX_SPEC ""
+#endif
+
+static const char *asm_debug;
+static const char *cpp_spec = CPP_SPEC;
+static const char *cc1_spec = CC1_SPEC;
+static const char *cc1plus_spec = CC1PLUS_SPEC;
+static const char *link_gcc_c_sequence_spec = LINK_GCC_C_SEQUENCE_SPEC;
+static const char *link_ssp_spec = LINK_SSP_SPEC;
+static const char *asm_spec = ASM_SPEC;
+static const char *asm_final_spec = ASM_FINAL_SPEC;
+static const char *link_spec = LINK_SPEC;
+static const char *lib_spec = LIB_SPEC;
+static const char *mfwrap_spec = MFWRAP_SPEC;
+static const char *mflib_spec = MFLIB_SPEC;
+static const char *libgcc_spec = LIBGCC_SPEC;
+static const char *endfile_spec = ENDFILE_SPEC;
+static const char *startfile_spec = STARTFILE_SPEC;
+static const char *switches_need_spaces = SWITCHES_NEED_SPACES;
+static const char *linker_name_spec = LINKER_NAME;
+static const char *link_command_spec = LINK_COMMAND_SPEC;
+static const char *link_libgcc_spec = LINK_LIBGCC_SPEC;
+static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;
+static const char *sysroot_spec = SYSROOT_SPEC;
+static const char *sysroot_suffix_spec = SYSROOT_SUFFIX_SPEC;
+static const char *sysroot_hdrs_suffix_spec = SYSROOT_HEADERS_SUFFIX_SPEC;
+
+/* Standard options to cpp, cc1, and as, to reduce duplication in specs.
+   There should be no need to override these in target dependent files,
+   but we need to copy them to the specs file so that newer versions
+   of the GCC driver can correctly drive older tool chains with the
+   appropriate -B options.  */
+
+/* When cpplib handles traditional preprocessing, get rid of this, and
+   call cc1 (or cc1obj in objc/lang-specs.h) from the main specs so
+   that we default the front end language better.  */
+static const char *trad_capable_cpp =
+"cc1 -E %{traditional|ftraditional|traditional-cpp:-traditional-cpp}";
+
+/* We don't wrap .d files in %W{} since a missing .d file, and
+   therefore no dependency entry, confuses make into thinking a .o
+   file that happens to exist is up-to-date.  */
+static const char *cpp_unique_options =
+"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\
+ %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\
+ %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
+ %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\
+ %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\
+ %{!E:%{!M:%{!MM:%{MD|MMD:%{o*:-MQ %*}}}}}\
+ %{remap} %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\
+ %{fmudflap:-D_MUDFLAP -include mf-runtime.h}\
+ %{fmudflapth:-D_MUDFLAP -D_MUDFLAPTH -include mf-runtime.h}\
+ %{E|M|MM:%W{o*}}";
+
+/* This contains cpp options which are common with cc1_options and are passed
+   only when preprocessing only to avoid duplication.  We pass the cc1 spec
+   options to the preprocessor so that it the cc1 spec may manipulate
+   options used to set target flags.  Those special target flags settings may
+   in turn cause preprocessor symbols to be defined specially.  */
+static const char *cpp_options =
+"%(cpp_unique_options) %1 %{m*} %{std*&ansi&trigraphs} %{W*&pedantic*} %{w}\
+ %{f*} %{g*:%{!g0:%{!fno-working-directory:-fworking-directory}}} %{O*}\
+ %{undef} %{save-temps:-fpch-preprocess}";
+
+/* This contains cpp options which are not passed when the preprocessor
+   output will be used by another program.  */
+static const char *cpp_debug_options = "%{d*}";
+
+/* NB: This is shared amongst all front-ends.  */
+static const char *cc1_options =
+"%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\
+ %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\
+ %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\
+ %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\
+ %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\
+ %{Qn:-fno-ident} %{--help:--help}\
+ %{--target-help:--target-help}\
+ %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\
+ %{fsyntax-only:-o %j} %{-param*}\
+ %{fmudflap|fmudflapth:-fno-builtin -fno-merge-constants}\
+ %{coverage:-fprofile-arcs -ftest-coverage}";
+
+static const char *asm_options =
+"%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}";
+
+static const char *invoke_as =
+#ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT
+"%{!S:-o %|.s |\n as %(asm_options) %|.s %A }";
+#else
+"%{!S:-o %|.s |\n as %(asm_options) %m.s %A }";
+#endif
+
+/* Some compilers have limits on line lengths, and the multilib_select
+   and/or multilib_matches strings can be very long, so we build them at
+   run time.  */
+static struct obstack multilib_obstack;
+static const char *multilib_select;
+static const char *multilib_matches;
+static const char *multilib_defaults;
+static const char *multilib_exclusions;
+
+/* Check whether a particular argument is a default argument.  */
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "" }
+#endif
+
+static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;
+
+#ifndef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS ""
+#endif
+
+static const char *const driver_self_specs[] = { DRIVER_SELF_SPECS };
+
+#ifndef OPTION_DEFAULT_SPECS
+#define OPTION_DEFAULT_SPECS { "", "" }
+#endif
+
+struct default_spec
+{
+  const char *name;
+  const char *spec;
+};
+
+static const struct default_spec
+  option_default_specs[] = { OPTION_DEFAULT_SPECS };
+
+struct user_specs
+{
+  struct user_specs *next;
+  const char *filename;
+};
+
+static struct user_specs *user_specs_head, *user_specs_tail;
+
+#ifndef SWITCH_TAKES_ARG
+#define SWITCH_TAKES_ARG(CHAR) DEFAULT_SWITCH_TAKES_ARG(CHAR)
+#endif
+
+#ifndef WORD_SWITCH_TAKES_ARG
+#define WORD_SWITCH_TAKES_ARG(STR) DEFAULT_WORD_SWITCH_TAKES_ARG (STR)
+#endif
+
+#ifdef HAVE_TARGET_EXECUTABLE_SUFFIX
+/* This defines which switches stop a full compilation.  */
+#define DEFAULT_SWITCH_CURTAILS_COMPILATION(CHAR) \
+  ((CHAR) == 'c' || (CHAR) == 'S')
+
+#ifndef SWITCH_CURTAILS_COMPILATION
+#define SWITCH_CURTAILS_COMPILATION(CHAR) \
+  DEFAULT_SWITCH_CURTAILS_COMPILATION(CHAR)
+#endif
+#endif
+
+/* Record the mapping from file suffixes for compilation specs.  */
+
+struct compiler
+{
+  const char *suffix;		/* Use this compiler for input files
+				   whose names end in this suffix.  */
+
+  const char *spec;		/* To use this compiler, run this spec.  */
+
+  const char *cpp_spec;         /* If non-NULL, substitute this spec
+				   for `%C', rather than the usual
+				   cpp_spec.  */
+  const int combinable;          /* If nonzero, compiler can deal with
+				    multiple source files at once (IMA).  */
+  const int needs_preprocessing; /* If nonzero, source files need to
+				    be run through a preprocessor.  */
+};
+
+/* Pointer to a vector of `struct compiler' that gives the spec for
+   compiling a file, based on its suffix.
+   A file that does not end in any of these suffixes will be passed
+   unchanged to the loader and nothing else will be done to it.
+
+   An entry containing two 0s is used to terminate the vector.
+
+   If multiple entries match a file, the last matching one is used.  */
+
+static struct compiler *compilers;
+
+/* Number of entries in `compilers', not counting the null terminator.  */
+
+static int n_compilers;
+
+/* The default list of file name suffixes and their compilation specs.  */
+
+static const struct compiler default_compilers[] =
+{
+  /* Add lists of suffixes of known languages here.  If those languages
+     were not present when we built the driver, we will hit these copies
+     and be given a more meaningful error than "file not used since
+     linking is not done".  */
+  {".m",  "#Objective-C", 0, 0, 0}, {".mi",  "#Objective-C", 0, 0, 0},
+  {".mm", "#Objective-C++", 0, 0, 0}, {".M", "#Objective-C++", 0, 0, 0},
+  {".mii", "#Objective-C++", 0, 0, 0},
+  {".cc", "#C++", 0, 0, 0}, {".cxx", "#C++", 0, 0, 0},
+  {".cpp", "#C++", 0, 0, 0}, {".cp", "#C++", 0, 0, 0},
+  {".c++", "#C++", 0, 0, 0}, {".C", "#C++", 0, 0, 0},
+  {".CPP", "#C++", 0, 0, 0}, {".ii", "#C++", 0, 0, 0},
+  {".ads", "#Ada", 0, 0, 0}, {".adb", "#Ada", 0, 0, 0},
+  {".f", "#Fortran", 0, 0, 0}, {".for", "#Fortran", 0, 0, 0},
+  {".fpp", "#Fortran", 0, 0, 0}, {".F", "#Fortran", 0, 0, 0},
+  {".FOR", "#Fortran", 0, 0, 0}, {".FPP", "#Fortran", 0, 0, 0},
+  {".f90", "#Fortran", 0, 0, 0}, {".f95", "#Fortran", 0, 0, 0},
+  {".F90", "#Fortran", 0, 0, 0}, {".F95", "#Fortran", 0, 0, 0},
+  {".r", "#Ratfor", 0, 0, 0},
+  {".p", "#Pascal", 0, 0, 0}, {".pas", "#Pascal", 0, 0, 0},
+  {".java", "#Java", 0, 0, 0}, {".class", "#Java", 0, 0, 0},
+  {".zip", "#Java", 0, 0, 0}, {".jar", "#Java", 0, 0, 0},
+  /* Next come the entries for C.  */
+  {".c", "@c", 0, 1, 1},
+  {"@c",
+   /* cc1 has an integrated ISO C preprocessor.  We should invoke the
+      external preprocessor if -save-temps is given.  */
+     "%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\
+      %{!E:%{!M:%{!MM:\
+          %{traditional|ftraditional:\
+%eGNU C no longer supports -traditional without -E}\
+       %{!combine:\
+	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \
+		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
+		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
+			%(cc1_options)}\
+	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
+		cc1 %(cpp_unique_options) %(cc1_options)}}}\
+          %{!fsyntax-only:%(invoke_as)}} \
+      %{combine:\
+	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \
+		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i}}\
+	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
+		cc1 %(cpp_unique_options) %(cc1_options)}}\
+                %{!fsyntax-only:%(invoke_as)}}}}}}", 0, 1, 1},
+  {"-",
+   "%{!E:%e-E or -x required when input is from standard input}\
+    %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)", 0, 0, 0},
+  {".h", "@c-header", 0, 0, 0},
+  {"@c-header",
+   /* cc1 has an integrated ISO C preprocessor.  We should invoke the
+      external preprocessor if -save-temps is given.  */
+     "%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\
+      %{!E:%{!M:%{!MM:\
+	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \
+		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
+		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
+			%(cc1_options)\
+                        -o %g.s %{!o*:--output-pch=%i.gch}\
+                        %W{o*:--output-pch=%*}%V}\
+	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
+		cc1 %(cpp_unique_options) %(cc1_options)\
+                    -o %g.s %{!o*:--output-pch=%i.gch}\
+                    %W{o*:--output-pch=%*}%V}}}}}}", 0, 0, 0},
+  {".i", "@cpp-output", 0, 1, 0},
+  {"@cpp-output",
+   "%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}", 0, 1, 0},
+  {".s", "@assembler", 0, 1, 0},
+  {"@assembler",
+   "%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}", 0, 1, 0},
+  {".S", "@assembler-with-cpp", 0, 1, 0},
+  {"@assembler-with-cpp",
+#ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT
+   "%(trad_capable_cpp) -lang-asm %(cpp_options)\
+      %{E|M|MM:%(cpp_debug_options)}\
+      %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\
+       as %(asm_debug) %(asm_options) %|.s %A }}}}"
+#else
+   "%(trad_capable_cpp) -lang-asm %(cpp_options)\
+      %{E|M|MM:%(cpp_debug_options)}\
+      %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\
+       as %(asm_debug) %(asm_options) %m.s %A }}}}"
+#endif
+   , 0, 1, 0},
+
+#include "specs.h"
+  /* Mark end of table.  */
+  {0, 0, 0, 0, 0}
+};
+
+/* Number of elements in default_compilers, not counting the terminator.  */
+
+static const int n_default_compilers = ARRAY_SIZE (default_compilers) - 1;
+
+/* A vector of options to give to the linker.
+   These options are accumulated by %x,
+   and substituted into the linker command with %X.  */
+static int n_linker_options;
+static char **linker_options;
+
+/* A vector of options to give to the assembler.
+   These options are accumulated by -Wa,
+   and substituted into the assembler command with %Y.  */
+static int n_assembler_options;
+static char **assembler_options;
+
+/* A vector of options to give to the preprocessor.
+   These options are accumulated by -Wp,
+   and substituted into the preprocessor command with %Z.  */
+static int n_preprocessor_options;
+static char **preprocessor_options;
+
+/* Define how to map long options into short ones.  */
+
+/* This structure describes one mapping.  */
+struct option_map
+{
+  /* The long option's name.  */
+  const char *const name;
+  /* The equivalent short option.  */
+  const char *const equivalent;
+  /* Argument info.  A string of flag chars; NULL equals no options.
+     a => argument required.
+     o => argument optional.
+     j => join argument to equivalent, making one word.
+     * => require other text after NAME as an argument.  */
+  const char *const arg_info;
+};
+
+/* This is the table of mappings.  Mappings are tried sequentially
+   for each option encountered; the first one that matches, wins.  */
+
+static const struct option_map option_map[] =
+ {
+   {"--all-warnings", "-Wall", 0},
+   {"--ansi", "-ansi", 0},
+   {"--assemble", "-S", 0},
+   {"--assert", "-A", "a"},
+   {"--classpath", "-fclasspath=", "aj"},
+   {"--bootclasspath", "-fbootclasspath=", "aj"},
+   {"--CLASSPATH", "-fclasspath=", "aj"},
+   {"--combine", "-combine", 0},
+   {"--comments", "-C", 0},
+   {"--comments-in-macros", "-CC", 0},
+   {"--compile", "-c", 0},
+   {"--debug", "-g", "oj"},
+   {"--define-macro", "-D", "aj"},
+   {"--dependencies", "-M", 0},
+   {"--dump", "-d", "a"},
+   {"--dumpbase", "-dumpbase", "a"},
+   {"--encoding", "-fencoding=", "aj"},
+   {"--entry", "-e", 0},
+   {"--extra-warnings", "-W", 0},
+   {"--extdirs", "-fextdirs=", "aj"},
+   {"--for-assembler", "-Wa", "a"},
+   {"--for-linker", "-Xlinker", "a"},
+   {"--force-link", "-u", "a"},
+   {"--coverage", "-coverage", 0},
+   {"--imacros", "-imacros", "a"},
+   {"--include", "-include", "a"},
+   {"--include-barrier", "-I-", 0},
+   {"--include-directory", "-I", "aj"},
+   {"--include-directory-after", "-idirafter", "a"},
+   {"--include-prefix", "-iprefix", "a"},
+   {"--include-with-prefix", "-iwithprefix", "a"},
+   {"--include-with-prefix-before", "-iwithprefixbefore", "a"},
+   {"--include-with-prefix-after", "-iwithprefix", "a"},
+   {"--language", "-x", "a"},
+   {"--library-directory", "-L", "a"},
+   {"--machine", "-m", "aj"},
+   {"--machine-", "-m", "*j"},
+   {"--no-integrated-cpp", "-no-integrated-cpp", 0},
+   {"--no-line-commands", "-P", 0},
+   {"--no-precompiled-includes", "-noprecomp", 0},
+   {"--no-standard-includes", "-nostdinc", 0},
+   {"--no-standard-libraries", "-nostdlib", 0},
+   {"--no-warnings", "-w", 0},
+   {"--optimize", "-O", "oj"},
+   {"--output", "-o", "a"},
+   {"--output-class-directory", "-foutput-class-dir=", "ja"},
+   {"--param", "--param", "a"},
+   {"--pass-exit-codes", "-pass-exit-codes", 0},
+   {"--pedantic", "-pedantic", 0},
+   {"--pedantic-errors", "-pedantic-errors", 0},
+   {"--pie", "-pie", 0},
+   {"--pipe", "-pipe", 0},
+   {"--prefix", "-B", "a"},
+   {"--preprocess", "-E", 0},
+   {"--print-search-dirs", "-print-search-dirs", 0},
+   {"--print-file-name", "-print-file-name=", "aj"},
+   {"--print-libgcc-file-name", "-print-libgcc-file-name", 0},
+   {"--print-missing-file-dependencies", "-MG", 0},
+   {"--print-multi-lib", "-print-multi-lib", 0},
+   {"--print-multi-directory", "-print-multi-directory", 0},
+   {"--print-multi-os-directory", "-print-multi-os-directory", 0},
+   {"--print-prog-name", "-print-prog-name=", "aj"},
+   {"--profile", "-p", 0},
+   {"--profile-blocks", "-a", 0},
+   {"--quiet", "-q", 0},
+   {"--resource", "-fcompile-resource=", "aj"},
+   {"--save-temps", "-save-temps", 0},
+   {"--shared", "-shared", 0},
+   {"--silent", "-q", 0},
+   {"--specs", "-specs=", "aj"},
+   {"--static", "-static", 0},
+   {"--std", "-std=", "aj"},
+   {"--symbolic", "-symbolic", 0},
+   {"--sysroot", "--sysroot=", "aj"},
+   {"--time", "-time", 0},
+   {"--trace-includes", "-H", 0},
+   {"--traditional", "-traditional", 0},
+   {"--traditional-cpp", "-traditional-cpp", 0},
+   {"--trigraphs", "-trigraphs", 0},
+   {"--undefine-macro", "-U", "aj"},
+   {"--user-dependencies", "-MM", 0},
+   {"--verbose", "-v", 0},
+   {"--warn-", "-W", "*j"},
+   {"--write-dependencies", "-MD", 0},
+   {"--write-user-dependencies", "-MMD", 0},
+   {"--", "-f", "*j"}
+ };
+
+
+#ifdef TARGET_OPTION_TRANSLATE_TABLE
+static const struct {
+  const char *const option_found;
+  const char *const replacements;
+} target_option_translations[] =
+{
+  TARGET_OPTION_TRANSLATE_TABLE,
+  { 0, 0 }
+};
+#endif
+
+/* Translate the options described by *ARGCP and *ARGVP.
+   Make a new vector and store it back in *ARGVP,
+   and store its length in *ARGVC.  */
+
+static void
+translate_options (int *argcp, const char *const **argvp)
+{
+  int i;
+  int argc = *argcp;
+  const char *const *argv = *argvp;
+  int newvsize = (argc + 2) * 2 * sizeof (const char *);
+  const char **newv = xmalloc (newvsize);
+  int newindex = 0;
+
+  i = 0;
+  newv[newindex++] = argv[i++];
+
+  while (i < argc)
+    {
+#ifdef TARGET_OPTION_TRANSLATE_TABLE
+      int tott_idx;
+
+      for (tott_idx = 0;
+	   target_option_translations[tott_idx].option_found;
+	   tott_idx++)
+	{
+	  if (strcmp (target_option_translations[tott_idx].option_found,
+		      argv[i]) == 0)
+	    {
+	      int spaces = 1;
+	      const char *sp;
+	      char *np;
+
+	      for (sp = target_option_translations[tott_idx].replacements;
+		   *sp; sp++)
+		{
+		  if (*sp == ' ')
+		    spaces ++;
+		}
+
+	      newvsize += spaces * sizeof (const char *);
+	      newv =  xrealloc (newv, newvsize);
+
+	      sp = target_option_translations[tott_idx].replacements;
+	      np = xstrdup (sp);
+
+	      while (1)
+		{
+		  while (*np == ' ')
+		    np++;
+		  if (*np == 0)
+		    break;
+		  newv[newindex++] = np;
+		  while (*np != ' ' && *np)
+		    np++;
+		  if (*np == 0)
+		    break;
+		  *np++ = 0;
+		}
+
+	      i ++;
+	      break;
+	    }
+	}
+      if (target_option_translations[tott_idx].option_found)
+	continue;
+#endif
+
+      /* Translate -- options.  */
+      if (argv[i][0] == '-' && argv[i][1] == '-')
+	{
+	  size_t j;
+	  /* Find a mapping that applies to this option.  */
+	  for (j = 0; j < ARRAY_SIZE (option_map); j++)
+	    {
+	      size_t optlen = strlen (option_map[j].name);
+	      size_t arglen = strlen (argv[i]);
+	      size_t complen = arglen > optlen ? optlen : arglen;
+	      const char *arginfo = option_map[j].arg_info;
+
+	      if (arginfo == 0)
+		arginfo = "";
+
+	      if (!strncmp (argv[i], option_map[j].name, complen))
+		{
+		  const char *arg = 0;
+
+		  if (arglen < optlen)
+		    {
+		      size_t k;
+		      for (k = j + 1; k < ARRAY_SIZE (option_map); k++)
+			if (strlen (option_map[k].name) >= arglen
+			    && !strncmp (argv[i], option_map[k].name, arglen))
+			  {
+			    error ("ambiguous abbreviation %s", argv[i]);
+			    break;
+			  }
+
+		      if (k != ARRAY_SIZE (option_map))
+			break;
+		    }
+
+		  if (arglen > optlen)
+		    {
+		      /* If the option has an argument, accept that.  */
+		      if (argv[i][optlen] == '=')
+			arg = argv[i] + optlen + 1;
+
+		      /* If this mapping requires extra text at end of name,
+			 accept that as "argument".  */
+		      else if (strchr (arginfo, '*') != 0)
+			arg = argv[i] + optlen;
+
+		      /* Otherwise, extra text at end means mismatch.
+			 Try other mappings.  */
+		      else
+			continue;
+		    }
+
+		  else if (strchr (arginfo, '*') != 0)
+		    {
+		      error ("incomplete '%s' option", option_map[j].name);
+		      break;
+		    }
+
+		  /* Handle arguments.  */
+		  if (strchr (arginfo, 'a') != 0)
+		    {
+		      if (arg == 0)
+			{
+			  if (i + 1 == argc)
+			    {
+			      error ("missing argument to '%s' option",
+				     option_map[j].name);
+			      break;
+			    }
+
+			  arg = argv[++i];
+			}
+		    }
+		  else if (strchr (arginfo, '*') != 0)
+		    ;
+		  else if (strchr (arginfo, 'o') == 0)
+		    {
+		      if (arg != 0)
+			error ("extraneous argument to '%s' option",
+			       option_map[j].name);
+		      arg = 0;
+		    }
+
+		  /* Store the translation as one argv elt or as two.  */
+		  if (arg != 0 && strchr (arginfo, 'j') != 0)
+		    newv[newindex++] = concat (option_map[j].equivalent, arg,
+					       NULL);
+		  else if (arg != 0)
+		    {
+		      newv[newindex++] = option_map[j].equivalent;
+		      newv[newindex++] = arg;
+		    }
+		  else
+		    newv[newindex++] = option_map[j].equivalent;
+
+		  break;
+		}
+	    }
+	  i++;
+	}
+
+      /* Handle old-fashioned options--just copy them through,
+	 with their arguments.  */
+      else if (argv[i][0] == '-')
+	{
+	  const char *p = argv[i] + 1;
+	  int c = *p;
+	  int nskip = 1;
+
+	  if (SWITCH_TAKES_ARG (c) > (p[1] != 0))
+	    nskip += SWITCH_TAKES_ARG (c) - (p[1] != 0);
+	  else if (WORD_SWITCH_TAKES_ARG (p))
+	    nskip += WORD_SWITCH_TAKES_ARG (p);
+	  else if ((c == 'B' || c == 'b' || c == 'x')
+		   && p[1] == 0)
+	    nskip += 1;
+	  else if (! strcmp (p, "Xlinker"))
+	    nskip += 1;
+	  else if (! strcmp (p, "Xpreprocessor"))
+	    nskip += 1;
+	  else if (! strcmp (p, "Xassembler"))
+	    nskip += 1;
+
+	  /* Watch out for an option at the end of the command line that
+	     is missing arguments, and avoid skipping past the end of the
+	     command line.  */
+	  if (nskip + i > argc)
+	    nskip = argc - i;
+
+	  while (nskip > 0)
+	    {
+	      newv[newindex++] = argv[i++];
+	      nskip--;
+	    }
+	}
+      else
+	/* Ordinary operands, or +e options.  */
+	newv[newindex++] = argv[i++];
+    }
+
+  newv[newindex] = 0;
+
+  *argvp = newv;
+  *argcp = newindex;
+}
+
+static char *
+skip_whitespace (char *p)
+{
+  while (1)
+    {
+      /* A fully-blank line is a delimiter in the SPEC file and shouldn't
+	 be considered whitespace.  */
+      if (p[0] == '\n' && p[1] == '\n' && p[2] == '\n')
+	return p + 1;
+      else if (*p == '\n' || *p == ' ' || *p == '\t')
+	p++;
+      else if (*p == '#')
+	{
+	  while (*p != '\n')
+	    p++;
+	  p++;
+	}
+      else
+	break;
+    }
+
+  return p;
+}
+/* Structures to keep track of prefixes to try when looking for files.  */
+
+struct prefix_list
+{
+  const char *prefix;	      /* String to prepend to the path.  */
+  struct prefix_list *next;   /* Next in linked list.  */
+  int require_machine_suffix; /* Don't use without machine_suffix.  */
+  /* 2 means try both machine_suffix and just_machine_suffix.  */
+  int priority;		      /* Sort key - priority within list.  */
+  int os_multilib;	      /* 1 if OS multilib scheme should be used,
+				 0 for GCC multilib scheme.  */
+};
+
+struct path_prefix
+{
+  struct prefix_list *plist;  /* List of prefixes to try */
+  int max_len;                /* Max length of a prefix in PLIST */
+  const char *name;           /* Name of this list (used in config stuff) */
+};
+
+/* List of prefixes to try when looking for executables.  */
+
+static struct path_prefix exec_prefixes = { 0, 0, "exec" };
+
+/* List of prefixes to try when looking for startup (crt0) files.  */
+
+static struct path_prefix startfile_prefixes = { 0, 0, "startfile" };
+
+/* List of prefixes to try when looking for include files.  */
+
+static struct path_prefix include_prefixes = { 0, 0, "include" };
+
+/* Suffix to attach to directories searched for commands.
+   This looks like `MACHINE/VERSION/'.  */
+
+static const char *machine_suffix = 0;
+
+/* Suffix to attach to directories searched for commands.
+   This is just `MACHINE/'.  */
+
+static const char *just_machine_suffix = 0;
+
+/* Adjusted value of GCC_EXEC_PREFIX envvar.  */
+
+static const char *gcc_exec_prefix;
+
+/* Adjusted value of standard_libexec_prefix.  */
+
+static const char *gcc_libexec_prefix;
+
+/* Default prefixes to attach to command names.  */
+
+#ifndef STANDARD_STARTFILE_PREFIX_1
+#define STANDARD_STARTFILE_PREFIX_1 "/lib/"
+#endif
+#ifndef STANDARD_STARTFILE_PREFIX_2
+#define STANDARD_STARTFILE_PREFIX_2 "/usr/lib/"
+#endif
+
+#ifdef CROSS_COMPILE  /* Don't use these prefixes for a cross compiler.  */
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
+#undef MD_STARTFILE_PREFIX_1
+#endif
+
+/* If no prefixes defined, use the null string, which will disable them.  */
+#ifndef MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX ""
+#endif
+#ifndef MD_STARTFILE_PREFIX
+#define MD_STARTFILE_PREFIX ""
+#endif
+#ifndef MD_STARTFILE_PREFIX_1
+#define MD_STARTFILE_PREFIX_1 ""
+#endif
+
+static const char *const standard_exec_prefix = STANDARD_EXEC_PREFIX;
+static const char *const standard_exec_prefix_1 = "/usr/libexec/gcc/";
+static const char *const standard_exec_prefix_2 = "/usr/lib/gcc/";
+static const char *md_exec_prefix = MD_EXEC_PREFIX;
+
+static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
+static const char *md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;
+static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
+static const char *const standard_startfile_prefix_1
+  = STANDARD_STARTFILE_PREFIX_1;
+static const char *const standard_startfile_prefix_2
+  = STANDARD_STARTFILE_PREFIX_2;
+
+static const char *const tooldir_base_prefix = TOOLDIR_BASE_PREFIX;
+static const char *tooldir_prefix;
+
+static const char *const standard_bindir_prefix = STANDARD_BINDIR_PREFIX;
+
+static const char *standard_libexec_prefix = STANDARD_LIBEXEC_PREFIX;
+
+/* Subdirectory to use for locating libraries.  Set by
+   set_multilib_dir based on the compilation options.  */
+
+static const char *multilib_dir;
+
+/* Subdirectory to use for locating libraries in OS conventions.  Set by
+   set_multilib_dir based on the compilation options.  */
+
+static const char *multilib_os_dir;
+
+/* Structure to keep track of the specs that have been defined so far.
+   These are accessed using %(specname) or %[specname] in a compiler
+   or link spec.  */
+
+struct spec_list
+{
+				/* The following 2 fields must be first */
+				/* to allow EXTRA_SPECS to be initialized */
+  const char *name;		/* name of the spec.  */
+  const char *ptr;		/* available ptr if no static pointer */
+
+				/* The following fields are not initialized */
+				/* by EXTRA_SPECS */
+  const char **ptr_spec;	/* pointer to the spec itself.  */
+  struct spec_list *next;	/* Next spec in linked list.  */
+  int name_len;			/* length of the name */
+  int alloc_p;			/* whether string was allocated */
+};
+
+#define INIT_STATIC_SPEC(NAME,PTR) \
+{ NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }
+
+/* List of statically defined specs.  */
+static struct spec_list static_specs[] =
+{
+  INIT_STATIC_SPEC ("asm",			&asm_spec),
+  INIT_STATIC_SPEC ("asm_debug",		&asm_debug),
+  INIT_STATIC_SPEC ("asm_final",		&asm_final_spec),
+  INIT_STATIC_SPEC ("asm_options",		&asm_options),
+  INIT_STATIC_SPEC ("invoke_as",		&invoke_as),
+  INIT_STATIC_SPEC ("cpp",			&cpp_spec),
+  INIT_STATIC_SPEC ("cpp_options",		&cpp_options),
+  INIT_STATIC_SPEC ("cpp_debug_options",	&cpp_debug_options),
+  INIT_STATIC_SPEC ("cpp_unique_options",	&cpp_unique_options),
+  INIT_STATIC_SPEC ("trad_capable_cpp",		&trad_capable_cpp),
+  INIT_STATIC_SPEC ("cc1",			&cc1_spec),
+  INIT_STATIC_SPEC ("cc1_options",		&cc1_options),
+  INIT_STATIC_SPEC ("cc1plus",			&cc1plus_spec),
+  INIT_STATIC_SPEC ("link_gcc_c_sequence",	&link_gcc_c_sequence_spec),
+  INIT_STATIC_SPEC ("link_ssp",			&link_ssp_spec),
+  INIT_STATIC_SPEC ("endfile",			&endfile_spec),
+  INIT_STATIC_SPEC ("link",			&link_spec),
+  INIT_STATIC_SPEC ("lib",			&lib_spec),
+  INIT_STATIC_SPEC ("mfwrap",			&mfwrap_spec),
+  INIT_STATIC_SPEC ("mflib",			&mflib_spec),
+  INIT_STATIC_SPEC ("libgcc",			&libgcc_spec),
+  INIT_STATIC_SPEC ("startfile",		&startfile_spec),
+  INIT_STATIC_SPEC ("switches_need_spaces",	&switches_need_spaces),
+  INIT_STATIC_SPEC ("cross_compile",		&cross_compile),
+  INIT_STATIC_SPEC ("version",			&compiler_version),
+  INIT_STATIC_SPEC ("multilib",			&multilib_select),
+  INIT_STATIC_SPEC ("multilib_defaults",	&multilib_defaults),
+  INIT_STATIC_SPEC ("multilib_extra",		&multilib_extra),
+  INIT_STATIC_SPEC ("multilib_matches",		&multilib_matches),
+  INIT_STATIC_SPEC ("multilib_exclusions",	&multilib_exclusions),
+  INIT_STATIC_SPEC ("multilib_options",		&multilib_options),
+  INIT_STATIC_SPEC ("linker",			&linker_name_spec),
+  INIT_STATIC_SPEC ("link_libgcc",		&link_libgcc_spec),
+  INIT_STATIC_SPEC ("md_exec_prefix",		&md_exec_prefix),
+  INIT_STATIC_SPEC ("md_startfile_prefix",	&md_startfile_prefix),
+  INIT_STATIC_SPEC ("md_startfile_prefix_1",	&md_startfile_prefix_1),
+  INIT_STATIC_SPEC ("startfile_prefix_spec",	&startfile_prefix_spec),
+  INIT_STATIC_SPEC ("sysroot_spec",             &sysroot_spec),
+  INIT_STATIC_SPEC ("sysroot_suffix_spec",	&sysroot_suffix_spec),
+  INIT_STATIC_SPEC ("sysroot_hdrs_suffix_spec",	&sysroot_hdrs_suffix_spec),
+};
+
+#ifdef EXTRA_SPECS		/* additional specs needed */
+/* Structure to keep track of just the first two args of a spec_list.
+   That is all that the EXTRA_SPECS macro gives us.  */
+struct spec_list_1
+{
+  const char *const name;
+  const char *const ptr;
+};
+
+static const struct spec_list_1 extra_specs_1[] = { EXTRA_SPECS };
+static struct spec_list *extra_specs = (struct spec_list *) 0;
+#endif
+
+/* List of dynamically allocates specs that have been defined so far.  */
+
+static struct spec_list *specs = (struct spec_list *) 0;
+
+/* List of static spec functions.  */
+
+static const struct spec_function static_spec_functions[] =
+{
+  { "if-exists",		if_exists_spec_function },
+  { "if-exists-else",		if_exists_else_spec_function },
+  { "replace-outfile",		replace_outfile_spec_function },
+  { "version-compare",		version_compare_spec_function },
+  { 0, 0 }
+};
+
+static int processing_spec_function;
+
+/* Add appropriate libgcc specs to OBSTACK, taking into account
+   various permutations of -shared-libgcc, -shared, and such.  */
+
+#if defined(ENABLE_SHARED_LIBGCC) && !defined(REAL_LIBGCC_SPEC)
+
+#ifndef USE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 0
+#endif
+
+static void
+init_gcc_specs (struct obstack *obstack, const char *shared_name,
+		const char *static_name, const char *eh_name)
+{
+  char *buf;
+
+  buf = concat ("%{static|static-libgcc:", static_name, " ", eh_name,
+		"}%{!static:%{!static-libgcc:",
+#if USE_LD_AS_NEEDED
+		"%{!shared-libgcc:", static_name,
+		" --as-needed ", shared_name, " --no-as-needed}"
+		"%{shared-libgcc:", shared_name, "%{!shared: ", static_name,
+		"}",
+#else
+		"%{!shared:%{!shared-libgcc:", static_name, " ",
+		eh_name, "}%{shared-libgcc:", shared_name, " ",
+		static_name, "}}%{shared:",
+#ifdef LINK_EH_SPEC
+		"%{shared-libgcc:", shared_name,
+		"}%{!shared-libgcc:", static_name, "}",
+#else
+		shared_name,
+#endif
+#endif
+		"}}}", NULL);
+
+  obstack_grow (obstack, buf, strlen (buf));
+  free (buf);
+}
+#endif /* ENABLE_SHARED_LIBGCC */
+
+/* Initialize the specs lookup routines.  */
+
+static void
+init_spec (void)
+{
+  struct spec_list *next = (struct spec_list *) 0;
+  struct spec_list *sl   = (struct spec_list *) 0;
+  int i;
+
+  if (specs)
+    return;			/* Already initialized.  */
+
+  if (verbose_flag)
+    notice ("Using built-in specs.\n");
+
+#ifdef EXTRA_SPECS
+  extra_specs = xcalloc (sizeof (struct spec_list),
+			 ARRAY_SIZE (extra_specs_1));
+
+  for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)
+    {
+      sl = &extra_specs[i];
+      sl->name = extra_specs_1[i].name;
+      sl->ptr = extra_specs_1[i].ptr;
+      sl->next = next;
+      sl->name_len = strlen (sl->name);
+      sl->ptr_spec = &sl->ptr;
+      next = sl;
+    }
+#endif
+
+  /* Initialize here, not in definition.  The IRIX 6 O32 cc sometimes chokes
+     on ?: in file-scope variable initializations.  */
+  asm_debug = ASM_DEBUG_SPEC;
+
+  for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
+    {
+      sl = &static_specs[i];
+      sl->next = next;
+      next = sl;
+    }
+
+#if defined(ENABLE_SHARED_LIBGCC) && !defined(REAL_LIBGCC_SPEC)
+  /* ??? If neither -shared-libgcc nor --static-libgcc was
+     seen, then we should be making an educated guess.  Some proposed
+     heuristics for ELF include:
+
+	(1) If "-Wl,--export-dynamic", then it's a fair bet that the
+	    program will be doing dynamic loading, which will likely
+	    need the shared libgcc.
+
+	(2) If "-ldl", then it's also a fair bet that we're doing
+	    dynamic loading.
+
+	(3) For each ET_DYN we're linking against (either through -lfoo
+	    or /some/path/foo.so), check to see whether it or one of
+	    its dependencies depends on a shared libgcc.
+
+	(4) If "-shared"
+
+	    If the runtime is fixed to look for program headers instead
+	    of calling __register_frame_info at all, for each object,
+	    use the shared libgcc if any EH symbol referenced.
+
+	    If crtstuff is fixed to not invoke __register_frame_info
+	    automatically, for each object, use the shared libgcc if
+	    any non-empty unwind section found.
+
+     Doing any of this probably requires invoking an external program to
+     do the actual object file scanning.  */
+  {
+    const char *p = libgcc_spec;
+    int in_sep = 1;
+
+    /* Transform the extant libgcc_spec into one that uses the shared libgcc
+       when given the proper command line arguments.  */
+    while (*p)
+      {
+	if (in_sep && *p == '-' && strncmp (p, "-lgcc", 5) == 0)
+	  {
+	    init_gcc_specs (&obstack,
+			    "-lgcc_s"
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+			    " -lunwind"
+#endif
+			    ,
+			    "-lgcc",
+			    "-lgcc_eh"
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+# ifdef HAVE_LD_STATIC_DYNAMIC
+			    " %{!static:-Bstatic} -lunwind %{!static:-Bdynamic}"
+# else
+			    " -lunwind"
+# endif
+#endif
+			    );
+
+	    p += 5;
+	    in_sep = 0;
+	  }
+	else if (in_sep && *p == 'l' && strncmp (p, "libgcc.a%s", 10) == 0)
+	  {
+	    /* Ug.  We don't know shared library extensions.  Hope that
+	       systems that use this form don't do shared libraries.  */
+	    init_gcc_specs (&obstack,
+			    "-lgcc_s",
+			    "libgcc.a%s",
+			    "libgcc_eh.a%s"
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+			    " -lunwind"
+#endif
+			    );
+	    p += 10;
+	    in_sep = 0;
+	  }
+	else
+	  {
+	    obstack_1grow (&obstack, *p);
+	    in_sep = (*p == ' ');
+	    p += 1;
+	  }
+      }
+
+    obstack_1grow (&obstack, '\0');
+    libgcc_spec = XOBFINISH (&obstack, const char *);
+  }
+#endif
+#ifdef USE_AS_TRADITIONAL_FORMAT
+  /* Prepend "--traditional-format" to whatever asm_spec we had before.  */
+  {
+    static const char tf[] = "--traditional-format ";
+    obstack_grow (&obstack, tf, sizeof(tf) - 1);
+    obstack_grow0 (&obstack, asm_spec, strlen (asm_spec));
+    asm_spec = XOBFINISH (&obstack, const char *);
+  }
+#endif
+#ifdef LINK_EH_SPEC
+  /* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */
+  obstack_grow (&obstack, LINK_EH_SPEC, sizeof(LINK_EH_SPEC) - 1);
+  obstack_grow0 (&obstack, link_spec, strlen (link_spec));
+  link_spec = XOBFINISH (&obstack, const char *);
+#endif
+
+  specs = sl;
+}
+
+/* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is
+   removed; If the spec starts with a + then SPEC is added to the end of the
+   current spec.  */
+
+static void
+set_spec (const char *name, const char *spec)
+{
+  struct spec_list *sl;
+  const char *old_spec;
+  int name_len = strlen (name);
+  int i;
+
+  /* If this is the first call, initialize the statically allocated specs.  */
+  if (!specs)
+    {
+      struct spec_list *next = (struct spec_list *) 0;
+      for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
+	{
+	  sl = &static_specs[i];
+	  sl->next = next;
+	  next = sl;
+	}
+      specs = sl;
+    }
+
+  /* See if the spec already exists.  */
+  for (sl = specs; sl; sl = sl->next)
+    if (name_len == sl->name_len && !strcmp (sl->name, name))
+      break;
+
+  if (!sl)
+    {
+      /* Not found - make it.  */
+      sl = xmalloc (sizeof (struct spec_list));
+      sl->name = xstrdup (name);
+      sl->name_len = name_len;
+      sl->ptr_spec = &sl->ptr;
+      sl->alloc_p = 0;
+      *(sl->ptr_spec) = "";
+      sl->next = specs;
+      specs = sl;
+    }
+
+  old_spec = *(sl->ptr_spec);
+  *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))
+		     ? concat (old_spec, spec + 1, NULL)
+		     : xstrdup (spec));
+
+#ifdef DEBUG_SPECS
+  if (verbose_flag)
+    notice ("Setting spec %s to '%s'\n\n", name, *(sl->ptr_spec));
+#endif
+
+  /* Free the old spec.  */
+  if (old_spec && sl->alloc_p)
+    free ((void *) old_spec);
+
+  sl->alloc_p = 1;
+}
+
+/* Accumulate a command (program name and args), and run it.  */
+
+/* Vector of pointers to arguments in the current line of specifications.  */
+
+static const char **argbuf;
+
+/* Number of elements allocated in argbuf.  */
+
+static int argbuf_length;
+
+/* Number of elements in argbuf currently in use (containing args).  */
+
+static int argbuf_index;
+
+/* Position in the argbuf array containing the name of the output file
+   (the value associated with the "-o" flag).  */
+
+static int have_o_argbuf_index = 0;
+
+/* Were the options -c or -S passed.  */
+static int have_c = 0;
+
+/* Was the option -o passed.  */
+static int have_o = 0;
+
+/* This is the list of suffixes and codes (%g/%u/%U/%j) and the associated
+   temp file.  If the HOST_BIT_BUCKET is used for %j, no entry is made for
+   it here.  */
+
+static struct temp_name {
+  const char *suffix;	/* suffix associated with the code.  */
+  int length;		/* strlen (suffix).  */
+  int unique;		/* Indicates whether %g or %u/%U was used.  */
+  const char *filename;	/* associated filename.  */
+  int filename_length;	/* strlen (filename).  */
+  struct temp_name *next;
+} *temp_names;
+
+/* Number of commands executed so far.  */
+
+static int execution_count;
+
+/* Number of commands that exited with a signal.  */
+
+static int signal_count;
+
+/* Name with which this program was invoked.  */
+
+static const char *programname;
+
+/* Allocate the argument vector.  */
+
+static void
+alloc_args (void)
+{
+  argbuf_length = 10;
+  argbuf = xmalloc (argbuf_length * sizeof (const char *));
+}
+
+/* Clear out the vector of arguments (after a command is executed).  */
+
+static void
+clear_args (void)
+{
+  argbuf_index = 0;
+}
+
+/* Add one argument to the vector at the end.
+   This is done when a space is seen or at the end of the line.
+   If DELETE_ALWAYS is nonzero, the arg is a filename
+    and the file should be deleted eventually.
+   If DELETE_FAILURE is nonzero, the arg is a filename
+    and the file should be deleted if this compilation fails.  */
+
+static void
+store_arg (const char *arg, int delete_always, int delete_failure)
+{
+  if (argbuf_index + 1 == argbuf_length)
+    argbuf = xrealloc (argbuf, (argbuf_length *= 2) * sizeof (const char *));
+
+  argbuf[argbuf_index++] = arg;
+  argbuf[argbuf_index] = 0;
+
+  if (strcmp (arg, "-o") == 0)
+    have_o_argbuf_index = argbuf_index;
+  if (delete_always || delete_failure)
+    record_temp_file (arg, delete_always, delete_failure);
+}
+
+/* Load specs from a file name named FILENAME, replacing occurrences of
+   various different types of line-endings, \r\n, \n\r and just \r, with
+   a single \n.  */
+
+static char *
+load_specs (const char *filename)
+{
+  int desc;
+  int readlen;
+  struct stat statbuf;
+  char *buffer;
+  char *buffer_p;
+  char *specs;
+  char *specs_p;
+
+  if (verbose_flag)
+    notice ("Reading specs from %s\n", filename);
+
+  /* Open and stat the file.  */
+  desc = open (filename, O_RDONLY, 0);
+  if (desc < 0)
+    pfatal_with_name (filename);
+  if (stat (filename, &statbuf) < 0)
+    pfatal_with_name (filename);
+
+  /* Read contents of file into BUFFER.  */
+  buffer = xmalloc ((unsigned) statbuf.st_size + 1);
+  readlen = read (desc, buffer, (unsigned) statbuf.st_size);
+  if (readlen < 0)
+    pfatal_with_name (filename);
+  buffer[readlen] = 0;
+  close (desc);
+
+  specs = xmalloc (readlen + 1);
+  specs_p = specs;
+  for (buffer_p = buffer; buffer_p && *buffer_p; buffer_p++)
+    {
+      int skip = 0;
+      char c = *buffer_p;
+      if (c == '\r')
+	{
+	  if (buffer_p > buffer && *(buffer_p - 1) == '\n')	/* \n\r */
+	    skip = 1;
+	  else if (*(buffer_p + 1) == '\n')			/* \r\n */
+	    skip = 1;
+	  else							/* \r */
+	    c = '\n';
+	}
+      if (! skip)
+	*specs_p++ = c;
+    }
+  *specs_p = '\0';
+
+  free (buffer);
+  return (specs);
+}
+
+/* Read compilation specs from a file named FILENAME,
+   replacing the default ones.
+
+   A suffix which starts with `*' is a definition for
+   one of the machine-specific sub-specs.  The "suffix" should be
+   *asm, *cc1, *cpp, *link, *startfile, etc.
+   The corresponding spec is stored in asm_spec, etc.,
+   rather than in the `compilers' vector.
+
+   Anything invalid in the file is a fatal error.  */
+
+static void
+read_specs (const char *filename, int main_p)
+{
+  char *buffer;
+  char *p;
+
+  buffer = load_specs (filename);
+
+  /* Scan BUFFER for specs, putting them in the vector.  */
+  p = buffer;
+  while (1)
+    {
+      char *suffix;
+      char *spec;
+      char *in, *out, *p1, *p2, *p3;
+
+      /* Advance P in BUFFER to the next nonblank nocomment line.  */
+      p = skip_whitespace (p);
+      if (*p == 0)
+	break;
+
+      /* Is this a special command that starts with '%'? */
+      /* Don't allow this for the main specs file, since it would
+	 encourage people to overwrite it.  */
+      if (*p == '%' && !main_p)
+	{
+	  p1 = p;
+	  while (*p && *p != '\n')
+	    p++;
+
+	  /* Skip '\n'.  */
+	  p++;
+
+	  if (!strncmp (p1, "%include", sizeof ("%include") - 1)
+	      && (p1[sizeof "%include" - 1] == ' '
+		  || p1[sizeof "%include" - 1] == '\t'))
+	    {
+	      char *new_filename;
+
+	      p1 += sizeof ("%include");
+	      while (*p1 == ' ' || *p1 == '\t')
+		p1++;
+
+	      if (*p1++ != '<' || p[-2] != '>')
+		fatal ("specs %%include syntax malformed after %ld characters",
+		       (long) (p1 - buffer + 1));
+
+	      p[-2] = '\0';
+	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);
+	      read_specs (new_filename ? new_filename : p1, FALSE);
+	      continue;
+	    }
+	  else if (!strncmp (p1, "%include_noerr", sizeof "%include_noerr" - 1)
+		   && (p1[sizeof "%include_noerr" - 1] == ' '
+		       || p1[sizeof "%include_noerr" - 1] == '\t'))
+	    {
+	      char *new_filename;
+
+	      p1 += sizeof "%include_noerr";
+	      while (*p1 == ' ' || *p1 == '\t')
+		p1++;
+
+	      if (*p1++ != '<' || p[-2] != '>')
+		fatal ("specs %%include syntax malformed after %ld characters",
+		       (long) (p1 - buffer + 1));
+
+	      p[-2] = '\0';
+	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);
+	      if (new_filename)
+		read_specs (new_filename, FALSE);
+	      else if (verbose_flag)
+		notice ("could not find specs file %s\n", p1);
+	      continue;
+	    }
+	  else if (!strncmp (p1, "%rename", sizeof "%rename" - 1)
+		   && (p1[sizeof "%rename" - 1] == ' '
+		       || p1[sizeof "%rename" - 1] == '\t'))
+	    {
+	      int name_len;
+	      struct spec_list *sl;
+	      struct spec_list *newsl;
+
+	      /* Get original name.  */
+	      p1 += sizeof "%rename";
+	      while (*p1 == ' ' || *p1 == '\t')
+		p1++;
+
+	      if (! ISALPHA ((unsigned char) *p1))
+		fatal ("specs %%rename syntax malformed after %ld characters",
+		       (long) (p1 - buffer));
+
+	      p2 = p1;
+	      while (*p2 && !ISSPACE ((unsigned char) *p2))
+		p2++;
+
+	      if (*p2 != ' ' && *p2 != '\t')
+		fatal ("specs %%rename syntax malformed after %ld characters",
+		       (long) (p2 - buffer));
+
+	      name_len = p2 - p1;
+	      *p2++ = '\0';
+	      while (*p2 == ' ' || *p2 == '\t')
+		p2++;
+
+	      if (! ISALPHA ((unsigned char) *p2))
+		fatal ("specs %%rename syntax malformed after %ld characters",
+		       (long) (p2 - buffer));
+
+	      /* Get new spec name.  */
+	      p3 = p2;
+	      while (*p3 && !ISSPACE ((unsigned char) *p3))
+		p3++;
+
+	      if (p3 != p - 1)
+		fatal ("specs %%rename syntax malformed after %ld characters",
+		       (long) (p3 - buffer));
+	      *p3 = '\0';
+
+	      for (sl = specs; sl; sl = sl->next)
+		if (name_len == sl->name_len && !strcmp (sl->name, p1))
+		  break;
+
+	      if (!sl)
+		fatal ("specs %s spec was not found to be renamed", p1);
+
+	      if (strcmp (p1, p2) == 0)
+		continue;
+
+	      for (newsl = specs; newsl; newsl = newsl->next)
+		if (strcmp (newsl->name, p2) == 0)
+		  fatal ("%s: attempt to rename spec '%s' to already defined spec '%s'",
+		    filename, p1, p2);
+
+	      if (verbose_flag)
+		{
+		  notice ("rename spec %s to %s\n", p1, p2);
+#ifdef DEBUG_SPECS
+		  notice ("spec is '%s'\n\n", *(sl->ptr_spec));
+#endif
+		}
+
+	      set_spec (p2, *(sl->ptr_spec));
+	      if (sl->alloc_p)
+		free ((void *) *(sl->ptr_spec));
+
+	      *(sl->ptr_spec) = "";
+	      sl->alloc_p = 0;
+	      continue;
+	    }
+	  else
+	    fatal ("specs unknown %% command after %ld characters",
+		   (long) (p1 - buffer));
+	}
+
+      /* Find the colon that should end the suffix.  */
+      p1 = p;
+      while (*p1 && *p1 != ':' && *p1 != '\n')
+	p1++;
+
+      /* The colon shouldn't be missing.  */
+      if (*p1 != ':')
+	fatal ("specs file malformed after %ld characters",
+	       (long) (p1 - buffer));
+
+      /* Skip back over trailing whitespace.  */
+      p2 = p1;
+      while (p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\t'))
+	p2--;
+
+      /* Copy the suffix to a string.  */
+      suffix = save_string (p, p2 - p);
+      /* Find the next line.  */
+      p = skip_whitespace (p1 + 1);
+      if (p[1] == 0)
+	fatal ("specs file malformed after %ld characters",
+	       (long) (p - buffer));
+
+      p1 = p;
+      /* Find next blank line or end of string.  */
+      while (*p1 && !(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0')))
+	p1++;
+
+      /* Specs end at the blank line and do not include the newline.  */
+      spec = save_string (p, p1 - p);
+      p = p1;
+
+      /* Delete backslash-newline sequences from the spec.  */
+      in = spec;
+      out = spec;
+      while (*in != 0)
+	{
+	  if (in[0] == '\\' && in[1] == '\n')
+	    in += 2;
+	  else if (in[0] == '#')
+	    while (*in && *in != '\n')
+	      in++;
+
+	  else
+	    *out++ = *in++;
+	}
+      *out = 0;
+
+      if (suffix[0] == '*')
+	{
+	  if (! strcmp (suffix, "*link_command"))
+	    link_command_spec = spec;
+	  else
+	    set_spec (suffix + 1, spec);
+	}
+      else
+	{
+	  /* Add this pair to the vector.  */
+	  compilers
+	    = xrealloc (compilers,
+			(n_compilers + 2) * sizeof (struct compiler));
+
+	  compilers[n_compilers].suffix = suffix;
+	  compilers[n_compilers].spec = spec;
+	  n_compilers++;
+	  memset (&compilers[n_compilers], 0, sizeof compilers[n_compilers]);
+	}
+
+      if (*suffix == 0)
+	link_command_spec = spec;
+    }
+
+  if (link_command_spec == 0)
+    fatal ("spec file has no spec for linking");
+}
+
+/* Record the names of temporary files we tell compilers to write,
+   and delete them at the end of the run.  */
+
+/* This is the common prefix we use to make temp file names.
+   It is chosen once for each run of this program.
+   It is substituted into a spec by %g or %j.
+   Thus, all temp file names contain this prefix.
+   In practice, all temp file names start with this prefix.
+
+   This prefix comes from the envvar TMPDIR if it is defined;
+   otherwise, from the P_tmpdir macro if that is defined;
+   otherwise, in /usr/tmp or /tmp;
+   or finally the current directory if all else fails.  */
+
+static const char *temp_filename;
+
+/* Length of the prefix.  */
+
+static int temp_filename_length;
+
+/* Define the list of temporary files to delete.  */
+
+struct temp_file
+{
+  const char *name;
+  struct temp_file *next;
+};
+
+/* Queue of files to delete on success or failure of compilation.  */
+static struct temp_file *always_delete_queue;
+/* Queue of files to delete on failure of compilation.  */
+static struct temp_file *failure_delete_queue;
+
+/* Record FILENAME as a file to be deleted automatically.
+   ALWAYS_DELETE nonzero means delete it if all compilation succeeds;
+   otherwise delete it in any case.
+   FAIL_DELETE nonzero means delete it if a compilation step fails;
+   otherwise delete it in any case.  */
+
+void
+record_temp_file (const char *filename, int always_delete, int fail_delete)
+{
+  char *const name = xstrdup (filename);
+
+  if (always_delete)
+    {
+      struct temp_file *temp;
+      for (temp = always_delete_queue; temp; temp = temp->next)
+	if (! strcmp (name, temp->name))
+	  goto already1;
+
+      temp = xmalloc (sizeof (struct temp_file));
+      temp->next = always_delete_queue;
+      temp->name = name;
+      always_delete_queue = temp;
+
+    already1:;
+    }
+
+  if (fail_delete)
+    {
+      struct temp_file *temp;
+      for (temp = failure_delete_queue; temp; temp = temp->next)
+	if (! strcmp (name, temp->name))
+	  goto already2;
+
+      temp = xmalloc (sizeof (struct temp_file));
+      temp->next = failure_delete_queue;
+      temp->name = name;
+      failure_delete_queue = temp;
+
+    already2:;
+    }
+}
+
+/* Delete all the temporary files whose names we previously recorded.  */
+
+#ifndef DELETE_IF_ORDINARY
+#define DELETE_IF_ORDINARY(NAME,ST,VERBOSE_FLAG)        \
+do                                                      \
+  {                                                     \
+    if (stat (NAME, &ST) >= 0 && S_ISREG (ST.st_mode))  \
+      if (unlink (NAME) < 0)                            \
+	if (VERBOSE_FLAG)                               \
+	  perror_with_name (NAME);                      \
+  } while (0)
+#endif
+
+static void
+delete_if_ordinary (const char *name)
+{
+  struct stat st;
+#ifdef DEBUG
+  int i, c;
+
+  printf ("Delete %s? (y or n) ", name);
+  fflush (stdout);
+  i = getchar ();
+  if (i != '\n')
+    while ((c = getchar ()) != '\n' && c != EOF)
+      ;
+
+  if (i == 'y' || i == 'Y')
+#endif /* DEBUG */
+  DELETE_IF_ORDINARY (name, st, verbose_flag);
+}
+
+static void
+delete_temp_files (void)
+{
+  struct temp_file *temp;
+
+  for (temp = always_delete_queue; temp; temp = temp->next)
+    delete_if_ordinary (temp->name);
+  always_delete_queue = 0;
+}
+
+/* Delete all the files to be deleted on error.  */
+
+static void
+delete_failure_queue (void)
+{
+  struct temp_file *temp;
+
+  for (temp = failure_delete_queue; temp; temp = temp->next)
+    delete_if_ordinary (temp->name);
+}
+
+static void
+clear_failure_queue (void)
+{
+  failure_delete_queue = 0;
+}
+
+/* Build a list of search directories from PATHS.
+   PREFIX is a string to prepend to the list.
+   If CHECK_DIR_P is nonzero we ensure the directory exists.
+   This is used mostly by putenv_from_prefixes so we use `collect_obstack'.
+   It is also used by the --print-search-dirs flag.  */
+
+static char *
+build_search_list (struct path_prefix *paths, const char *prefix,
+		   int check_dir_p)
+{
+  int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;
+  int just_suffix_len
+    = (just_machine_suffix) ? strlen (just_machine_suffix) : 0;
+  int first_time = TRUE;
+  struct prefix_list *pprefix;
+
+  obstack_grow (&collect_obstack, prefix, strlen (prefix));
+  obstack_1grow (&collect_obstack, '=');
+
+  for (pprefix = paths->plist; pprefix != 0; pprefix = pprefix->next)
+    {
+      int len = strlen (pprefix->prefix);
+
+      if (machine_suffix
+	  && (! check_dir_p
+	      || is_directory (pprefix->prefix, machine_suffix, 0)))
+	{
+	  if (!first_time)
+	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
+
+	  first_time = FALSE;
+	  obstack_grow (&collect_obstack, pprefix->prefix, len);
+	  obstack_grow (&collect_obstack, machine_suffix, suffix_len);
+	}
+
+      if (just_machine_suffix
+	  && pprefix->require_machine_suffix == 2
+	  && (! check_dir_p
+	      || is_directory (pprefix->prefix, just_machine_suffix, 0)))
+	{
+	  if (! first_time)
+	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
+
+	  first_time = FALSE;
+	  obstack_grow (&collect_obstack, pprefix->prefix, len);
+	  obstack_grow (&collect_obstack, just_machine_suffix,
+			just_suffix_len);
+	}
+
+      if (! pprefix->require_machine_suffix)
+	{
+	  if (! first_time)
+	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
+
+	  first_time = FALSE;
+	  obstack_grow (&collect_obstack, pprefix->prefix, len);
+	}
+    }
+
+  obstack_1grow (&collect_obstack, '\0');
+  return XOBFINISH (&collect_obstack, char *);
+}
+
+/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables
+   for collect.  */
+
+static void
+putenv_from_prefixes (struct path_prefix *paths, const char *env_var)
+{
+  putenv (build_search_list (paths, env_var, 1));
+}
+
+/* Check whether NAME can be accessed in MODE.  This is like access,
+   except that it never considers directories to be executable.  */
+
+static int
+access_check (const char *name, int mode)
+{
+  if (mode == X_OK)
+    {
+      struct stat st;
+
+      if (stat (name, &st) < 0
+	  || S_ISDIR (st.st_mode))
+	return -1;
+    }
+
+  return access (name, mode);
+}
+
+/* Search for NAME using the prefix list PREFIXES.  MODE is passed to
+   access to check permissions.
+   Return 0 if not found, otherwise return its name, allocated with malloc.  */
+
+static char *
+find_a_file (struct path_prefix *pprefix, const char *name, int mode,
+	     int multilib)
+{
+  char *temp;
+  const char *const file_suffix =
+    ((mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : "");
+  struct prefix_list *pl;
+  int len = pprefix->max_len + strlen (name) + strlen (file_suffix) + 1;
+  const char *multilib_name, *multilib_os_name;
+
+#ifdef DEFAULT_ASSEMBLER
+  if (! strcmp (name, "as") && access (DEFAULT_ASSEMBLER, mode) == 0)
+    return xstrdup (DEFAULT_ASSEMBLER);
+#endif
+
+#ifdef DEFAULT_LINKER
+  if (! strcmp(name, "ld") && access (DEFAULT_LINKER, mode) == 0)
+    return xstrdup (DEFAULT_LINKER);
+#endif
+
+  if (machine_suffix)
+    len += strlen (machine_suffix);
+
+  multilib_name = name;
+  multilib_os_name = name;
+  if (multilib && multilib_os_dir)
+    {
+      int len1 = multilib_dir ? strlen (multilib_dir) + 1 : 0;
+      int len2 = strlen (multilib_os_dir) + 1;
+
+      len += len1 > len2 ? len1 : len2;
+      if (multilib_dir)
+	multilib_name = ACONCAT ((multilib_dir, dir_separator_str, name,
+				  NULL));
+      if (strcmp (multilib_os_dir, ".") != 0)
+	multilib_os_name = ACONCAT ((multilib_os_dir, dir_separator_str, name,
+				    NULL));
+    }
+
+  temp = xmalloc (len);
+
+  /* Determine the filename to execute (special case for absolute paths).  */
+
+  if (IS_ABSOLUTE_PATH (name))
+    {
+      if (access (name, mode) == 0)
+	{
+	  strcpy (temp, name);
+	  return temp;
+	}
+    }
+  else
+    for (pl = pprefix->plist; pl; pl = pl->next)
+      {
+	const char *this_name
+	  = pl->os_multilib ? multilib_os_name : multilib_name;
+
+	if (machine_suffix)
+	  {
+	    /* Some systems have a suffix for executable files.
+	       So try appending that first.  */
+	    if (file_suffix[0] != 0)
+	      {
+		strcpy (temp, pl->prefix);
+		strcat (temp, machine_suffix);
+		strcat (temp, multilib_name);
+		strcat (temp, file_suffix);
+		if (access_check (temp, mode) == 0)
+		  return temp;
+	      }
+
+	    /* Now try just the multilib_name.  */
+	    strcpy (temp, pl->prefix);
+	    strcat (temp, machine_suffix);
+	    strcat (temp, multilib_name);
+	    if (access_check (temp, mode) == 0)
+	      return temp;
+	  }
+
+	/* Certain prefixes are tried with just the machine type,
+	   not the version.  This is used for finding as, ld, etc.  */
+	if (just_machine_suffix && pl->require_machine_suffix == 2)
+	  {
+	    /* Some systems have a suffix for executable files.
+	       So try appending that first.  */
+	    if (file_suffix[0] != 0)
+	      {
+		strcpy (temp, pl->prefix);
+		strcat (temp, just_machine_suffix);
+		strcat (temp, multilib_name);
+		strcat (temp, file_suffix);
+		if (access_check (temp, mode) == 0)
+		  return temp;
+	      }
+
+	    strcpy (temp, pl->prefix);
+	    strcat (temp, just_machine_suffix);
+	    strcat (temp, multilib_name);
+	    if (access_check (temp, mode) == 0)
+	      return temp;
+	  }
+
+	/* Certain prefixes can't be used without the machine suffix
+	   when the machine or version is explicitly specified.  */
+	if (! pl->require_machine_suffix)
+	  {
+	    /* Some systems have a suffix for executable files.
+	       So try appending that first.  */
+	    if (file_suffix[0] != 0)
+	      {
+		strcpy (temp, pl->prefix);
+		strcat (temp, this_name);
+		strcat (temp, file_suffix);
+		if (access_check (temp, mode) == 0)
+		  return temp;
+	      }
+
+	    strcpy (temp, pl->prefix);
+	    strcat (temp, this_name);
+	    if (access_check (temp, mode) == 0)
+	      return temp;
+	  }
+      }
+
+  free (temp);
+  return 0;
+}
+
+/* Ranking of prefixes in the sort list. -B prefixes are put before
+   all others.  */
+
+enum path_prefix_priority
+{
+  PREFIX_PRIORITY_B_OPT,
+  PREFIX_PRIORITY_LAST
+};
+
+/* Add an entry for PREFIX in PLIST.  The PLIST is kept in ascending
+   order according to PRIORITY.  Within each PRIORITY, new entries are
+   appended.
+
+   If WARN is nonzero, we will warn if no file is found
+   through this prefix.  WARN should point to an int
+   which will be set to 1 if this entry is used.
+
+   COMPONENT is the value to be passed to update_path.
+
+   REQUIRE_MACHINE_SUFFIX is 1 if this prefix can't be used without
+   the complete value of machine_suffix.
+   2 means try both machine_suffix and just_machine_suffix.  */
+
+static void
+add_prefix (struct path_prefix *pprefix, const char *prefix,
+	    const char *component, /* enum prefix_priority */ int priority,
+	    int require_machine_suffix, int os_multilib)
+{
+  struct prefix_list *pl, **prev;
+  int len;
+
+  for (prev = &pprefix->plist;
+       (*prev) != NULL && (*prev)->priority <= priority;
+       prev = &(*prev)->next)
+    ;
+
+  /* Keep track of the longest prefix.  */
+
+  prefix = update_path (prefix, component);
+  len = strlen (prefix);
+  if (len > pprefix->max_len)
+    pprefix->max_len = len;
+
+  pl = xmalloc (sizeof (struct prefix_list));
+  pl->prefix = prefix;
+  pl->require_machine_suffix = require_machine_suffix;
+  pl->priority = priority;
+  pl->os_multilib = os_multilib;
+
+  /* Insert after PREV.  */
+  pl->next = (*prev);
+  (*prev) = pl;
+}
+
+/* Same as add_prefix, but prepending target_system_root to prefix.  */
+static void
+add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,
+		      const char *component,
+		      /* enum prefix_priority */ int priority,
+		      int require_machine_suffix, int os_multilib)
+{
+  if (!IS_ABSOLUTE_PATH (prefix))
+    fatal ("system path '%s' is not absolute", prefix);
+
+  if (target_system_root)
+    {
+      if (target_sysroot_suffix)
+	  prefix = concat (target_sysroot_suffix, prefix, NULL);
+      prefix = concat (target_system_root, prefix, NULL);
+
+      /* We have to override this because GCC's notion of sysroot
+	 moves along with GCC.  */
+      component = "GCC";
+    }
+
+  add_prefix (pprefix, prefix, component, priority,
+	      require_machine_suffix, os_multilib);
+}
+
+/* Execute the command specified by the arguments on the current line of spec.
+   When using pipes, this includes several piped-together commands
+   with `|' between them.
+
+   Return 0 if successful, -1 if failed.  */
+
+static int
+execute (void)
+{
+  int i;
+  int n_commands;		/* # of command.  */
+  char *string;
+  struct pex_obj *pex;
+  struct command
+  {
+    const char *prog;		/* program name.  */
+    const char **argv;		/* vector of args.  */
+  };
+
+  struct command *commands;	/* each command buffer with above info.  */
+
+  gcc_assert (!processing_spec_function);
+
+  /* Count # of piped commands.  */
+  for (n_commands = 1, i = 0; i < argbuf_index; i++)
+    if (strcmp (argbuf[i], "|") == 0)
+      n_commands++;
+
+  /* Get storage for each command.  */
+  commands = alloca (n_commands * sizeof (struct command));
+
+  /* Split argbuf into its separate piped processes,
+     and record info about each one.
+     Also search for the programs that are to be run.  */
+
+  commands[0].prog = argbuf[0]; /* first command.  */
+  commands[0].argv = &argbuf[0];
+  string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, 0);
+
+  if (string)
+    commands[0].argv[0] = string;
+
+  for (n_commands = 1, i = 0; i < argbuf_index; i++)
+    if (strcmp (argbuf[i], "|") == 0)
+      {				/* each command.  */
+#if defined (__MSDOS__) || defined (OS2) || defined (VMS)
+	fatal ("-pipe not supported");
+#endif
+	argbuf[i] = 0;	/* termination of command args.  */
+	commands[n_commands].prog = argbuf[i + 1];
+	commands[n_commands].argv = &argbuf[i + 1];
+	string = find_a_file (&exec_prefixes, commands[n_commands].prog,
+			      X_OK, 0);
+	if (string)
+	  commands[n_commands].argv[0] = string;
+	n_commands++;
+      }
+
+  argbuf[argbuf_index] = 0;
+
+  /* If -v, print what we are about to do, and maybe query.  */
+
+  if (verbose_flag)
+    {
+      /* For help listings, put a blank line between sub-processes.  */
+      if (print_help_list)
+	fputc ('\n', stderr);
+
+      /* Print each piped command as a separate line.  */
+      for (i = 0; i < n_commands; i++)
+	{
+	  const char *const *j;
+
+	  if (verbose_only_flag)
+	    {
+	      for (j = commands[i].argv; *j; j++)
+		{
+		  const char *p;
+		  fprintf (stderr, " \"");
+		  for (p = *j; *p; ++p)
+		    {
+		      if (*p == '"' || *p == '\\' || *p == '$')
+			fputc ('\\', stderr);
+		      fputc (*p, stderr);
+		    }
+		  fputc ('"', stderr);
+		}
+	    }
+	  else
+	    for (j = commands[i].argv; *j; j++)
+	      fprintf (stderr, " %s", *j);
+
+	  /* Print a pipe symbol after all but the last command.  */
+	  if (i + 1 != n_commands)
+	    fprintf (stderr, " |");
+	  fprintf (stderr, "\n");
+	}
+      fflush (stderr);
+      if (verbose_only_flag != 0)
+        {
+	  /* verbose_only_flag should act as if the spec was
+	     executed, so increment execution_count before
+	     returning.  This prevents spurious warnings about
+	     unused linker input files, etc.  */
+	  execution_count++;
+	  return 0;
+        }
+#ifdef DEBUG
+      notice ("\nGo ahead? (y or n) ");
+      fflush (stderr);
+      i = getchar ();
+      if (i != '\n')
+	while (getchar () != '\n')
+	  ;
+
+      if (i != 'y' && i != 'Y')
+	return 0;
+#endif /* DEBUG */
+    }
+
+#ifdef ENABLE_VALGRIND_CHECKING
+  /* Run the each command through valgrind.  To simplify prepending the
+     path to valgrind and the option "-q" (for quiet operation unless
+     something triggers), we allocate a separate argv array.  */
+
+  for (i = 0; i < n_commands; i++)
+    {
+      const char **argv;
+      int argc;
+      int j;
+
+      for (argc = 0; commands[i].argv[argc] != NULL; argc++)
+	;
+
+      argv = alloca ((argc + 3) * sizeof (char *));
+
+      argv[0] = VALGRIND_PATH;
+      argv[1] = "-q";
+      for (j = 2; j < argc + 2; j++)
+	argv[j] = commands[i].argv[j - 2];
+      argv[j] = NULL;
+
+      commands[i].argv = argv;
+      commands[i].prog = argv[0];
+    }
+#endif
+
+  /* Run each piped subprocess.  */
+
+  pex = pex_init (PEX_USE_PIPES | (report_times ? PEX_RECORD_TIMES : 0),
+		  programname, temp_filename);
+  if (pex == NULL)
+    pfatal_with_name (_("pex_init failed"));
+
+  for (i = 0; i < n_commands; i++)
+    {
+      const char *errmsg;
+      int err;
+      const char *string = commands[i].argv[0];
+
+      errmsg = pex_run (pex,
+			((i + 1 == n_commands ? PEX_LAST : 0)
+			 | (string == commands[i].prog ? PEX_SEARCH : 0)),
+			string, (char * const *) commands[i].argv,
+			NULL, NULL, &err);
+      if (errmsg != NULL)
+	{
+	  if (err == 0)
+	    fatal (errmsg);
+	  else
+	    {
+	      errno = err;
+	      pfatal_with_name (errmsg);
+	    }
+	}
+
+      if (string != commands[i].prog)
+	free ((void *) string);
+    }
+
+  execution_count++;
+
+  /* Wait for all the subprocesses to finish.  */
+
+  {
+    int *statuses;
+    struct pex_time *times = NULL;
+    int ret_code = 0;
+
+    statuses = alloca (n_commands * sizeof (int));
+    if (!pex_get_status (pex, n_commands, statuses))
+      pfatal_with_name (_("failed to get exit status"));
+
+    if (report_times)
+      {
+	times = alloca (n_commands * sizeof (struct pex_time));
+	if (!pex_get_times (pex, n_commands, times))
+	  pfatal_with_name (_("failed to get process times"));
+      }
+
+    pex_free (pex);
+
+    for (i = 0; i < n_commands; ++i)
+      {
+	int status = statuses[i];
+
+	if (WIFSIGNALED (status))
+	  {
+#ifdef SIGPIPE
+	    /* SIGPIPE is a special case.  It happens in -pipe mode
+	       when the compiler dies before the preprocessor is done,
+	       or the assembler dies before the compiler is done.
+	       There's generally been an error already, and this is
+	       just fallout.  So don't generate another error unless
+	       we would otherwise have succeeded.  */
+	    if (WTERMSIG (status) == SIGPIPE
+		&& (signal_count || greatest_status >= MIN_FATAL_STATUS))
+	      ;
+	    else
+#endif
+	      fatal ("\
+Internal error: %s (program %s)\n\
+Please submit a full bug report.\n\
+See %s for instructions.",
+		     strsignal (WTERMSIG (status)), commands[i].prog,
+		     bug_report_url);
+	    signal_count++;
+	    ret_code = -1;
+	  }
+	else if (WIFEXITED (status)
+		 && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
+	  {
+	    if (WEXITSTATUS (status) > greatest_status)
+	      greatest_status = WEXITSTATUS (status);
+	    ret_code = -1;
+	  }
+
+	if (report_times)
+	  {
+	    struct pex_time *pt = &times[i];
+	    double ut, st;
+
+	    ut = ((double) pt->user_seconds
+		  + (double) pt->user_microseconds / 1.0e6);
+	    st = ((double) pt->system_seconds
+		  + (double) pt->system_microseconds / 1.0e6);
+
+	    if (ut + st != 0)
+	      notice ("# %s %.2f %.2f\n", commands[i].prog, ut, st);
+	  }
+      }
+
+    return ret_code;
+  }
+}
+
+/* Find all the switches given to us
+   and make a vector describing them.
+   The elements of the vector are strings, one per switch given.
+   If a switch uses following arguments, then the `part1' field
+   is the switch itself and the `args' field
+   is a null-terminated vector containing the following arguments.
+   The `live_cond' field is:
+   0 when initialized
+   1 if the switch is true in a conditional spec,
+   -1 if false (overridden by a later switch)
+   -2 if this switch should be ignored (used in %<S)
+   The `validated' field is nonzero if any spec has looked at this switch;
+   if it remains zero at the end of the run, it must be meaningless.  */
+
+#define SWITCH_OK       0
+#define SWITCH_FALSE   -1
+#define SWITCH_IGNORE  -2
+#define SWITCH_LIVE     1
+
+struct switchstr
+{
+  const char *part1;
+  const char **args;
+  int live_cond;
+  unsigned char validated;
+  unsigned char ordering;
+};
+
+static struct switchstr *switches;
+
+static int n_switches;
+
+/* Language is one of three things:
+
+   1) The name of a real programming language.
+   2) NULL, indicating that no one has figured out
+   what it is yet.
+   3) '*', indicating that the file should be passed
+   to the linker.  */
+struct infile
+{
+  const char *name;
+  const char *language;
+  struct compiler *incompiler;
+  bool compiled;
+  bool preprocessed;
+};
+
+/* Also a vector of input files specified.  */
+
+static struct infile *infiles;
+
+int n_infiles;
+
+/* True if multiple input files are being compiled to a single
+   assembly file.  */
+
+static bool combine_inputs;
+
+/* This counts the number of libraries added by lang_specific_driver, so that
+   we can tell if there were any user supplied any files or libraries.  */
+
+static int added_libraries;
+
+/* And a vector of corresponding output files is made up later.  */
+
+const char **outfiles;
+
+#if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+
+/* Convert NAME to a new name if it is the standard suffix.  DO_EXE
+   is true if we should look for an executable suffix.  DO_OBJ
+   is true if we should look for an object suffix.  */
+
+static const char *
+convert_filename (const char *name, int do_exe ATTRIBUTE_UNUSED,
+		  int do_obj ATTRIBUTE_UNUSED)
+{
+#if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+  int i;
+#endif
+  int len;
+
+  if (name == NULL)
+    return NULL;
+
+  len = strlen (name);
+
+#ifdef HAVE_TARGET_OBJECT_SUFFIX
+  /* Convert x.o to x.obj if TARGET_OBJECT_SUFFIX is ".obj".  */
+  if (do_obj && len > 2
+      && name[len - 2] == '.'
+      && name[len - 1] == 'o')
+    {
+      obstack_grow (&obstack, name, len - 2);
+      obstack_grow0 (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX));
+      name = XOBFINISH (&obstack, const char *);
+    }
+#endif
+
+#if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+  /* If there is no filetype, make it the executable suffix (which includes
+     the ".").  But don't get confused if we have just "-o".  */
+  if (! do_exe || TARGET_EXECUTABLE_SUFFIX[0] == 0 || (len == 2 && name[0] == '-'))
+    return name;
+
+  for (i = len - 1; i >= 0; i--)
+    if (IS_DIR_SEPARATOR (name[i]))
+      break;
+
+  for (i++; i < len; i++)
+    if (name[i] == '.')
+      return name;
+
+  obstack_grow (&obstack, name, len);
+  obstack_grow0 (&obstack, TARGET_EXECUTABLE_SUFFIX,
+		 strlen (TARGET_EXECUTABLE_SUFFIX));
+  name = XOBFINISH (&obstack, const char *);
+#endif
+
+  return name;
+}
+#endif
+
+/* Display the command line switches accepted by gcc.  */
+static void
+display_help (void)
+{
+  printf (_("Usage: %s [options] file...\n"), programname);
+  fputs (_("Options:\n"), stdout);
+
+  fputs (_("  -pass-exit-codes         Exit with highest error code from a phase\n"), stdout);
+  fputs (_("  --help                   Display this information\n"), stdout);
+  fputs (_("  --target-help            Display target specific command line options\n"), stdout);
+  if (! verbose_flag)
+    fputs (_("  (Use '-v --help' to display command line options of sub-processes)\n"), stdout);
+  fputs (_("  -dumpspecs               Display all of the built in spec strings\n"), stdout);
+  fputs (_("  -dumpversion             Display the version of the compiler\n"), stdout);
+  fputs (_("  -dumpmachine             Display the compiler's target processor\n"), stdout);
+  fputs (_("  -print-search-dirs       Display the directories in the compiler's search path\n"), stdout);
+  fputs (_("  -print-libgcc-file-name  Display the name of the compiler's companion library\n"), stdout);
+  fputs (_("  -print-file-name=<lib>   Display the full path to library <lib>\n"), stdout);
+  fputs (_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>\n"), stdout);
+  fputs (_("  -print-multi-directory   Display the root directory for versions of libgcc\n"), stdout);
+  fputs (_("\
+  -print-multi-lib         Display the mapping between command line options and\n\
+                           multiple library search directories\n"), stdout);
+  fputs (_("  -print-multi-os-directory Display the relative path to OS libraries\n"), stdout);
+  fputs (_("  -Wa,<options>            Pass comma-separated <options> on to the assembler\n"), stdout);
+  fputs (_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor\n"), stdout);
+  fputs (_("  -Wl,<options>            Pass comma-separated <options> on to the linker\n"), stdout);
+  fputs (_("  -Xassembler <arg>        Pass <arg> on to the assembler\n"), stdout);
+  fputs (_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor\n"), stdout);
+  fputs (_("  -Xlinker <arg>           Pass <arg> on to the linker\n"), stdout);
+  fputs (_("  -combine                 Pass multiple source files to compiler at once\n"), stdout);
+  fputs (_("  -save-temps              Do not delete intermediate files\n"), stdout);
+  fputs (_("  -pipe                    Use pipes rather than intermediate files\n"), stdout);
+  fputs (_("  -time                    Time the execution of each subprocess\n"), stdout);
+  fputs (_("  -specs=<file>            Override built-in specs with the contents of <file>\n"), stdout);
+  fputs (_("  -std=<standard>          Assume that the input sources are for <standard>\n"), stdout);
+  fputs (_("\
+  --sysroot=<directory>    Use <directory> as the root directory for headers\n\
+                           for headers and libraries\n"), stdout);
+  fputs (_("  -B <directory>           Add <directory> to the compiler's search paths\n"), stdout);
+  fputs (_("  -b <machine>             Run gcc for target <machine>, if installed\n"), stdout);
+  fputs (_("  -V <version>             Run gcc version number <version>, if installed\n"), stdout);
+  fputs (_("  -v                       Display the programs invoked by the compiler\n"), stdout);
+  fputs (_("  -###                     Like -v but options quoted and commands not executed\n"), stdout);
+  fputs (_("  -E                       Preprocess only; do not compile, assemble or link\n"), stdout);
+  fputs (_("  -S                       Compile only; do not assemble or link\n"), stdout);
+  fputs (_("  -c                       Compile and assemble, but do not link\n"), stdout);
+  fputs (_("  -o <file>                Place the output into <file>\n"), stdout);
+  fputs (_("\
+  -x <language>            Specify the language of the following input files\n\
+                           Permissible languages include: c c++ assembler none\n\
+                           'none' means revert to the default behavior of\n\
+                           guessing the language based on the file's extension\n\
+"), stdout);
+
+  printf (_("\
+\nOptions starting with -g, -f, -m, -O, -W, or --param are automatically\n\
+ passed on to the various sub-processes invoked by %s.  In order to pass\n\
+ other options on to these processes the -W<letter> options must be used.\n\
+"), programname);
+
+  /* The rest of the options are displayed by invocations of the various
+     sub-processes.  */
+}
+
+static void
+add_preprocessor_option (const char *option, int len)
+{
+  n_preprocessor_options++;
+
+  if (! preprocessor_options)
+    preprocessor_options = xmalloc (n_preprocessor_options * sizeof (char *));
+  else
+    preprocessor_options = xrealloc (preprocessor_options,
+				     n_preprocessor_options * sizeof (char *));
+
+  preprocessor_options [n_preprocessor_options - 1] =
+    save_string (option, len);
+}
+
+static void
+add_assembler_option (const char *option, int len)
+{
+  n_assembler_options++;
+
+  if (! assembler_options)
+    assembler_options = xmalloc (n_assembler_options * sizeof (char *));
+  else
+    assembler_options = xrealloc (assembler_options,
+				  n_assembler_options * sizeof (char *));
+
+  assembler_options [n_assembler_options - 1] = save_string (option, len);
+}
+
+static void
+add_linker_option (const char *option, int len)
+{
+  n_linker_options++;
+
+  if (! linker_options)
+    linker_options = xmalloc (n_linker_options * sizeof (char *));
+  else
+    linker_options = xrealloc (linker_options,
+			       n_linker_options * sizeof (char *));
+
+  linker_options [n_linker_options - 1] = save_string (option, len);
+}
+
+/* Create the vector `switches' and its contents.
+   Store its length in `n_switches'.  */
+
+static void
+process_command (int argc, const char **argv)
+{
+  int i;
+  const char *temp;
+  char *temp1;
+  const char *spec_lang = 0;
+  int last_language_n_infiles;
+  int lang_n_infiles = 0;
+#ifdef MODIFY_TARGET_NAME
+  int is_modify_target_name;
+  int j;
+#endif
+
+  GET_ENVIRONMENT (gcc_exec_prefix, "GCC_EXEC_PREFIX");
+
+  n_switches = 0;
+  n_infiles = 0;
+  added_libraries = 0;
+
+  /* Figure compiler version from version string.  */
+
+  compiler_version = temp1 = xstrdup (version_string);
+
+  for (; *temp1; ++temp1)
+    {
+      if (*temp1 == ' ')
+	{
+	  *temp1 = '\0';
+	  break;
+	}
+    }
+
+  /* If there is a -V or -b option (or both), process it now, before
+     trying to interpret the rest of the command line. 
+     Use heuristic that all configuration names must have at least
+     one dash '-'. This allows us to pass options starting with -b.  */
+  if (argc > 1 && argv[1][0] == '-'
+      && (argv[1][1] == 'V' || 
+	 ((argv[1][1] == 'b') && (NULL != strchr(argv[1] + 2,'-')))))
+    {
+      const char *new_version = DEFAULT_TARGET_VERSION;
+      const char *new_machine = DEFAULT_TARGET_MACHINE;
+      const char *progname = argv[0];
+      char **new_argv;
+      char *new_argv0;
+      int baselen;
+
+      while (argc > 1 && argv[1][0] == '-'
+	     && (argv[1][1] == 'V' ||
+		((argv[1][1] == 'b') && ( NULL != strchr(argv[1] + 2,'-')))))
+	{
+	  char opt = argv[1][1];
+	  const char *arg;
+	  if (argv[1][2] != '\0')
+	    {
+	      arg = argv[1] + 2;
+	      argc -= 1;
+	      argv += 1;
+	    }
+	  else if (argc > 2)
+	    {
+	      arg = argv[2];
+	      argc -= 2;
+	      argv += 2;
+	    }
+	  else
+	    fatal ("'-%c' option must have argument", opt);
+	  if (opt == 'V')
+	    new_version = arg;
+	  else
+	    new_machine = arg;
+	}
+
+      for (baselen = strlen (progname); baselen > 0; baselen--)
+	if (IS_DIR_SEPARATOR (progname[baselen-1]))
+	  break;
+      new_argv0 = xmemdup (progname, baselen,
+			   baselen + concat_length (new_version, new_machine,
+						    "-gcc-", NULL) + 1);
+      strcpy (new_argv0 + baselen, new_machine);
+      strcat (new_argv0, "-gcc-");
+      strcat (new_argv0, new_version);
+
+      new_argv = xmemdup (argv, (argc + 1) * sizeof (argv[0]),
+			  (argc + 1) * sizeof (argv[0]));
+      new_argv[0] = new_argv0;
+
+      execvp (new_argv0, new_argv);
+      fatal ("couldn't run '%s': %s", new_argv0, xstrerror (errno));
+    }
+
+  /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,
+     see if we can create it from the pathname specified in argv[0].  */
+
+  gcc_libexec_prefix = standard_libexec_prefix;
+#ifndef VMS
+  /* FIXME: make_relative_prefix doesn't yet work for VMS.  */
+  if (!gcc_exec_prefix)
+    {
+      gcc_exec_prefix = make_relative_prefix (argv[0], standard_bindir_prefix,
+					      standard_exec_prefix);
+      gcc_libexec_prefix = make_relative_prefix (argv[0],
+						 standard_bindir_prefix,
+						 standard_libexec_prefix);
+      if (gcc_exec_prefix)
+	putenv (concat ("GCC_EXEC_PREFIX=", gcc_exec_prefix, NULL));
+    }
+  else
+    gcc_libexec_prefix = make_relative_prefix (gcc_exec_prefix,
+					       standard_exec_prefix,
+					       standard_libexec_prefix);
+#else
+#endif
+
+  if (gcc_exec_prefix)
+    {
+      int len = strlen (gcc_exec_prefix);
+
+      if (len > (int) sizeof ("/lib/gcc/") - 1
+	  && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))
+	{
+	  temp = gcc_exec_prefix + len - sizeof ("/lib/gcc/") + 1;
+	  if (IS_DIR_SEPARATOR (*temp)
+	      && strncmp (temp + 1, "lib", 3) == 0
+	      && IS_DIR_SEPARATOR (temp[4])
+	      && strncmp (temp + 5, "gcc", 3) == 0)
+	    len -= sizeof ("/lib/gcc/") - 1;
+	}
+
+      set_std_prefix (gcc_exec_prefix, len);
+      add_prefix (&exec_prefixes, gcc_libexec_prefix, "GCC",
+		  PREFIX_PRIORITY_LAST, 0, 0);
+      add_prefix (&startfile_prefixes, gcc_exec_prefix, "GCC",
+		  PREFIX_PRIORITY_LAST, 0, 0);
+    }
+
+  /* COMPILER_PATH and LIBRARY_PATH have values
+     that are lists of directory names with colons.  */
+
+  GET_ENVIRONMENT (temp, "COMPILER_PATH");
+  if (temp)
+    {
+      const char *startp, *endp;
+      char *nstore = alloca (strlen (temp) + 3);
+
+      startp = endp = temp;
+      while (1)
+	{
+	  if (*endp == PATH_SEPARATOR || *endp == 0)
+	    {
+	      strncpy (nstore, startp, endp - startp);
+	      if (endp == startp)
+		strcpy (nstore, concat (".", dir_separator_str, NULL));
+	      else if (!IS_DIR_SEPARATOR (endp[-1]))
+		{
+		  nstore[endp - startp] = DIR_SEPARATOR;
+		  nstore[endp - startp + 1] = 0;
+		}
+	      else
+		nstore[endp - startp] = 0;
+	      add_prefix (&exec_prefixes, nstore, 0,
+			  PREFIX_PRIORITY_LAST, 0, 0);
+	      add_prefix (&include_prefixes, nstore, 0,
+			  PREFIX_PRIORITY_LAST, 0, 0);
+	      if (*endp == 0)
+		break;
+	      endp = startp = endp + 1;
+	    }
+	  else
+	    endp++;
+	}
+    }
+
+  GET_ENVIRONMENT (temp, LIBRARY_PATH_ENV);
+  if (temp && *cross_compile == '0')
+    {
+      const char *startp, *endp;
+      char *nstore = alloca (strlen (temp) + 3);
+
+      startp = endp = temp;
+      while (1)
+	{
+	  if (*endp == PATH_SEPARATOR || *endp == 0)
+	    {
+	      strncpy (nstore, startp, endp - startp);
+	      if (endp == startp)
+		strcpy (nstore, concat (".", dir_separator_str, NULL));
+	      else if (!IS_DIR_SEPARATOR (endp[-1]))
+		{
+		  nstore[endp - startp] = DIR_SEPARATOR;
+		  nstore[endp - startp + 1] = 0;
+		}
+	      else
+		nstore[endp - startp] = 0;
+	      add_prefix (&startfile_prefixes, nstore, NULL,
+			  PREFIX_PRIORITY_LAST, 0, 1);
+	      if (*endp == 0)
+		break;
+	      endp = startp = endp + 1;
+	    }
+	  else
+	    endp++;
+	}
+    }
+
+  /* Use LPATH like LIBRARY_PATH (for the CMU build program).  */
+  GET_ENVIRONMENT (temp, "LPATH");
+  if (temp && *cross_compile == '0')
+    {
+      const char *startp, *endp;
+      char *nstore = alloca (strlen (temp) + 3);
+
+      startp = endp = temp;
+      while (1)
+	{
+	  if (*endp == PATH_SEPARATOR || *endp == 0)
+	    {
+	      strncpy (nstore, startp, endp - startp);
+	      if (endp == startp)
+		strcpy (nstore, concat (".", dir_separator_str, NULL));
+	      else if (!IS_DIR_SEPARATOR (endp[-1]))
+		{
+		  nstore[endp - startp] = DIR_SEPARATOR;
+		  nstore[endp - startp + 1] = 0;
+		}
+	      else
+		nstore[endp - startp] = 0;
+	      add_prefix (&startfile_prefixes, nstore, NULL,
+			  PREFIX_PRIORITY_LAST, 0, 1);
+	      if (*endp == 0)
+		break;
+	      endp = startp = endp + 1;
+	    }
+	  else
+	    endp++;
+	}
+    }
+
+  /* Convert new-style -- options to old-style.  */
+  translate_options (&argc, (const char *const **) &argv);
+
+  /* Do language-specific adjustment/addition of flags.  */
+  lang_specific_driver (&argc, (const char *const **) &argv, &added_libraries);
+
+  /* Scan argv twice.  Here, the first time, just count how many switches
+     there will be in their vector, and how many input files in theirs.
+     Here we also parse the switches that cc itself uses (e.g. -v).  */
+
+  for (i = 1; i < argc; i++)
+    {
+      if (! strcmp (argv[i], "-dumpspecs"))
+	{
+	  struct spec_list *sl;
+	  init_spec ();
+	  for (sl = specs; sl; sl = sl->next)
+	    printf ("*%s:\n%s\n\n", sl->name, *(sl->ptr_spec));
+	  if (link_command_spec)
+	    printf ("*link_command:\n%s\n\n", link_command_spec);
+	  exit (0);
+	}
+      else if (! strcmp (argv[i], "-dumpversion"))
+	{
+	  printf ("%s\n", spec_version);
+	  exit (0);
+	}
+      else if (! strcmp (argv[i], "-dumpmachine"))
+	{
+	  printf ("%s\n", spec_machine);
+	  exit (0);
+	}
+      else if (strcmp (argv[i], "-fversion") == 0)
+	{
+	  /* translate_options () has turned --version into -fversion.  */
+	  printf (_("%s (GCC) %s\n"), programname, version_string);
+	  printf ("Copyright %s 2006 Free Software Foundation, Inc.\n",
+		  _("(C)"));
+	  fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
+		 stdout);
+	  exit (0);
+	}
+      else if (strcmp (argv[i], "-fhelp") == 0)
+	{
+	  /* translate_options () has turned --help into -fhelp.  */
+	  print_help_list = 1;
+
+	  /* We will be passing a dummy file on to the sub-processes.  */
+	  n_infiles++;
+	  n_switches++;
+
+	  /* CPP driver cannot obtain switch from cc1_options.  */
+	  if (is_cpp_driver)
+	    add_preprocessor_option ("--help", 6);
+	  add_assembler_option ("--help", 6);
+	  add_linker_option ("--help", 6);
+	}
+      else if (strcmp (argv[i], "-ftarget-help") == 0)
+	{
+	  /* translate_options() has turned --target-help into -ftarget-help.  */
+	  target_help_flag = 1;
+
+	  /* We will be passing a dummy file on to the sub-processes.  */
+	  n_infiles++;
+	  n_switches++;
+
+	  /* CPP driver cannot obtain switch from cc1_options.  */
+	  if (is_cpp_driver)
+	    add_preprocessor_option ("--target-help", 13);
+	  add_assembler_option ("--target-help", 13);
+	  add_linker_option ("--target-help", 13);
+	}
+      else if (! strcmp (argv[i], "-pass-exit-codes"))
+	{
+	  pass_exit_codes = 1;
+	  n_switches++;
+	}
+      else if (! strcmp (argv[i], "-print-search-dirs"))
+	print_search_dirs = 1;
+      else if (! strcmp (argv[i], "-print-libgcc-file-name"))
+	print_file_name = "libgcc.a";
+      else if (! strncmp (argv[i], "-print-file-name=", 17))
+	print_file_name = argv[i] + 17;
+      else if (! strncmp (argv[i], "-print-prog-name=", 17))
+	print_prog_name = argv[i] + 17;
+      else if (! strcmp (argv[i], "-print-multi-lib"))
+	print_multi_lib = 1;
+      else if (! strcmp (argv[i], "-print-multi-directory"))
+	print_multi_directory = 1;
+      else if (! strcmp (argv[i], "-print-multi-os-directory"))
+	print_multi_os_directory = 1;
+      else if (! strncmp (argv[i], "-Wa,", 4))
+	{
+	  int prev, j;
+	  /* Pass the rest of this option to the assembler.  */
+
+	  /* Split the argument at commas.  */
+	  prev = 4;
+	  for (j = 4; argv[i][j]; j++)
+	    if (argv[i][j] == ',')
+	      {
+		add_assembler_option (argv[i] + prev, j - prev);
+		prev = j + 1;
+	      }
+
+	  /* Record the part after the last comma.  */
+	  add_assembler_option (argv[i] + prev, j - prev);
+	}
+      else if (! strncmp (argv[i], "-Wp,", 4))
+	{
+	  int prev, j;
+	  /* Pass the rest of this option to the preprocessor.  */
+
+	  /* Split the argument at commas.  */
+	  prev = 4;
+	  for (j = 4; argv[i][j]; j++)
+	    if (argv[i][j] == ',')
+	      {
+		add_preprocessor_option (argv[i] + prev, j - prev);
+		prev = j + 1;
+	      }
+
+	  /* Record the part after the last comma.  */
+	  add_preprocessor_option (argv[i] + prev, j - prev);
+	}
+      else if (argv[i][0] == '+' && argv[i][1] == 'e')
+	/* The +e options to the C++ front-end.  */
+	n_switches++;
+      else if (strncmp (argv[i], "-Wl,", 4) == 0)
+	{
+	  int j;
+	  /* Split the argument at commas.  */
+	  for (j = 3; argv[i][j]; j++)
+	    n_infiles += (argv[i][j] == ',');
+	}
+      else if (strcmp (argv[i], "-Xlinker") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to '-Xlinker' is missing");
+
+	  n_infiles++;
+	  i++;
+	}
+      else if (strcmp (argv[i], "-Xpreprocessor") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to '-Xpreprocessor' is missing");
+
+	  add_preprocessor_option (argv[i+1], strlen (argv[i+1]));
+	}
+      else if (strcmp (argv[i], "-Xassembler") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to '-Xassembler' is missing");
+
+	  add_assembler_option (argv[i+1], strlen (argv[i+1]));
+	}
+      else if (strcmp (argv[i], "-l") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to '-l' is missing");
+
+	  n_infiles++;
+	  i++;
+	}
+      else if (strncmp (argv[i], "-l", 2) == 0)
+	n_infiles++;
+      else if (strcmp (argv[i], "-save-temps") == 0)
+	{
+	  save_temps_flag = 1;
+	  n_switches++;
+	}
+      else if (strcmp (argv[i], "-combine") == 0)
+	{
+	  combine_flag = 1;
+	  n_switches++;
+	}
+      else if (strcmp (argv[i], "-specs") == 0)
+	{
+	  struct user_specs *user = xmalloc (sizeof (struct user_specs));
+	  if (++i >= argc)
+	    fatal ("argument to '-specs' is missing");
+
+	  user->next = (struct user_specs *) 0;
+	  user->filename = argv[i];
+	  if (user_specs_tail)
+	    user_specs_tail->next = user;
+	  else
+	    user_specs_head = user;
+	  user_specs_tail = user;
+	}
+      else if (strncmp (argv[i], "-specs=", 7) == 0)
+	{
+	  struct user_specs *user = xmalloc (sizeof (struct user_specs));
+	  if (strlen (argv[i]) == 7)
+	    fatal ("argument to '-specs=' is missing");
+
+	  user->next = (struct user_specs *) 0;
+	  user->filename = argv[i] + 7;
+	  if (user_specs_tail)
+	    user_specs_tail->next = user;
+	  else
+	    user_specs_head = user;
+	  user_specs_tail = user;
+	}
+      else if (strcmp (argv[i], "-time") == 0)
+	report_times = 1;
+      else if (strcmp (argv[i], "-pipe") == 0)
+	{
+	  /* -pipe has to go into the switches array as well as
+	     setting a flag.  */
+	  use_pipes = 1;
+	  n_switches++;
+	}
+      else if (strcmp (argv[i], "-###") == 0)
+	{
+	  /* This is similar to -v except that there is no execution
+	     of the commands and the echoed arguments are quoted.  It
+	     is intended for use in shell scripts to capture the
+	     driver-generated command line.  */
+	  verbose_only_flag++;
+	  verbose_flag++;
+	}
+      else if (argv[i][0] == '-' && argv[i][1] != 0)
+	{
+	  const char *p = &argv[i][1];
+	  int c = *p;
+
+	  switch (c)
+	    {
+	    case 'b':
+	      if (NULL == strchr(argv[i] + 2, '-'))
+		goto normal_switch;
+
+	      /* Fall through.  */
+	    case 'V':
+	      fatal ("'-%c' must come at the start of the command line", c);
+	      break;
+
+	    case 'B':
+	      {
+		const char *value;
+		int len;
+
+		if (p[1] == 0 && i + 1 == argc)
+		  fatal ("argument to '-B' is missing");
+		if (p[1] == 0)
+		  value = argv[++i];
+		else
+		  value = p + 1;
+
+		len = strlen (value);
+
+		/* Catch the case where the user has forgotten to append a
+		   directory separator to the path.  Note, they may be using
+		   -B to add an executable name prefix, eg "i386-elf-", in
+		   order to distinguish between multiple installations of
+		   GCC in the same directory.  Hence we must check to see
+		   if appending a directory separator actually makes a
+		   valid directory name.  */
+		if (! IS_DIR_SEPARATOR (value [len - 1])
+		    && is_directory (value, "", 0))
+		  {
+		    char *tmp = xmalloc (len + 2);
+		    strcpy (tmp, value);
+		    tmp[len] = DIR_SEPARATOR;
+		    tmp[++ len] = 0;
+		    value = tmp;
+		  }
+
+		/* As a kludge, if the arg is "[foo/]stageN/", just
+		   add "[foo/]include" to the include prefix.  */
+		if ((len == 7
+		     || (len > 7
+			 && (IS_DIR_SEPARATOR (value[len - 8]))))
+		    && strncmp (value + len - 7, "stage", 5) == 0
+		    && ISDIGIT (value[len - 2])
+		    && (IS_DIR_SEPARATOR (value[len - 1])))
+		  {
+		    if (len == 7)
+		      add_prefix (&include_prefixes, "./", NULL,
+				  PREFIX_PRIORITY_B_OPT, 0, 0);
+		    else
+		      {
+		        char *string = xmalloc (len - 6);
+			memcpy (string, value, len - 7);
+			string[len - 7] = 0;
+		        add_prefix (&include_prefixes, string, NULL,
+				    PREFIX_PRIORITY_B_OPT, 0, 0);
+		      }
+		  }
+
+		add_prefix (&exec_prefixes, value, NULL,
+			    PREFIX_PRIORITY_B_OPT, 0, 0);
+		add_prefix (&startfile_prefixes, value, NULL,
+			    PREFIX_PRIORITY_B_OPT, 0, 0);
+		add_prefix (&include_prefixes, value, NULL,
+			    PREFIX_PRIORITY_B_OPT, 0, 0);
+		n_switches++;
+	      }
+	      break;
+
+	    case 'v':	/* Print our subcommands and print versions.  */
+	      n_switches++;
+	      /* If they do anything other than exactly `-v', don't set
+		 verbose_flag; rather, continue on to give the error.  */
+	      if (p[1] != 0)
+		break;
+	      verbose_flag++;
+	      break;
+
+	    case 'S':
+	    case 'c':
+	      if (p[1] == 0)
+		{
+		  have_c = 1;
+		  n_switches++;
+		  break;
+		}
+	      goto normal_switch;
+
+	    case 'o':
+	      have_o = 1;
+#if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+	      if (! have_c)
+		{
+		  int skip;
+
+		  /* Forward scan, just in case -S or -c is specified
+		     after -o.  */
+		  int j = i + 1;
+		  if (p[1] == 0)
+		    ++j;
+		  while (j < argc)
+		    {
+		      if (argv[j][0] == '-')
+			{
+			  if (SWITCH_CURTAILS_COMPILATION (argv[j][1])
+			      && argv[j][2] == 0)
+			    {
+			      have_c = 1;
+			      break;
+			    }
+			  else if ((skip = SWITCH_TAKES_ARG (argv[j][1])))
+			    j += skip - (argv[j][2] != 0);
+			  else if ((skip = WORD_SWITCH_TAKES_ARG (argv[j] + 1)))
+			    j += skip;
+			}
+		      j++;
+		    }
+		}
+#endif
+#if defined(HAVE_TARGET_EXECUTABLE_SUFFIX) || defined(HAVE_TARGET_OBJECT_SUFFIX)
+	      if (p[1] == 0)
+		argv[i + 1] = convert_filename (argv[i + 1], ! have_c, 0);
+	      else
+		argv[i] = convert_filename (argv[i], ! have_c, 0);
+#endif
+	      goto normal_switch;
+
+	    default:
+	    normal_switch:
+
+#ifdef MODIFY_TARGET_NAME
+	      is_modify_target_name = 0;
+
+	      for (j = 0; j < ARRAY_SIZE (modify_target); j++)
+		if (! strcmp (argv[i], modify_target[j].sw))
+		  {
+		    char *new_name = xmalloc (strlen (modify_target[j].str)
+					      + strlen (spec_machine));
+		    const char *p, *r;
+		    char *q;
+		    int made_addition = 0;
+
+		    is_modify_target_name = 1;
+		    for (p = spec_machine, q = new_name; *p != 0; )
+		      {
+			if (modify_target[j].add_del == DELETE
+			    && (! strncmp (q, modify_target[j].str,
+					   strlen (modify_target[j].str))))
+			  p += strlen (modify_target[j].str);
+			else if (modify_target[j].add_del == ADD
+				 && ! made_addition && *p == '-')
+			  {
+			    for (r = modify_target[j].str; *r != 0; )
+			      *q++ = *r++;
+			    made_addition = 1;
+			  }
+
+			*q++ = *p++;
+		      }
+
+		    spec_machine = new_name;
+		  }
+
+	      if (is_modify_target_name)
+		break;
+#endif
+
+	      n_switches++;
+
+	      if (SWITCH_TAKES_ARG (c) > (p[1] != 0))
+		i += SWITCH_TAKES_ARG (c) - (p[1] != 0);
+	      else if (WORD_SWITCH_TAKES_ARG (p))
+		i += WORD_SWITCH_TAKES_ARG (p);
+	    }
+	}
+      else
+	{
+	  n_infiles++;
+	  lang_n_infiles++;
+	}
+    }
+
+  if (save_temps_flag && use_pipes)
+    {
+      /* -save-temps overrides -pipe, so that temp files are produced */
+      if (save_temps_flag)
+	error ("warning: -pipe ignored because -save-temps specified");
+      use_pipes = 0;
+    }
+
+  /* Set up the search paths before we go looking for config files.  */
+
+  /* These come before the md prefixes so that we will find gcc's subcommands
+     (such as cpp) rather than those of the host system.  */
+  /* Use 2 as fourth arg meaning try just the machine as a suffix,
+     as well as trying the machine and the version.  */
+#ifndef OS2
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "GCC",
+	      PREFIX_PRIORITY_LAST, 1, 0);
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, 0);
+  add_prefix (&exec_prefixes, standard_exec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, 0);
+  add_prefix (&exec_prefixes, standard_exec_prefix_1, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, 0);
+  add_prefix (&exec_prefixes, standard_exec_prefix_2, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, 0);
+#endif
+
+  add_prefix (&startfile_prefixes, standard_exec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 1, 0);
+  add_prefix (&startfile_prefixes, standard_exec_prefix_2, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 1, 0);
+
+  tooldir_prefix = concat (tooldir_base_prefix, spec_machine,
+			   dir_separator_str, NULL);
+
+  /* If tooldir is relative, base it on exec_prefixes.  A relative
+     tooldir lets us move the installed tree as a unit.
+
+     If GCC_EXEC_PREFIX is defined, then we want to add two relative
+     directories, so that we can search both the user specified directory
+     and the standard place.  */
+
+  if (!IS_ABSOLUTE_PATH (tooldir_prefix))
+    {
+      if (gcc_exec_prefix)
+	{
+	  char *gcc_exec_tooldir_prefix
+	    = concat (gcc_exec_prefix, spec_machine, dir_separator_str,
+		      spec_version, dir_separator_str, tooldir_prefix, NULL);
+
+	  add_prefix (&exec_prefixes,
+		      concat (gcc_exec_tooldir_prefix, "bin",
+			      dir_separator_str, NULL),
+		      NULL, PREFIX_PRIORITY_LAST, 0, 0);
+	  add_prefix (&startfile_prefixes,
+		      concat (gcc_exec_tooldir_prefix, "lib",
+			      dir_separator_str, NULL),
+		      NULL, PREFIX_PRIORITY_LAST, 0, 1);
+	}
+
+      tooldir_prefix = concat (standard_exec_prefix, spec_machine,
+			       dir_separator_str, spec_version,
+			       dir_separator_str, tooldir_prefix, NULL);
+    }
+
+  add_prefix (&exec_prefixes,
+	      concat (tooldir_prefix, "bin", dir_separator_str, NULL),
+	      "BINUTILS", PREFIX_PRIORITY_LAST, 0, 0);
+  add_prefix (&startfile_prefixes,
+	      concat (tooldir_prefix, "lib", dir_separator_str, NULL),
+	      "BINUTILS", PREFIX_PRIORITY_LAST, 0, 1);
+
+#if defined(TARGET_SYSTEM_ROOT_RELOCATABLE) && !defined(VMS)
+  /* If the normal TARGET_SYSTEM_ROOT is inside of $exec_prefix,
+     then consider it to relocate with the rest of the GCC installation
+     if GCC_EXEC_PREFIX is set.
+     ``make_relative_prefix'' is not compiled for VMS, so don't call it.  */
+  if (target_system_root && gcc_exec_prefix)
+    {
+      char *tmp_prefix = make_relative_prefix (argv[0],
+					       standard_bindir_prefix,
+					       target_system_root);
+      if (tmp_prefix && access_check (tmp_prefix, F_OK) == 0)
+	{
+	  target_system_root = tmp_prefix;
+	  target_system_root_changed = 1;
+	}
+    }
+#endif
+
+  /* More prefixes are enabled in main, after we read the specs file
+     and determine whether this is cross-compilation or not.  */
+
+  /* Then create the space for the vectors and scan again.  */
+
+  switches = xmalloc ((n_switches + 1) * sizeof (struct switchstr));
+  infiles = xmalloc ((n_infiles + 1) * sizeof (struct infile));
+  n_switches = 0;
+  n_infiles = 0;
+  last_language_n_infiles = -1;
+
+  /* This, time, copy the text of each switch and store a pointer
+     to the copy in the vector of switches.
+     Store all the infiles in their vector.  */
+
+  for (i = 1; i < argc; i++)
+    {
+      /* Just skip the switches that were handled by the preceding loop.  */
+#ifdef MODIFY_TARGET_NAME
+      is_modify_target_name = 0;
+
+      for (j = 0; j < ARRAY_SIZE (modify_target); j++)
+	if (! strcmp (argv[i], modify_target[j].sw))
+	  is_modify_target_name = 1;
+
+      if (is_modify_target_name)
+	;
+      else
+#endif
+      if (! strncmp (argv[i], "-Wa,", 4))
+	;
+      else if (! strncmp (argv[i], "-Wp,", 4))
+	;
+      else if (! strcmp (argv[i], "-pass-exit-codes"))
+	;
+      else if (! strcmp (argv[i], "-print-search-dirs"))
+	;
+      else if (! strcmp (argv[i], "-print-libgcc-file-name"))
+	;
+      else if (! strncmp (argv[i], "-print-file-name=", 17))
+	;
+      else if (! strncmp (argv[i], "-print-prog-name=", 17))
+	;
+      else if (! strcmp (argv[i], "-print-multi-lib"))
+	;
+      else if (! strcmp (argv[i], "-print-multi-directory"))
+	;
+      else if (! strcmp (argv[i], "-print-multi-os-directory"))
+	;
+      else if (! strcmp (argv[i], "-ftarget-help"))
+	;
+      else if (! strcmp (argv[i], "-fhelp"))
+	;
+      else if (! strncmp (argv[i], "--sysroot=", strlen ("--sysroot=")))
+	{
+	  target_system_root = argv[i] + strlen ("--sysroot=");
+	  target_system_root_changed = 1;
+	}
+      else if (argv[i][0] == '+' && argv[i][1] == 'e')
+	{
+	  /* Compensate for the +e options to the C++ front-end;
+	     they're there simply for cfront call-compatibility.  We do
+	     some magic in default_compilers to pass them down properly.
+	     Note we deliberately start at the `+' here, to avoid passing
+	     -e0 or -e1 down into the linker.  */
+	  switches[n_switches].part1 = &argv[i][0];
+	  switches[n_switches].args = 0;
+	  switches[n_switches].live_cond = SWITCH_OK;
+	  switches[n_switches].validated = 0;
+	  n_switches++;
+	}
+      else if (strncmp (argv[i], "-Wl,", 4) == 0)
+	{
+	  int prev, j;
+	  /* Split the argument at commas.  */
+	  prev = 4;
+	  for (j = 4; argv[i][j]; j++)
+	    if (argv[i][j] == ',')
+	      {
+		infiles[n_infiles].language = "*";
+		infiles[n_infiles++].name
+		  = save_string (argv[i] + prev, j - prev);
+		prev = j + 1;
+	      }
+	  /* Record the part after the last comma.  */
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = argv[i] + prev;
+	}
+      else if (strcmp (argv[i], "-Xlinker") == 0)
+	{
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = argv[++i];
+	}
+      /* Xassembler and Xpreprocessor were already handled in the first argv
+	 scan, so all we need to do here is ignore them and their argument.  */
+      else if (strcmp (argv[i], "-Xassembler") == 0)
+	i++;
+      else if (strcmp (argv[i], "-Xpreprocessor") == 0)
+	i++;
+      else if (strcmp (argv[i], "-l") == 0)
+	{ /* POSIX allows separation of -l and the lib arg;
+	     canonicalize by concatenating -l with its arg */
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = concat ("-l", argv[++i], NULL);
+	}
+      else if (strncmp (argv[i], "-l", 2) == 0)
+	{
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = argv[i];
+	}
+      else if (strcmp (argv[i], "-specs") == 0)
+	i++;
+      else if (strncmp (argv[i], "-specs=", 7) == 0)
+	;
+      else if (strcmp (argv[i], "-time") == 0)
+	;
+      else if (strcmp (argv[i], "-###") == 0)
+	;
+      else if (argv[i][0] == '-' && argv[i][1] != 0)
+	{
+	  const char *p = &argv[i][1];
+	  int c = *p;
+
+	  if (c == 'x')
+	    {
+	      if (p[1] == 0 && i + 1 == argc)
+		fatal ("argument to '-x' is missing");
+	      if (p[1] == 0)
+		spec_lang = argv[++i];
+	      else
+		spec_lang = p + 1;
+	      if (! strcmp (spec_lang, "none"))
+		/* Suppress the warning if -xnone comes after the last input
+		   file, because alternate command interfaces like g++ might
+		   find it useful to place -xnone after each input file.  */
+		spec_lang = 0;
+	      else
+		last_language_n_infiles = n_infiles;
+	      continue;
+	    }
+	  switches[n_switches].part1 = p;
+	  /* Deal with option arguments in separate argv elements.  */
+	  if ((SWITCH_TAKES_ARG (c) > (p[1] != 0))
+	      || WORD_SWITCH_TAKES_ARG (p))
+	    {
+	      int j = 0;
+	      int n_args = WORD_SWITCH_TAKES_ARG (p);
+
+	      if (n_args == 0)
+		{
+		  /* Count only the option arguments in separate argv elements.  */
+		  n_args = SWITCH_TAKES_ARG (c) - (p[1] != 0);
+		}
+	      if (i + n_args >= argc)
+		fatal ("argument to '-%s' is missing", p);
+	      switches[n_switches].args
+		= xmalloc ((n_args + 1) * sizeof(const char *));
+	      while (j < n_args)
+		switches[n_switches].args[j++] = argv[++i];
+	      /* Null-terminate the vector.  */
+	      switches[n_switches].args[j] = 0;
+	    }
+	  else if (strchr (switches_need_spaces, c))
+	    {
+	      /* On some systems, ld cannot handle some options without
+		 a space.  So split the option from its argument.  */
+	      char *part1 = xmalloc (2);
+	      part1[0] = c;
+	      part1[1] = '\0';
+
+	      switches[n_switches].part1 = part1;
+	      switches[n_switches].args = xmalloc (2 * sizeof (const char *));
+	      switches[n_switches].args[0] = xstrdup (p+1);
+	      switches[n_switches].args[1] = 0;
+	    }
+	  else
+	    switches[n_switches].args = 0;
+
+	  switches[n_switches].live_cond = SWITCH_OK;
+	  switches[n_switches].validated = 0;
+	  switches[n_switches].ordering = 0;
+	  /* These are always valid, since gcc.c itself understands them.  */
+	  if (!strcmp (p, "save-temps")
+	      || !strcmp (p, "static-libgcc")
+	      || !strcmp (p, "shared-libgcc")
+	      || !strcmp (p, "pipe"))
+	    switches[n_switches].validated = 1;
+	  else
+	    {
+	      char ch = switches[n_switches].part1[0];
+	      if (ch == 'B')
+		switches[n_switches].validated = 1;
+	    }
+	  n_switches++;
+	}
+      else
+	{
+#ifdef HAVE_TARGET_OBJECT_SUFFIX
+	  argv[i] = convert_filename (argv[i], 0, access (argv[i], F_OK));
+#endif
+
+	  if (strcmp (argv[i], "-") != 0 && access (argv[i], F_OK) < 0)
+	    {
+	      perror_with_name (argv[i]);
+	      error_count++;
+	    }
+	  else
+	    {
+	      infiles[n_infiles].language = spec_lang;
+	      infiles[n_infiles++].name = argv[i];
+	    }
+	}
+    }
+
+  if (n_infiles == last_language_n_infiles && spec_lang != 0)
+    error ("warning: '-x %s' after last input file has no effect", spec_lang);
+
+  /* Ensure we only invoke each subprocess once.  */
+  if (target_help_flag || print_help_list)
+    {
+      n_infiles = 1;
+
+      /* Create a dummy input file, so that we can pass --target-help on to
+	 the various sub-processes.  */
+      infiles[0].language = "c";
+      infiles[0].name   = "help-dummy";
+
+      if (target_help_flag)
+	{
+	  switches[n_switches].part1     = "--target-help";
+	  switches[n_switches].args      = 0;
+	  switches[n_switches].live_cond = SWITCH_OK;
+	  switches[n_switches].validated = 0;
+
+	  n_switches++;
+	}
+
+      if (print_help_list)
+	{
+	  switches[n_switches].part1     = "--help";
+	  switches[n_switches].args      = 0;
+	  switches[n_switches].live_cond = SWITCH_OK;
+	  switches[n_switches].validated = 0;
+
+	  n_switches++;
+	}
+    }
+
+  switches[n_switches].part1 = 0;
+  infiles[n_infiles].name = 0;
+}
+
+/* Store switches not filtered out by %<S in spec in COLLECT_GCC_OPTIONS
+   and place that in the environment.  */
+
+static void
+set_collect_gcc_options (void)
+{
+  int i;
+  int first_time;
+
+  /* Build COLLECT_GCC_OPTIONS to have all of the options specified to
+     the compiler.  */
+  obstack_grow (&collect_obstack, "COLLECT_GCC_OPTIONS=",
+		sizeof ("COLLECT_GCC_OPTIONS=") - 1);
+
+  first_time = TRUE;
+  for (i = 0; (int) i < n_switches; i++)
+    {
+      const char *const *args;
+      const char *p, *q;
+      if (!first_time)
+	obstack_grow (&collect_obstack, " ", 1);
+
+      first_time = FALSE;
+
+      /* Ignore elided switches.  */
+      if (switches[i].live_cond == SWITCH_IGNORE)
+	continue;
+
+      obstack_grow (&collect_obstack, "'-", 2);
+      q = switches[i].part1;
+      while ((p = strchr (q, '\'')))
+	{
+	  obstack_grow (&collect_obstack, q, p - q);
+	  obstack_grow (&collect_obstack, "'\\''", 4);
+	  q = ++p;
+	}
+      obstack_grow (&collect_obstack, q, strlen (q));
+      obstack_grow (&collect_obstack, "'", 1);
+
+      for (args = switches[i].args; args && *args; args++)
+	{
+	  obstack_grow (&collect_obstack, " '", 2);
+	  q = *args;
+	  while ((p = strchr (q, '\'')))
+	    {
+	      obstack_grow (&collect_obstack, q, p - q);
+	      obstack_grow (&collect_obstack, "'\\''", 4);
+	      q = ++p;
+	    }
+	  obstack_grow (&collect_obstack, q, strlen (q));
+	  obstack_grow (&collect_obstack, "'", 1);
+	}
+    }
+  obstack_grow (&collect_obstack, "\0", 1);
+  putenv (XOBFINISH (&collect_obstack, char *));
+}
+
+/* Process a spec string, accumulating and running commands.  */
+
+/* These variables describe the input file name.
+   input_file_number is the index on outfiles of this file,
+   so that the output file name can be stored for later use by %o.
+   input_basename is the start of the part of the input file
+   sans all directory names, and basename_length is the number
+   of characters starting there excluding the suffix .c or whatever.  */
+
+static const char *input_filename;
+static int input_file_number;
+size_t input_filename_length;
+static int basename_length;
+static int suffixed_basename_length;
+static const char *input_basename;
+static const char *input_suffix;
+#ifndef HOST_LACKS_INODE_NUMBERS
+static struct stat input_stat;
+#endif
+static int input_stat_set;
+
+/* The compiler used to process the current input file.  */
+static struct compiler *input_file_compiler;
+
+/* These are variables used within do_spec and do_spec_1.  */
+
+/* Nonzero if an arg has been started and not yet terminated
+   (with space, tab or newline).  */
+static int arg_going;
+
+/* Nonzero means %d or %g has been seen; the next arg to be terminated
+   is a temporary file name.  */
+static int delete_this_arg;
+
+/* Nonzero means %w has been seen; the next arg to be terminated
+   is the output file name of this compilation.  */
+static int this_is_output_file;
+
+/* Nonzero means %s has been seen; the next arg to be terminated
+   is the name of a library file and we should try the standard
+   search dirs for it.  */
+static int this_is_library_file;
+
+/* Nonzero means that the input of this command is coming from a pipe.  */
+static int input_from_pipe;
+
+/* Nonnull means substitute this for any suffix when outputting a switches
+   arguments.  */
+static const char *suffix_subst;
+
+/* Process the spec SPEC and run the commands specified therein.
+   Returns 0 if the spec is successfully processed; -1 if failed.  */
+
+int
+do_spec (const char *spec)
+{
+  int value;
+
+  value = do_spec_2 (spec);
+
+  /* Force out any unfinished command.
+     If -pipe, this forces out the last command if it ended in `|'.  */
+  if (value == 0)
+    {
+      if (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], "|"))
+	argbuf_index--;
+
+      set_collect_gcc_options ();
+
+      if (argbuf_index > 0)
+	value = execute ();
+    }
+
+  return value;
+}
+
+static int
+do_spec_2 (const char *spec)
+{
+  const char *string;
+  int result;
+
+  clear_args ();
+  arg_going = 0;
+  delete_this_arg = 0;
+  this_is_output_file = 0;
+  this_is_library_file = 0;
+  input_from_pipe = 0;
+  suffix_subst = NULL;
+
+  result = do_spec_1 (spec, 0, NULL);
+
+  /* End any pending argument.  */
+  if (arg_going)
+    {
+      obstack_1grow (&obstack, 0);
+      string = XOBFINISH (&obstack, const char *);
+      if (this_is_library_file)
+	string = find_file (string);
+      store_arg (string, delete_this_arg, this_is_output_file);
+      if (this_is_output_file)
+	outfiles[input_file_number] = string;
+      arg_going = 0;
+    }
+
+  return result;
+}
+
+
+/* Process the given spec string and add any new options to the end
+   of the switches/n_switches array.  */
+
+static void
+do_option_spec (const char *name, const char *spec)
+{
+  unsigned int i, value_count, value_len;
+  const char *p, *q, *value;
+  char *tmp_spec, *tmp_spec_p;
+
+  if (configure_default_options[0].name == NULL)
+    return;
+
+  for (i = 0; i < ARRAY_SIZE (configure_default_options); i++)
+    if (strcmp (configure_default_options[i].name, name) == 0)
+      break;
+  if (i == ARRAY_SIZE (configure_default_options))
+    return;
+
+  value = configure_default_options[i].value;
+  value_len = strlen (value);
+
+  /* Compute the size of the final spec.  */
+  value_count = 0;
+  p = spec;
+  while ((p = strstr (p, "%(VALUE)")) != NULL)
+    {
+      p ++;
+      value_count ++;
+    }
+
+  /* Replace each %(VALUE) by the specified value.  */
+  tmp_spec = alloca (strlen (spec) + 1
+		     + value_count * (value_len - strlen ("%(VALUE)")));
+  tmp_spec_p = tmp_spec;
+  q = spec;
+  while ((p = strstr (q, "%(VALUE)")) != NULL)
+    {
+      memcpy (tmp_spec_p, q, p - q);
+      tmp_spec_p = tmp_spec_p + (p - q);
+      memcpy (tmp_spec_p, value, value_len);
+      tmp_spec_p += value_len;
+      q = p + strlen ("%(VALUE)");
+    }
+  strcpy (tmp_spec_p, q);
+
+  do_self_spec (tmp_spec);
+}
+
+/* Process the given spec string and add any new options to the end
+   of the switches/n_switches array.  */
+
+static void
+do_self_spec (const char *spec)
+{
+  do_spec_2 (spec);
+  do_spec_1 (" ", 0, NULL);
+
+  if (argbuf_index > 0)
+    {
+      int i, first;
+
+      first = n_switches;
+      n_switches += argbuf_index;
+      switches = xrealloc (switches,
+			   sizeof (struct switchstr) * (n_switches + 1));
+
+      switches[n_switches] = switches[first];
+      for (i = 0; i < argbuf_index; i++)
+	{
+	  struct switchstr *sw;
+
+	  /* Each switch should start with '-'.  */
+	  if (argbuf[i][0] != '-')
+	    fatal ("switch '%s' does not start with '-'", argbuf[i]);
+
+	  sw = &switches[i + first];
+	  sw->part1 = &argbuf[i][1];
+	  sw->args = 0;
+	  sw->live_cond = SWITCH_OK;
+	  sw->validated = 0;
+	  sw->ordering = 0;
+	}
+    }
+}
+
+void
+do_spec_path (struct prefix_list *pl, const char *option,
+	      int omit_if_relative, int separate_options,
+	      int only_subdir,
+	      const char *dir_for_machine_suffix,
+	      const char *dir_for_no_suffix)
+{
+  static size_t bufsize = 0;
+  static char *buffer;
+  int idx;
+  bool multilib_p = false;
+
+  /* Used on systems which record the specified -L dirs
+     and use them to search for dynamic linking.  */
+  /* Relative directories always come from -B,
+     and it is better not to use them for searching
+     at run time.  In particular, stage1 loses.  */
+  if (omit_if_relative
+      && !IS_ABSOLUTE_PATH (pl->prefix))
+    return;
+
+  /* Try subdirectory if there is one.  */
+  if (machine_suffix && dir_for_machine_suffix)
+    {
+      if (strlen (pl->prefix) + strlen (machine_suffix)
+	  >= bufsize)
+	bufsize = (strlen (pl->prefix)
+		  + strlen (machine_suffix)) * 2 + 1;
+      buffer = xrealloc (buffer, bufsize);
+      strcpy (buffer, pl->prefix);
+      strcat (buffer, machine_suffix);
+      if (is_directory (buffer, dir_for_machine_suffix, 1))
+	{
+	  multilib_p = true;
+	  do_spec_1 (option, separate_options, NULL);
+	  if (separate_options)
+	    do_spec_1 (" ", 0, NULL);
+	  do_spec_1 (buffer, 1, NULL);
+	  do_spec_1 (dir_for_machine_suffix, 1, NULL);
+	  /* Make this a separate argument.  */
+	  do_spec_1 (" ", 0, NULL);
+	}
+    }
+  if (!pl->require_machine_suffix && dir_for_no_suffix)
+    {
+      if (is_directory (pl->prefix, dir_for_no_suffix, 1))
+	{
+	  multilib_p = true;
+	  do_spec_1 (option, separate_options, NULL);
+	  if (separate_options)
+	    do_spec_1 (" ", 0, NULL);
+	  do_spec_1 (pl->prefix, 1, NULL);
+	  do_spec_1 (dir_for_no_suffix, 1, NULL);
+	  /* Make this a separate argument.  */
+	  do_spec_1 (" ", 0, NULL);
+	}
+    }
+
+  if (only_subdir || multilib_p)
+    return;
+
+  if (machine_suffix)
+    {
+      if (is_directory (pl->prefix, machine_suffix, 1))
+	{
+	  do_spec_1 (option, separate_options, NULL);
+	  if (separate_options)
+	    do_spec_1 (" ", 0, NULL);
+	  do_spec_1 (pl->prefix, 1, NULL);
+	  /* Remove slash from machine_suffix.  */
+	  if (strlen (machine_suffix) >= bufsize)
+	    bufsize = strlen (machine_suffix) * 2 + 1;
+	  buffer = xrealloc (buffer, bufsize);
+	  strcpy (buffer, machine_suffix);
+	  idx = strlen (buffer);
+	  if (IS_DIR_SEPARATOR (buffer[idx - 1]))
+	    buffer[idx - 1] = 0;
+	  do_spec_1 (buffer, 1, NULL);
+	  /* Make this a separate argument.  */
+	  do_spec_1 (" ", 0, NULL);
+	}
+    }
+  if (!pl->require_machine_suffix)
+    {
+      if (is_directory (pl->prefix, "", 1))
+	{
+	  do_spec_1 (option, separate_options, NULL);
+	  if (separate_options)
+	    do_spec_1 (" ", 0, NULL);
+	  /* Remove slash from pl->prefix.  */
+	  if (strlen (pl->prefix) >= bufsize)
+	    bufsize = strlen (pl->prefix) * 2 + 1;
+	  buffer = xrealloc (buffer, bufsize);
+	  strcpy (buffer, pl->prefix);
+	  idx = strlen (buffer);
+	  if (IS_DIR_SEPARATOR (buffer[idx - 1]))
+	    buffer[idx - 1] = 0;
+	  do_spec_1 (buffer, 1, NULL);
+	  /* Make this a separate argument.  */
+	  do_spec_1 (" ", 0, NULL);
+	}
+    }
+}
+
+/* Process the sub-spec SPEC as a portion of a larger spec.
+   This is like processing a whole spec except that we do
+   not initialize at the beginning and we do not supply a
+   newline by default at the end.
+   INSWITCH nonzero means don't process %-sequences in SPEC;
+   in this case, % is treated as an ordinary character.
+   This is used while substituting switches.
+   INSWITCH nonzero also causes SPC not to terminate an argument.
+
+   Value is zero unless a line was finished
+   and the command on that line reported an error.  */
+
+static int
+do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
+{
+  const char *p = spec;
+  int c;
+  int i;
+  const char *string;
+  int value;
+
+  while ((c = *p++))
+    /* If substituting a switch, treat all chars like letters.
+       Otherwise, NL, SPC, TAB and % are special.  */
+    switch (inswitch ? 'a' : c)
+      {
+      case '\n':
+	/* End of line: finish any pending argument,
+	   then run the pending command if one has been started.  */
+	if (arg_going)
+	  {
+	    obstack_1grow (&obstack, 0);
+	    string = XOBFINISH (&obstack, const char *);
+	    if (this_is_library_file)
+	      string = find_file (string);
+	    store_arg (string, delete_this_arg, this_is_output_file);
+	    if (this_is_output_file)
+	      outfiles[input_file_number] = string;
+	  }
+	arg_going = 0;
+
+	if (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], "|"))
+	  {
+	    /* A `|' before the newline means use a pipe here,
+	       but only if -pipe was specified.
+	       Otherwise, execute now and don't pass the `|' as an arg.  */
+	    if (use_pipes)
+	      {
+		input_from_pipe = 1;
+		break;
+	      }
+	    else
+	      argbuf_index--;
+	  }
+
+	set_collect_gcc_options ();
+
+	if (argbuf_index > 0)
+	  {
+	    value = execute ();
+	    if (value)
+	      return value;
+	  }
+	/* Reinitialize for a new command, and for a new argument.  */
+	clear_args ();
+	arg_going = 0;
+	delete_this_arg = 0;
+	this_is_output_file = 0;
+	this_is_library_file = 0;
+	input_from_pipe = 0;
+	break;
+
+      case '|':
+	/* End any pending argument.  */
+	if (arg_going)
+	  {
+	    obstack_1grow (&obstack, 0);
+	    string = XOBFINISH (&obstack, const char *);
+	    if (this_is_library_file)
+	      string = find_file (string);
+	    store_arg (string, delete_this_arg, this_is_output_file);
+	    if (this_is_output_file)
+	      outfiles[input_file_number] = string;
+	  }
+
+	/* Use pipe */
+	obstack_1grow (&obstack, c);
+	arg_going = 1;
+	break;
+
+      case '\t':
+      case ' ':
+	/* Space or tab ends an argument if one is pending.  */
+	if (arg_going)
+	  {
+	    obstack_1grow (&obstack, 0);
+	    string = XOBFINISH (&obstack, const char *);
+	    if (this_is_library_file)
+	      string = find_file (string);
+	    store_arg (string, delete_this_arg, this_is_output_file);
+	    if (this_is_output_file)
+	      outfiles[input_file_number] = string;
+	  }
+	/* Reinitialize for a new argument.  */
+	arg_going = 0;
+	delete_this_arg = 0;
+	this_is_output_file = 0;
+	this_is_library_file = 0;
+	break;
+
+      case '%':
+	switch (c = *p++)
+	  {
+	  case 0:
+	    fatal ("spec '%s' invalid", spec);
+
+	  case 'b':
+	    obstack_grow (&obstack, input_basename, basename_length);
+	    arg_going = 1;
+	    break;
+
+	  case 'B':
+	    obstack_grow (&obstack, input_basename, suffixed_basename_length);
+	    arg_going = 1;
+	    break;
+
+	  case 'd':
+	    delete_this_arg = 2;
+	    break;
+
+	  /* Dump out the directories specified with LIBRARY_PATH,
+	     followed by the absolute directories
+	     that we search for startfiles.  */
+	  case 'D':
+	    {
+	      struct prefix_list *pl = startfile_prefixes.plist;
+
+	      for (; pl; pl = pl->next)
+		{
+		  const char *no_suffix_multilib_dir;
+
+		  no_suffix_multilib_dir = pl->os_multilib ? multilib_os_dir
+					   : multilib_dir;
+		  /* Do not separate options, include non-multilibbed variant.  */
+		  do_spec_path (pl, "-L",
+#ifdef RELATIVE_PREFIX_NOT_LINKDIR
+				1,
+#else
+				0,
+#endif
+				0, 0, multilib_dir, no_suffix_multilib_dir);
+		}
+	    }
+	    break;
+
+	  case 'e':
+	    /* %efoo means report an error with `foo' as error message
+	       and don't execute any more commands for this file.  */
+	    {
+	      const char *q = p;
+	      char *buf;
+	      while (*p != 0 && *p != '\n')
+		p++;
+	      buf = alloca (p - q + 1);
+	      strncpy (buf, q, p - q);
+	      buf[p - q] = 0;
+	      error ("%s", buf);
+	      return -1;
+	    }
+	    break;
+	  case 'n':
+	    /* %nfoo means report a notice with `foo' on stderr.  */
+	    {
+	      const char *q = p;
+	      char *buf;
+	      while (*p != 0 && *p != '\n')
+		p++;
+	      buf = alloca (p - q + 1);
+	      strncpy (buf, q, p - q);
+	      buf[p - q] = 0;
+	      notice ("%s\n", buf);
+	      if (*p)
+		p++;
+	    }
+	    break;
+
+	  case 'j':
+	    {
+	      struct stat st;
+
+	      /* If save_temps_flag is off, and the HOST_BIT_BUCKET is
+		 defined, and it is not a directory, and it is
+		 writable, use it.  Otherwise, treat this like any
+		 other temporary file.  */
+
+	      if ((!save_temps_flag)
+		  && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))
+		  && (access (HOST_BIT_BUCKET, W_OK) == 0))
+		{
+		  obstack_grow (&obstack, HOST_BIT_BUCKET,
+				strlen (HOST_BIT_BUCKET));
+		  delete_this_arg = 0;
+		  arg_going = 1;
+		  break;
+		}
+	    }
+	    goto create_temp_file;
+	  case '|':
+	    if (use_pipes)
+	      {
+		obstack_1grow (&obstack, '-');
+		delete_this_arg = 0;
+		arg_going = 1;
+
+		/* consume suffix */
+		while (*p == '.' || ISALNUM ((unsigned char) *p))
+		  p++;
+		if (p[0] == '%' && p[1] == 'O')
+		  p += 2;
+
+		break;
+	      }
+	    goto create_temp_file;
+	  case 'm':
+	    if (use_pipes)
+	      {
+		/* consume suffix */
+		while (*p == '.' || ISALNUM ((unsigned char) *p))
+		  p++;
+		if (p[0] == '%' && p[1] == 'O')
+		  p += 2;
+
+		break;
+	      }
+	    goto create_temp_file;
+	  case 'g':
+	  case 'u':
+	  case 'U':
+	  create_temp_file:
+	      {
+		struct temp_name *t;
+		int suffix_length;
+		const char *suffix = p;
+		char *saved_suffix = NULL;
+
+		while (*p == '.' || ISALNUM ((unsigned char) *p))
+		  p++;
+		suffix_length = p - suffix;
+		if (p[0] == '%' && p[1] == 'O')
+		  {
+		    p += 2;
+		    /* We don't support extra suffix characters after %O.  */
+		    if (*p == '.' || ISALNUM ((unsigned char) *p))
+		      fatal ("spec '%s' has invalid '%%0%c'", spec, *p);
+		    if (suffix_length == 0)
+		      suffix = TARGET_OBJECT_SUFFIX;
+		    else
+		      {
+			saved_suffix
+			  = xmalloc (suffix_length
+				     + strlen (TARGET_OBJECT_SUFFIX));
+			strncpy (saved_suffix, suffix, suffix_length);
+			strcpy (saved_suffix + suffix_length,
+				TARGET_OBJECT_SUFFIX);
+		      }
+		    suffix_length += strlen (TARGET_OBJECT_SUFFIX);
+		  }
+
+		/* If the input_filename has the same suffix specified
+		   for the %g, %u, or %U, and -save-temps is specified,
+		   we could end up using that file as an intermediate
+		   thus clobbering the user's source file (.e.g.,
+		   gcc -save-temps foo.s would clobber foo.s with the
+		   output of cpp0).  So check for this condition and
+		   generate a temp file as the intermediate.  */
+
+		if (save_temps_flag)
+		  {
+		    temp_filename_length = basename_length + suffix_length;
+		    temp_filename = alloca (temp_filename_length + 1);
+		    strncpy ((char *) temp_filename, input_basename, basename_length);
+		    strncpy ((char *) temp_filename + basename_length, suffix,
+			     suffix_length);
+		    *((char *) temp_filename + temp_filename_length) = '\0';
+		    if (strcmp (temp_filename, input_filename) != 0)
+		      {
+#ifndef HOST_LACKS_INODE_NUMBERS
+			struct stat st_temp;
+
+			/* Note, set_input() resets input_stat_set to 0.  */
+			if (input_stat_set == 0)
+			  {
+			    input_stat_set = stat (input_filename, &input_stat);
+			    if (input_stat_set >= 0)
+			      input_stat_set = 1;
+			  }
+
+			/* If we have the stat for the input_filename
+			   and we can do the stat for the temp_filename
+			   then the they could still refer to the same
+			   file if st_dev/st_ino's are the same.  */
+			if (input_stat_set != 1
+			    || stat (temp_filename, &st_temp) < 0
+			    || input_stat.st_dev != st_temp.st_dev
+			    || input_stat.st_ino != st_temp.st_ino)
+#else
+			/* Just compare canonical pathnames.  */
+			char* input_realname = lrealpath (input_filename);
+			char* temp_realname = lrealpath (temp_filename);
+			bool files_differ = strcmp (input_realname, temp_realname);
+			free (input_realname);
+			free (temp_realname);
+			if (files_differ)
+#endif
+			  {
+			    temp_filename = save_string (temp_filename,
+							 temp_filename_length + 1);
+			    obstack_grow (&obstack, temp_filename,
+						    temp_filename_length);
+			    arg_going = 1;
+			    delete_this_arg = 0;
+			    break;
+			  }
+		      }
+		  }
+
+		/* See if we already have an association of %g/%u/%U and
+		   suffix.  */
+		for (t = temp_names; t; t = t->next)
+		  if (t->length == suffix_length
+		      && strncmp (t->suffix, suffix, suffix_length) == 0
+		      && t->unique == (c == 'u' || c == 'U' || c == 'j'))
+		    break;
+
+		/* Make a new association if needed.  %u and %j
+		   require one.  */
+		if (t == 0 || c == 'u' || c == 'j')
+		  {
+		    if (t == 0)
+		      {
+			t = xmalloc (sizeof (struct temp_name));
+			t->next = temp_names;
+			temp_names = t;
+		      }
+		    t->length = suffix_length;
+		    if (saved_suffix)
+		      {
+			t->suffix = saved_suffix;
+			saved_suffix = NULL;
+		      }
+		    else
+		      t->suffix = save_string (suffix, suffix_length);
+		    t->unique = (c == 'u' || c == 'U' || c == 'j');
+		    temp_filename = make_temp_file (t->suffix);
+		    temp_filename_length = strlen (temp_filename);
+		    t->filename = temp_filename;
+		    t->filename_length = temp_filename_length;
+		  }
+
+		if (saved_suffix)
+		  free (saved_suffix);
+
+		obstack_grow (&obstack, t->filename, t->filename_length);
+		delete_this_arg = 1;
+	      }
+	    arg_going = 1;
+	    break;
+
+	  case 'i':
+	    if (combine_inputs)
+	      {
+		for (i = 0; (int) i < n_infiles; i++)
+		  if ((!infiles[i].language) || (infiles[i].language[0] != '*'))
+		    if (infiles[i].incompiler == input_file_compiler)
+		      {
+			store_arg (infiles[i].name, 0, 0);
+			infiles[i].compiled = true;
+		      }
+	      }
+	    else
+	      {
+		obstack_grow (&obstack, input_filename, input_filename_length);
+		arg_going = 1;
+	      }
+	    break;
+
+	  case 'I':
+	    {
+	      struct prefix_list *pl = include_prefixes.plist;
+
+	      if (gcc_exec_prefix)
+		{
+		  do_spec_1 ("-iprefix", 1, NULL);
+		  /* Make this a separate argument.  */
+		  do_spec_1 (" ", 0, NULL);
+		  do_spec_1 (gcc_exec_prefix, 1, NULL);
+		  do_spec_1 (" ", 0, NULL);
+		}
+
+	      if (target_system_root_changed ||
+		  (target_system_root && target_sysroot_hdrs_suffix))
+		{
+		  do_spec_1 ("-isysroot", 1, NULL);
+		  /* Make this a separate argument.  */
+		  do_spec_1 (" ", 0, NULL);
+		  do_spec_1 (target_system_root, 1, NULL);
+		  if (target_sysroot_hdrs_suffix)
+		    do_spec_1 (target_sysroot_hdrs_suffix, 1, NULL);
+		  do_spec_1 (" ", 0, NULL);
+		}
+
+	      for (; pl; pl = pl->next)
+		/* Separate options, don't include non-suffixed variant.  */
+		do_spec_path (pl, "-isystem", 0, 1, 1, "include", "include");
+	    }
+	    break;
+
+	  case 'o':
+	    {
+	      int max = n_infiles;
+	      max += lang_specific_extra_outfiles;
+
+	      for (i = 0; i < max; i++)
+		if (outfiles[i])
+		  store_arg (outfiles[i], 0, 0);
+	      break;
+	    }
+
+	  case 'O':
+	    obstack_grow (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX));
+	    arg_going = 1;
+	    break;
+
+	  case 's':
+	    this_is_library_file = 1;
+	    break;
+
+	  case 'V':
+	    outfiles[input_file_number] = NULL;
+	    break;
+
+	  case 'w':
+	    this_is_output_file = 1;
+	    break;
+
+	  case 'W':
+	    {
+	      int cur_index = argbuf_index;
+	      /* Handle the {...} following the %W.  */
+	      if (*p != '{')
+		fatal ("spec '%s' has invalid '%%W%c", spec, *p);
+	      p = handle_braces (p + 1);
+	      if (p == 0)
+		return -1;
+	      /* End any pending argument.  */
+	      if (arg_going)
+		{
+		  obstack_1grow (&obstack, 0);
+		  string = XOBFINISH (&obstack, const char *);
+		  if (this_is_library_file)
+		    string = find_file (string);
+		  store_arg (string, delete_this_arg, this_is_output_file);
+		  if (this_is_output_file)
+		    outfiles[input_file_number] = string;
+		  arg_going = 0;
+		}
+	      /* If any args were output, mark the last one for deletion
+		 on failure.  */
+	      if (argbuf_index != cur_index)
+		record_temp_file (argbuf[argbuf_index - 1], 0, 1);
+	      break;
+	    }
+
+	  /* %x{OPTION} records OPTION for %X to output.  */
+	  case 'x':
+	    {
+	      const char *p1 = p;
+	      char *string;
+
+	      /* Skip past the option value and make a copy.  */
+	      if (*p != '{')
+		fatal ("spec '%s' has invalid '%%x%c'", spec, *p);
+	      while (*p++ != '}')
+		;
+	      string = save_string (p1 + 1, p - p1 - 2);
+
+	      /* See if we already recorded this option.  */
+	      for (i = 0; i < n_linker_options; i++)
+		if (! strcmp (string, linker_options[i]))
+		  {
+		    free (string);
+		    return 0;
+		  }
+
+	      /* This option is new; add it.  */
+	      add_linker_option (string, strlen (string));
+	    }
+	    break;
+
+	  /* Dump out the options accumulated previously using %x.  */
+	  case 'X':
+	    for (i = 0; i < n_linker_options; i++)
+	      {
+		do_spec_1 (linker_options[i], 1, NULL);
+		/* Make each accumulated option a separate argument.  */
+		do_spec_1 (" ", 0, NULL);
+	      }
+	    break;
+
+	  /* Dump out the options accumulated previously using -Wa,.  */
+	  case 'Y':
+	    for (i = 0; i < n_assembler_options; i++)
+	      {
+		do_spec_1 (assembler_options[i], 1, NULL);
+		/* Make each accumulated option a separate argument.  */
+		do_spec_1 (" ", 0, NULL);
+	      }
+	    break;
+
+	  /* Dump out the options accumulated previously using -Wp,.  */
+	  case 'Z':
+	    for (i = 0; i < n_preprocessor_options; i++)
+	      {
+		do_spec_1 (preprocessor_options[i], 1, NULL);
+		/* Make each accumulated option a separate argument.  */
+		do_spec_1 (" ", 0, NULL);
+	      }
+	    break;
+
+	    /* Here are digits and numbers that just process
+	       a certain constant string as a spec.  */
+
+	  case '1':
+	    value = do_spec_1 (cc1_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case '2':
+	    value = do_spec_1 (cc1plus_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'a':
+	    value = do_spec_1 (asm_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'A':
+	    value = do_spec_1 (asm_final_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'C':
+	    {
+	      const char *const spec
+		= (input_file_compiler->cpp_spec
+		   ? input_file_compiler->cpp_spec
+		   : cpp_spec);
+	      value = do_spec_1 (spec, 0, NULL);
+	      if (value != 0)
+		return value;
+	    }
+	    break;
+
+	  case 'E':
+	    value = do_spec_1 (endfile_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'l':
+	    value = do_spec_1 (link_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'L':
+	    value = do_spec_1 (lib_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'G':
+	    value = do_spec_1 (libgcc_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	  case 'R':
+	    /* We assume there is a directory
+	       separator at the end of this string.  */
+	    if (target_system_root)
+	      {
+	        obstack_grow (&obstack, target_system_root,
+			      strlen (target_system_root));
+		if (target_sysroot_suffix)
+		  obstack_grow (&obstack, target_sysroot_suffix,
+				strlen (target_sysroot_suffix));
+	      }
+	    break;
+
+	  case 'S':
+	    value = do_spec_1 (startfile_spec, 0, NULL);
+	    if (value != 0)
+	      return value;
+	    break;
+
+	    /* Here we define characters other than letters and digits.  */
+
+	  case '{':
+	    p = handle_braces (p);
+	    if (p == 0)
+	      return -1;
+	    break;
+
+	  case ':':
+	    p = handle_spec_function (p);
+	    if (p == 0)
+	      return -1;
+	    break;
+
+	  case '%':
+	    obstack_1grow (&obstack, '%');
+	    break;
+
+	  case '.':
+	    {
+	      unsigned len = 0;
+
+	      while (p[len] && p[len] != ' ' && p[len] != '%')
+		len++;
+	      suffix_subst = save_string (p - 1, len + 1);
+	      p += len;
+	    }
+	   break;
+
+	   /* Henceforth ignore the option(s) matching the pattern
+	      after the %<.  */
+	  case '<':
+	    {
+	      unsigned len = 0;
+	      int have_wildcard = 0;
+	      int i;
+
+	      while (p[len] && p[len] != ' ' && p[len] != '\t')
+		len++;
+
+	      if (p[len-1] == '*')
+		have_wildcard = 1;
+
+	      for (i = 0; i < n_switches; i++)
+		if (!strncmp (switches[i].part1, p, len - have_wildcard)
+		    && (have_wildcard || switches[i].part1[len] == '\0'))
+		  {
+		    switches[i].live_cond = SWITCH_IGNORE;
+		    switches[i].validated = 1;
+		  }
+
+	      p += len;
+	    }
+	    break;
+
+	  case '*':
+	    if (soft_matched_part)
+	      {
+		do_spec_1 (soft_matched_part, 1, NULL);
+		do_spec_1 (" ", 0, NULL);
+	      }
+	    else
+	      /* Catch the case where a spec string contains something like
+		 '%{foo:%*}'.  i.e. there is no * in the pattern on the left
+		 hand side of the :.  */
+	      error ("spec failure: '%%*' has not been initialized by pattern match");
+	    break;
+
+	    /* Process a string found as the value of a spec given by name.
+	       This feature allows individual machine descriptions
+	       to add and use their own specs.
+	       %[...] modifies -D options the way %P does;
+	       %(...) uses the spec unmodified.  */
+	  case '[':
+	    error ("warning: use of obsolete %%[ operator in specs");
+	  case '(':
+	    {
+	      const char *name = p;
+	      struct spec_list *sl;
+	      int len;
+
+	      /* The string after the S/P is the name of a spec that is to be
+		 processed.  */
+	      while (*p && *p != ')' && *p != ']')
+		p++;
+
+	      /* See if it's in the list.  */
+	      for (len = p - name, sl = specs; sl; sl = sl->next)
+		if (sl->name_len == len && !strncmp (sl->name, name, len))
+		  {
+		    name = *(sl->ptr_spec);
+#ifdef DEBUG_SPECS
+		    notice ("Processing spec %c%s%c, which is '%s'\n",
+			    c, sl->name, (c == '(') ? ')' : ']', name);
+#endif
+		    break;
+		  }
+
+	      if (sl)
+		{
+		  if (c == '(')
+		    {
+		      value = do_spec_1 (name, 0, NULL);
+		      if (value != 0)
+			return value;
+		    }
+		  else
+		    {
+		      char *x = alloca (strlen (name) * 2 + 1);
+		      char *buf = x;
+		      const char *y = name;
+		      int flag = 0;
+
+		      /* Copy all of NAME into BUF, but put __ after
+			 every -D and at the end of each arg.  */
+		      while (1)
+			{
+			  if (! strncmp (y, "-D", 2))
+			    {
+			      *x++ = '-';
+			      *x++ = 'D';
+			      *x++ = '_';
+			      *x++ = '_';
+			      y += 2;
+			      flag = 1;
+			      continue;
+			    }
+			  else if (flag
+				   && (*y == ' ' || *y == '\t' || *y == '='
+				       || *y == '}' || *y == 0))
+			    {
+			      *x++ = '_';
+			      *x++ = '_';
+			      flag = 0;
+			    }
+			  if (*y == 0)
+			    break;
+			  else
+			    *x++ = *y++;
+			}
+		      *x = 0;
+
+		      value = do_spec_1 (buf, 0, NULL);
+		      if (value != 0)
+			return value;
+		    }
+		}
+
+	      /* Discard the closing paren or bracket.  */
+	      if (*p)
+		p++;
+	    }
+	    break;
+
+	  default:
+	    error ("spec failure: unrecognized spec option '%c'", c);
+	    break;
+	  }
+	break;
+
+      case '\\':
+	/* Backslash: treat next character as ordinary.  */
+	c = *p++;
+
+	/* Fall through.  */
+      default:
+	/* Ordinary character: put it into the current argument.  */
+	obstack_1grow (&obstack, c);
+	arg_going = 1;
+      }
+
+  /* End of string.  If we are processing a spec function, we need to
+     end any pending argument.  */
+  if (processing_spec_function && arg_going)
+    {
+      obstack_1grow (&obstack, 0);
+      string = XOBFINISH (&obstack, const char *);
+      if (this_is_library_file)
+        string = find_file (string);
+      store_arg (string, delete_this_arg, this_is_output_file);
+      if (this_is_output_file)
+        outfiles[input_file_number] = string;
+      arg_going = 0;
+    }
+
+  return 0;
+}
+
+/* Look up a spec function.  */
+
+static const struct spec_function *
+lookup_spec_function (const char *name)
+{
+  static const struct spec_function * const spec_function_tables[] =
+  {
+    static_spec_functions,
+    lang_specific_spec_functions,
+  };
+  const struct spec_function *sf;
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (spec_function_tables); i++)
+    {
+      for (sf = spec_function_tables[i]; sf->name != NULL; sf++)
+	if (strcmp (sf->name, name) == 0)
+	  return sf;
+    }
+
+  return NULL;
+}
+
+/* Evaluate a spec function.  */
+
+static const char *
+eval_spec_function (const char *func, const char *args)
+{
+  const struct spec_function *sf;
+  const char *funcval;
+
+  /* Saved spec processing context.  */
+  int save_argbuf_index;
+  int save_argbuf_length;
+  const char **save_argbuf;
+
+  int save_arg_going;
+  int save_delete_this_arg;
+  int save_this_is_output_file;
+  int save_this_is_library_file;
+  int save_input_from_pipe;
+  const char *save_suffix_subst;
+
+
+  sf = lookup_spec_function (func);
+  if (sf == NULL)
+    fatal ("unknown spec function '%s'", func);
+
+  /* Push the spec processing context.  */
+  save_argbuf_index = argbuf_index;
+  save_argbuf_length = argbuf_length;
+  save_argbuf = argbuf;
+
+  save_arg_going = arg_going;
+  save_delete_this_arg = delete_this_arg;
+  save_this_is_output_file = this_is_output_file;
+  save_this_is_library_file = this_is_library_file;
+  save_input_from_pipe = input_from_pipe;
+  save_suffix_subst = suffix_subst;
+
+  /* Create a new spec processing context, and build the function
+     arguments.  */
+
+  alloc_args ();
+  if (do_spec_2 (args) < 0)
+    fatal ("error in args to spec function '%s'", func);
+
+  /* argbuf_index is an index for the next argument to be inserted, and
+     so contains the count of the args already inserted.  */
+
+  funcval = (*sf->func) (argbuf_index, argbuf);
+
+  /* Pop the spec processing context.  */
+  argbuf_index = save_argbuf_index;
+  argbuf_length = save_argbuf_length;
+  free (argbuf);
+  argbuf = save_argbuf;
+
+  arg_going = save_arg_going;
+  delete_this_arg = save_delete_this_arg;
+  this_is_output_file = save_this_is_output_file;
+  this_is_library_file = save_this_is_library_file;
+  input_from_pipe = save_input_from_pipe;
+  suffix_subst = save_suffix_subst;
+
+  return funcval;
+}
+
+/* Handle a spec function call of the form:
+
+   %:function(args)
+
+   ARGS is processed as a spec in a separate context and split into an
+   argument vector in the normal fashion.  The function returns a string
+   containing a spec which we then process in the caller's context, or
+   NULL if no processing is required.  */
+
+static const char *
+handle_spec_function (const char *p)
+{
+  char *func, *args;
+  const char *endp, *funcval;
+  int count;
+
+  processing_spec_function++;
+
+  /* Get the function name.  */
+  for (endp = p; *endp != '\0'; endp++)
+    {
+      if (*endp == '(')		/* ) */
+        break;
+      /* Only allow [A-Za-z0-9], -, and _ in function names.  */
+      if (!ISALNUM (*endp) && !(*endp == '-' || *endp == '_'))
+	fatal ("malformed spec function name");
+    }
+  if (*endp != '(')		/* ) */
+    fatal ("no arguments for spec function");
+  func = save_string (p, endp - p);
+  p = ++endp;
+
+  /* Get the arguments.  */
+  for (count = 0; *endp != '\0'; endp++)
+    {
+      /* ( */
+      if (*endp == ')')
+	{
+	  if (count == 0)
+	    break;
+	  count--;
+	}
+      else if (*endp == '(')	/* ) */
+	count++;
+    }
+  /* ( */
+  if (*endp != ')')
+    fatal ("malformed spec function arguments");
+  args = save_string (p, endp - p);
+  p = ++endp;
+
+  /* p now points to just past the end of the spec function expression.  */
+
+  funcval = eval_spec_function (func, args);
+  if (funcval != NULL && do_spec_1 (funcval, 0, NULL) < 0)
+    p = NULL;
+
+  free (func);
+  free (args);
+
+  processing_spec_function--;
+
+  return p;
+}
+
+/* Inline subroutine of handle_braces.  Returns true if the current
+   input suffix matches the atom bracketed by ATOM and END_ATOM.  */
+static inline bool
+input_suffix_matches (const char *atom, const char *end_atom)
+{
+  /* We special case the semantics of {.s:...} and {.S:...} and their
+     negative variants.  Instead of testing the input filename suffix,
+     we test whether the input source file is an assembler file or an
+     assembler-with-cpp file respectively.  This allows us to correctly
+     handle the -x command line option.  */
+
+  if (atom + 1 == end_atom
+      && input_file_compiler
+      && input_file_compiler->suffix)
+    {
+      if (*atom == 's')
+	return !strcmp (input_file_compiler->suffix, "@assembler");
+      if (*atom == 'S')
+	return !strcmp (input_file_compiler->suffix, "@assembler-with-cpp");
+    }
+
+  return (input_suffix
+	  && !strncmp (input_suffix, atom, end_atom - atom)
+	  && input_suffix[end_atom - atom] == '\0');
+}
+
+/* Inline subroutine of handle_braces.  Returns true if a switch
+   matching the atom bracketed by ATOM and END_ATOM appeared on the
+   command line.  */
+static inline bool
+switch_matches (const char *atom, const char *end_atom, int starred)
+{
+  int i;
+  int len = end_atom - atom;
+  int plen = starred ? len : -1;
+
+  for (i = 0; i < n_switches; i++)
+    if (!strncmp (switches[i].part1, atom, len)
+	&& (starred || switches[i].part1[len] == '\0')
+	&& check_live_switch (i, plen))
+      return true;
+
+  return false;
+}
+
+/* Inline subroutine of handle_braces.  Mark all of the switches which
+   match ATOM (extends to END_ATOM; STARRED indicates whether there
+   was a star after the atom) for later processing.  */
+static inline void
+mark_matching_switches (const char *atom, const char *end_atom, int starred)
+{
+  int i;
+  int len = end_atom - atom;
+  int plen = starred ? len : -1;
+
+  for (i = 0; i < n_switches; i++)
+    if (!strncmp (switches[i].part1, atom, len)
+	&& (starred || switches[i].part1[len] == '\0')
+	&& check_live_switch (i, plen))
+      switches[i].ordering = 1;
+}
+
+/* Inline subroutine of handle_braces.  Process all the currently
+   marked switches through give_switch, and clear the marks.  */
+static inline void
+process_marked_switches (void)
+{
+  int i;
+
+  for (i = 0; i < n_switches; i++)
+    if (switches[i].ordering == 1)
+      {
+	switches[i].ordering = 0;
+	give_switch (i, 0);
+      }
+}
+
+/* Handle a %{ ... } construct.  P points just inside the leading {.
+   Returns a pointer one past the end of the brace block, or 0
+   if we call do_spec_1 and that returns -1.  */
+
+static const char *
+handle_braces (const char *p)
+{
+  const char *atom, *end_atom;
+  const char *d_atom = NULL, *d_end_atom = NULL;
+  const char *orig = p;
+
+  bool a_is_suffix;
+  bool a_is_starred;
+  bool a_is_negated;
+  bool a_matched;
+
+  bool a_must_be_last = false;
+  bool ordered_set    = false;
+  bool disjunct_set   = false;
+  bool disj_matched   = false;
+  bool disj_starred   = true;
+  bool n_way_choice   = false;
+  bool n_way_matched  = false;
+
+#define SKIP_WHITE() do { while (*p == ' ' || *p == '\t') p++; } while (0)
+
+  do
+    {
+      if (a_must_be_last)
+	goto invalid;
+
+      /* Scan one "atom" (S in the description above of %{}, possibly
+	 with !, ., or * modifiers).  */
+      a_matched = a_is_suffix = a_is_starred = a_is_negated = false;
+
+      SKIP_WHITE();
+      if (*p == '!')
+	p++, a_is_negated = true;
+
+      SKIP_WHITE();
+      if (*p == '.')
+	p++, a_is_suffix = true;
+
+      atom = p;
+      while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='
+	     || *p == ',' || *p == '.' || *p == '@')
+	p++;
+      end_atom = p;
+
+      if (*p == '*')
+	p++, a_is_starred = 1;
+
+      SKIP_WHITE();
+      switch (*p)
+	{
+	case '&': case '}':
+	  /* Substitute the switch(es) indicated by the current atom.  */
+	  ordered_set = true;
+	  if (disjunct_set || n_way_choice || a_is_negated || a_is_suffix
+	      || atom == end_atom)
+	    goto invalid;
+
+	  mark_matching_switches (atom, end_atom, a_is_starred);
+
+	  if (*p == '}')
+	    process_marked_switches ();
+	  break;
+
+	case '|': case ':':
+	  /* Substitute some text if the current atom appears as a switch
+	     or suffix.  */
+	  disjunct_set = true;
+	  if (ordered_set)
+	    goto invalid;
+
+	  if (atom == end_atom)
+	    {
+	      if (!n_way_choice || disj_matched || *p == '|'
+		  || a_is_negated || a_is_suffix || a_is_starred)
+		goto invalid;
+
+	      /* An empty term may appear as the last choice of an
+		 N-way choice set; it means "otherwise".  */
+	      a_must_be_last = true;
+	      disj_matched = !n_way_matched;
+	      disj_starred = false;
+	    }
+	  else
+	    {
+	       if (a_is_suffix && a_is_starred)
+		 goto invalid;
+
+	       if (!a_is_starred)
+		 disj_starred = false;
+
+	       /* Don't bother testing this atom if we already have a
+                  match.  */
+	       if (!disj_matched && !n_way_matched)
+		 {
+		   if (a_is_suffix)
+		     a_matched = input_suffix_matches (atom, end_atom);
+		   else
+		     a_matched = switch_matches (atom, end_atom, a_is_starred);
+
+		   if (a_matched != a_is_negated)
+		     {
+		       disj_matched = true;
+		       d_atom = atom;
+		       d_end_atom = end_atom;
+		     }
+		 }
+	    }
+
+	  if (*p == ':')
+	    {
+	      /* Found the body, that is, the text to substitute if the
+		 current disjunction matches.  */
+	      p = process_brace_body (p + 1, d_atom, d_end_atom, disj_starred,
+				      disj_matched && !n_way_matched);
+	      if (p == 0)
+		return 0;
+
+	      /* If we have an N-way choice, reset state for the next
+		 disjunction.  */
+	      if (*p == ';')
+		{
+		  n_way_choice = true;
+		  n_way_matched |= disj_matched;
+		  disj_matched = false;
+		  disj_starred = true;
+		  d_atom = d_end_atom = NULL;
+		}
+	    }
+	  break;
+
+	default:
+	  goto invalid;
+	}
+    }
+  while (*p++ != '}');
+
+  return p;
+
+ invalid:
+  fatal ("braced spec '%s' is invalid at '%c'", orig, *p);
+
+#undef SKIP_WHITE
+}
+
+/* Subroutine of handle_braces.  Scan and process a brace substitution body
+   (X in the description of %{} syntax).  P points one past the colon;
+   ATOM and END_ATOM bracket the first atom which was found to be true
+   (present) in the current disjunction; STARRED indicates whether all
+   the atoms in the current disjunction were starred (for syntax validation);
+   MATCHED indicates whether the disjunction matched or not, and therefore
+   whether or not the body is to be processed through do_spec_1 or just
+   skipped.  Returns a pointer to the closing } or ;, or 0 if do_spec_1
+   returns -1.  */
+
+static const char *
+process_brace_body (const char *p, const char *atom, const char *end_atom,
+		    int starred, int matched)
+{
+  const char *body, *end_body;
+  unsigned int nesting_level;
+  bool have_subst     = false;
+
+  /* Locate the closing } or ;, honoring nested braces.
+     Trim trailing whitespace.  */
+  body = p;
+  nesting_level = 1;
+  for (;;)
+    {
+      if (*p == '{')
+	nesting_level++;
+      else if (*p == '}')
+	{
+	  if (!--nesting_level)
+	    break;
+	}
+      else if (*p == ';' && nesting_level == 1)
+	break;
+      else if (*p == '%' && p[1] == '*' && nesting_level == 1)
+	have_subst = true;
+      else if (*p == '\0')
+	goto invalid;
+      p++;
+    }
+
+  end_body = p;
+  while (end_body[-1] == ' ' || end_body[-1] == '\t')
+    end_body--;
+
+  if (have_subst && !starred)
+    goto invalid;
+
+  if (matched)
+    {
+      /* Copy the substitution body to permanent storage and execute it.
+	 If have_subst is false, this is a simple matter of running the
+	 body through do_spec_1...  */
+      char *string = save_string (body, end_body - body);
+      if (!have_subst)
+	{
+	  if (do_spec_1 (string, 0, NULL) < 0)
+	    return 0;
+	}
+      else
+	{
+	  /* ... but if have_subst is true, we have to process the
+	     body once for each matching switch, with %* set to the
+	     variant part of the switch.  */
+	  unsigned int hard_match_len = end_atom - atom;
+	  int i;
+
+	  for (i = 0; i < n_switches; i++)
+	    if (!strncmp (switches[i].part1, atom, hard_match_len)
+		&& check_live_switch (i, hard_match_len))
+	      {
+		if (do_spec_1 (string, 0,
+			       &switches[i].part1[hard_match_len]) < 0)
+		  return 0;
+		/* Pass any arguments this switch has.  */
+		give_switch (i, 1);
+		suffix_subst = NULL;
+	      }
+	}
+    }
+
+  return p;
+
+ invalid:
+  fatal ("braced spec body '%s' is invalid", body);
+}
+
+/* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch
+   on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}
+   spec, or -1 if either exact match or %* is used.
+
+   A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch
+   whose value does not begin with "no-" is obsoleted by the same value
+   with the "no-", similarly for a switch with the "no-" prefix.  */
+
+static int
+check_live_switch (int switchnum, int prefix_length)
+{
+  const char *name = switches[switchnum].part1;
+  int i;
+
+  /* In the common case of {<at-most-one-letter>*}, a negating
+     switch would always match, so ignore that case.  We will just
+     send the conflicting switches to the compiler phase.  */
+  if (prefix_length >= 0 && prefix_length <= 1)
+    return 1;
+
+  /* If we already processed this switch and determined if it was
+     live or not, return our past determination.  */
+  if (switches[switchnum].live_cond != 0)
+    return switches[switchnum].live_cond > 0;
+
+  /* Now search for duplicate in a manner that depends on the name.  */
+  switch (*name)
+    {
+    case 'O':
+      for (i = switchnum + 1; i < n_switches; i++)
+	if (switches[i].part1[0] == 'O')
+	  {
+	    switches[switchnum].validated = 1;
+	    switches[switchnum].live_cond = SWITCH_FALSE;
+	    return 0;
+	  }
+      break;
+
+    case 'W':  case 'f':  case 'm':
+      if (! strncmp (name + 1, "no-", 3))
+	{
+	  /* We have Xno-YYY, search for XYYY.  */
+	  for (i = switchnum + 1; i < n_switches; i++)
+	    if (switches[i].part1[0] == name[0]
+		&& ! strcmp (&switches[i].part1[1], &name[4]))
+	      {
+		switches[switchnum].validated = 1;
+		switches[switchnum].live_cond = SWITCH_FALSE;
+		return 0;
+	      }
+	}
+      else
+	{
+	  /* We have XYYY, search for Xno-YYY.  */
+	  for (i = switchnum + 1; i < n_switches; i++)
+	    if (switches[i].part1[0] == name[0]
+		&& switches[i].part1[1] == 'n'
+		&& switches[i].part1[2] == 'o'
+		&& switches[i].part1[3] == '-'
+		&& !strcmp (&switches[i].part1[4], &name[1]))
+	      {
+		switches[switchnum].validated = 1;
+		switches[switchnum].live_cond = SWITCH_FALSE;
+		return 0;
+	      }
+	}
+      break;
+    }
+
+  /* Otherwise the switch is live.  */
+  switches[switchnum].live_cond = SWITCH_LIVE;
+  return 1;
+}
+
+/* Pass a switch to the current accumulating command
+   in the same form that we received it.
+   SWITCHNUM identifies the switch; it is an index into
+   the vector of switches gcc received, which is `switches'.
+   This cannot fail since it never finishes a command line.
+
+   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */
+
+static void
+give_switch (int switchnum, int omit_first_word)
+{
+  if (switches[switchnum].live_cond == SWITCH_IGNORE)
+    return;
+
+  if (!omit_first_word)
+    {
+      do_spec_1 ("-", 0, NULL);
+      do_spec_1 (switches[switchnum].part1, 1, NULL);
+    }
+
+  if (switches[switchnum].args != 0)
+    {
+      const char **p;
+      for (p = switches[switchnum].args; *p; p++)
+	{
+	  const char *arg = *p;
+
+	  do_spec_1 (" ", 0, NULL);
+	  if (suffix_subst)
+	    {
+	      unsigned length = strlen (arg);
+	      int dot = 0;
+
+	      while (length-- && !IS_DIR_SEPARATOR (arg[length]))
+		if (arg[length] == '.')
+		  {
+		    ((char *)arg)[length] = 0;
+		    dot = 1;
+		    break;
+		  }
+	      do_spec_1 (arg, 1, NULL);
+	      if (dot)
+		((char *)arg)[length] = '.';
+	      do_spec_1 (suffix_subst, 1, NULL);
+	    }
+	  else
+	    do_spec_1 (arg, 1, NULL);
+	}
+    }
+
+  do_spec_1 (" ", 0, NULL);
+  switches[switchnum].validated = 1;
+}
+
+/* Search for a file named NAME trying various prefixes including the
+   user's -B prefix and some standard ones.
+   Return the absolute file name found.  If nothing is found, return NAME.  */
+
+static const char *
+find_file (const char *name)
+{
+  char *newname;
+
+  /* Try multilib_dir if it is defined.  */
+  if (multilib_os_dir != NULL)
+    {
+      newname = find_a_file (&startfile_prefixes, name, R_OK, 1);
+
+      /* If we don't find it in the multi library dir, then fall
+	 through and look for it in the normal places.  */
+      if (newname != NULL)
+	return newname;
+    }
+
+  newname = find_a_file (&startfile_prefixes, name, R_OK, 0);
+  return newname ? newname : name;
+}
+
+/* Determine whether a directory exists.  If LINKER, return 0 for
+   certain fixed names not needed by the linker.  If not LINKER, it is
+   only important to return 0 if the host machine has a small ARG_MAX
+   limit.  */
+
+static int
+is_directory (const char *path1, const char *path2, int linker)
+{
+  int len1 = strlen (path1);
+  int len2 = strlen (path2);
+  char *path = alloca (3 + len1 + len2);
+  char *cp;
+  struct stat st;
+
+#ifndef SMALL_ARG_MAX
+  if (! linker)
+    return 1;
+#endif
+
+  /* Construct the path from the two parts.  Ensure the string ends with "/.".
+     The resulting path will be a directory even if the given path is a
+     symbolic link.  */
+  memcpy (path, path1, len1);
+  memcpy (path + len1, path2, len2);
+  cp = path + len1 + len2;
+  if (!IS_DIR_SEPARATOR (cp[-1]))
+    *cp++ = DIR_SEPARATOR;
+  *cp++ = '.';
+  *cp = '\0';
+
+  /* Exclude directories that the linker is known to search.  */
+  if (linker
+      && ((cp - path == 6
+	   && strcmp (path, concat (dir_separator_str, "lib",
+				    dir_separator_str, ".", NULL)) == 0)
+	  || (cp - path == 10
+	      && strcmp (path, concat (dir_separator_str, "usr",
+				       dir_separator_str, "lib",
+				       dir_separator_str, ".", NULL)) == 0)))
+    return 0;
+
+  return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));
+}
+
+/* Set up the various global variables to indicate that we're processing
+   the input file named FILENAME.  */
+
+void
+set_input (const char *filename)
+{
+  const char *p;
+
+  input_filename = filename;
+  input_filename_length = strlen (input_filename);
+
+  input_basename = input_filename;
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+  /* Skip drive name so 'x:foo' is handled properly.  */
+  if (input_basename[1] == ':')
+    input_basename += 2;
+#endif
+  for (p = input_basename; *p; p++)
+    if (IS_DIR_SEPARATOR (*p))
+      input_basename = p + 1;
+
+  /* Find a suffix starting with the last period,
+     and set basename_length to exclude that suffix.  */
+  basename_length = strlen (input_basename);
+  suffixed_basename_length = basename_length;
+  p = input_basename + basename_length;
+  while (p != input_basename && *p != '.')
+    --p;
+  if (*p == '.' && p != input_basename)
+    {
+      basename_length = p - input_basename;
+      input_suffix = p + 1;
+    }
+  else
+    input_suffix = "";
+
+  /* If a spec for 'g', 'u', or 'U' is seen with -save-temps then
+     we will need to do a stat on the input_filename.  The
+     INPUT_STAT_SET signals that the stat is needed.  */
+  input_stat_set = 0;
+}
+
+/* On fatal signals, delete all the temporary files.  */
+
+static void
+fatal_error (int signum)
+{
+  signal (signum, SIG_DFL);
+  delete_failure_queue ();
+  delete_temp_files ();
+  /* Get the same signal again, this time not handled,
+     so its normal effect occurs.  */
+  kill (getpid (), signum);
+}
+
+extern int main (int, const char **);
+
+int
+main (int argc, const char **argv)
+{
+  size_t i;
+  int value;
+  int linker_was_run = 0;
+  int lang_n_infiles = 0;
+  int num_linker_inputs = 0;
+  char *explicit_link_files;
+  char *specs_file;
+  const char *p;
+  struct user_specs *uptr;
+
+  p = argv[0] + strlen (argv[0]);
+  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))
+    --p;
+  programname = p;
+
+  xmalloc_set_program_name (programname);
+
+#ifdef GCC_DRIVER_HOST_INITIALIZATION
+  /* Perform host dependent initialization when needed.  */
+  GCC_DRIVER_HOST_INITIALIZATION;
+#endif
+
+  /* Unlock the stdio streams.  */
+  unlock_std_streams ();
+
+  gcc_init_libintl ();
+
+  if (signal (SIGINT, SIG_IGN) != SIG_IGN)
+    signal (SIGINT, fatal_error);
+#ifdef SIGHUP
+  if (signal (SIGHUP, SIG_IGN) != SIG_IGN)
+    signal (SIGHUP, fatal_error);
+#endif
+  if (signal (SIGTERM, SIG_IGN) != SIG_IGN)
+    signal (SIGTERM, fatal_error);
+#ifdef SIGPIPE
+  if (signal (SIGPIPE, SIG_IGN) != SIG_IGN)
+    signal (SIGPIPE, fatal_error);
+#endif
+#ifdef SIGCHLD
+  /* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will
+     receive the signal.  A different setting is inheritable */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Allocate the argument vector.  */
+  alloc_args ();
+
+  obstack_init (&obstack);
+
+  /* Build multilib_select, et. al from the separate lines that make up each
+     multilib selection.  */
+  {
+    const char *const *q = multilib_raw;
+    int need_space;
+
+    obstack_init (&multilib_obstack);
+    while ((p = *q++) != (char *) 0)
+      obstack_grow (&multilib_obstack, p, strlen (p));
+
+    obstack_1grow (&multilib_obstack, 0);
+    multilib_select = XOBFINISH (&multilib_obstack, const char *);
+
+    q = multilib_matches_raw;
+    while ((p = *q++) != (char *) 0)
+      obstack_grow (&multilib_obstack, p, strlen (p));
+
+    obstack_1grow (&multilib_obstack, 0);
+    multilib_matches = XOBFINISH (&multilib_obstack, const char *);
+
+    q = multilib_exclusions_raw;
+    while ((p = *q++) != (char *) 0)
+      obstack_grow (&multilib_obstack, p, strlen (p));
+
+    obstack_1grow (&multilib_obstack, 0);
+    multilib_exclusions = XOBFINISH (&multilib_obstack, const char *);
+
+    need_space = FALSE;
+    for (i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)
+      {
+	if (need_space)
+	  obstack_1grow (&multilib_obstack, ' ');
+	obstack_grow (&multilib_obstack,
+		      multilib_defaults_raw[i],
+		      strlen (multilib_defaults_raw[i]));
+	need_space = TRUE;
+      }
+
+    obstack_1grow (&multilib_obstack, 0);
+    multilib_defaults = XOBFINISH (&multilib_obstack, const char *);
+  }
+
+  /* Set up to remember the pathname of gcc and any options
+     needed for collect.  We use argv[0] instead of programname because
+     we need the complete pathname.  */
+  obstack_init (&collect_obstack);
+  obstack_grow (&collect_obstack, "COLLECT_GCC=", sizeof ("COLLECT_GCC=") - 1);
+  obstack_grow (&collect_obstack, argv[0], strlen (argv[0]) + 1);
+  putenv (XOBFINISH (&collect_obstack, char *));
+
+#ifdef INIT_ENVIRONMENT
+  /* Set up any other necessary machine specific environment variables.  */
+  putenv (INIT_ENVIRONMENT);
+#endif
+
+  /* Make a table of what switches there are (switches, n_switches).
+     Make a table of specified input files (infiles, n_infiles).
+     Decode switches that are handled locally.  */
+
+  process_command (argc, argv);
+
+  /* Initialize the vector of specs to just the default.
+     This means one element containing 0s, as a terminator.  */
+
+  compilers = xmalloc (sizeof default_compilers);
+  memcpy (compilers, default_compilers, sizeof default_compilers);
+  n_compilers = n_default_compilers;
+
+  /* Read specs from a file if there is one.  */
+
+  machine_suffix = concat (spec_machine, dir_separator_str,
+			   spec_version, dir_separator_str, NULL);
+  just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);
+
+  specs_file = find_a_file (&startfile_prefixes, "specs", R_OK, 0);
+  /* Read the specs file unless it is a default one.  */
+  if (specs_file != 0 && strcmp (specs_file, "specs"))
+    read_specs (specs_file, TRUE);
+  else
+    init_spec ();
+
+  /* We need to check standard_exec_prefix/just_machine_suffix/specs
+     for any override of as, ld and libraries.  */
+  specs_file = alloca (strlen (standard_exec_prefix)
+		       + strlen (just_machine_suffix) + sizeof ("specs"));
+
+  strcpy (specs_file, standard_exec_prefix);
+  strcat (specs_file, just_machine_suffix);
+  strcat (specs_file, "specs");
+  if (access (specs_file, R_OK) == 0)
+    read_specs (specs_file, TRUE);
+
+  /* Process any configure-time defaults specified for the command line
+     options, via OPTION_DEFAULT_SPECS.  */
+  for (i = 0; i < ARRAY_SIZE (option_default_specs); i++)
+    do_option_spec (option_default_specs[i].name,
+		    option_default_specs[i].spec);
+
+  /* Process DRIVER_SELF_SPECS, adding any new options to the end
+     of the command line.  */
+
+  for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)
+    do_self_spec (driver_self_specs[i]);
+
+  /* If not cross-compiling, look for executables in the standard
+     places.  */
+  if (*cross_compile == '0')
+    {
+      if (*md_exec_prefix)
+	{
+	  add_prefix (&exec_prefixes, md_exec_prefix, "GCC",
+		      PREFIX_PRIORITY_LAST, 0, 0);
+	}
+    }
+
+  /* Process sysroot_suffix_spec.  */
+  if (*sysroot_suffix_spec != 0
+      && do_spec_2 (sysroot_suffix_spec) == 0)
+    {
+      if (argbuf_index > 1)
+        error ("spec failure: more than one arg to SYSROOT_SUFFIX_SPEC");
+      else if (argbuf_index == 1)
+        target_sysroot_suffix = xstrdup (argbuf[argbuf_index -1]);
+    }
+
+#ifdef HAVE_LD_SYSROOT
+  /* Pass the --sysroot option to the linker, if it supports that.  If
+     there is a sysroot_suffix_spec, it has already been processed by
+     this point, so target_system_root really is the system root we
+     should be using.  */
+  if (target_system_root)
+    {
+      obstack_grow (&obstack, "%(sysroot_spec) ", strlen ("%(sysroot_spec) "));
+      obstack_grow0 (&obstack, link_spec, strlen (link_spec));
+      set_spec ("link", XOBFINISH (&obstack, const char *));
+    }
+#endif
+
+  /* Process sysroot_hdrs_suffix_spec.  */
+  if (*sysroot_hdrs_suffix_spec != 0
+      && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)
+    {
+      if (argbuf_index > 1)
+        error ("spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC");
+      else if (argbuf_index == 1)
+        target_sysroot_hdrs_suffix = xstrdup (argbuf[argbuf_index -1]);
+    }
+
+  /* Look for startfiles in the standard places.  */
+  if (*startfile_prefix_spec != 0
+      && do_spec_2 (startfile_prefix_spec) == 0
+      && do_spec_1 (" ", 0, NULL) == 0)
+    {
+      int ndx;
+      for (ndx = 0; ndx < argbuf_index; ndx++)
+	add_sysrooted_prefix (&startfile_prefixes, argbuf[ndx], "BINUTILS",
+			      PREFIX_PRIORITY_LAST, 0, 1);
+    }
+  /* We should eventually get rid of all these and stick to
+     startfile_prefix_spec exclusively.  */
+  else if (*cross_compile == '0' || target_system_root)
+    {
+      if (*md_startfile_prefix)
+	add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix,
+			      "GCC", PREFIX_PRIORITY_LAST, 0, 1);
+
+      if (*md_startfile_prefix_1)
+	add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix_1,
+			      "GCC", PREFIX_PRIORITY_LAST, 0, 1);
+
+      /* If standard_startfile_prefix is relative, base it on
+	 standard_exec_prefix.  This lets us move the installed tree
+	 as a unit.  If GCC_EXEC_PREFIX is defined, base
+	 standard_startfile_prefix on that as well.
+
+         If the prefix is relative, only search it for native compilers;
+         otherwise we will search a directory containing host libraries.  */
+      if (IS_ABSOLUTE_PATH (standard_startfile_prefix))
+	add_sysrooted_prefix (&startfile_prefixes,
+			      standard_startfile_prefix, "BINUTILS",
+			      PREFIX_PRIORITY_LAST, 0, 1);
+      else if (*cross_compile == '0')
+	{
+	  if (gcc_exec_prefix)
+	    add_prefix (&startfile_prefixes,
+			concat (gcc_exec_prefix, machine_suffix,
+				standard_startfile_prefix, NULL),
+			NULL, PREFIX_PRIORITY_LAST, 0, 1);
+	  add_prefix (&startfile_prefixes,
+		      concat (standard_exec_prefix,
+			      machine_suffix,
+			      standard_startfile_prefix, NULL),
+		      NULL, PREFIX_PRIORITY_LAST, 0, 1);
+	}
+
+      if (*standard_startfile_prefix_1)
+ 	add_sysrooted_prefix (&startfile_prefixes,
+			      standard_startfile_prefix_1, "BINUTILS",
+			      PREFIX_PRIORITY_LAST, 0, 1);
+      if (*standard_startfile_prefix_2)
+	add_sysrooted_prefix (&startfile_prefixes,
+			      standard_startfile_prefix_2, "BINUTILS",
+			      PREFIX_PRIORITY_LAST, 0, 1);
+    }
+
+  /* Process any user specified specs in the order given on the command
+     line.  */
+  for (uptr = user_specs_head; uptr; uptr = uptr->next)
+    {
+      char *filename = find_a_file (&startfile_prefixes, uptr->filename,
+				    R_OK, 0);
+      read_specs (filename ? filename : uptr->filename, FALSE);
+    }
+
+  /* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */
+  if (gcc_exec_prefix)
+    gcc_exec_prefix = concat (gcc_exec_prefix, spec_machine, dir_separator_str,
+			      spec_version, dir_separator_str, NULL);
+
+  /* Now we have the specs.
+     Set the `valid' bits for switches that match anything in any spec.  */
+
+  validate_all_switches ();
+
+  /* Now that we have the switches and the specs, set
+     the subdirectory based on the options.  */
+  set_multilib_dir ();
+
+  /* Warn about any switches that no pass was interested in.  */
+
+  for (i = 0; (int) i < n_switches; i++)
+    if (! switches[i].validated)
+      error ("unrecognized option '-%s'", switches[i].part1);
+
+  /* Obey some of the options.  */
+
+  if (print_search_dirs)
+    {
+      printf (_("install: %s%s\n"), standard_exec_prefix, machine_suffix);
+      printf (_("programs: %s\n"), build_search_list (&exec_prefixes, "", 0));
+      printf (_("libraries: %s\n"), build_search_list (&startfile_prefixes, "", 0));
+      return (0);
+    }
+
+  if (print_file_name)
+    {
+      printf ("%s\n", find_file (print_file_name));
+      return (0);
+    }
+
+  if (print_prog_name)
+    {
+      char *newname = find_a_file (&exec_prefixes, print_prog_name, X_OK, 0);
+      printf ("%s\n", (newname ? newname : print_prog_name));
+      return (0);
+    }
+
+  if (print_multi_lib)
+    {
+      print_multilib_info ();
+      return (0);
+    }
+
+  if (print_multi_directory)
+    {
+      if (multilib_dir == NULL)
+	printf (".\n");
+      else
+	printf ("%s\n", multilib_dir);
+      return (0);
+    }
+
+  if (print_multi_os_directory)
+    {
+      if (multilib_os_dir == NULL)
+	printf (".\n");
+      else
+	printf ("%s\n", multilib_os_dir);
+      return (0);
+    }
+
+  if (target_help_flag)
+   {
+      /* Print if any target specific options.  */
+
+      /* We do not exit here. Instead we have created a fake input file
+         called 'target-dummy' which needs to be compiled, and we pass this
+         on to the various sub-processes, along with the --target-help
+         switch.  */
+    }
+
+  if (print_help_list)
+    {
+      display_help ();
+
+      if (! verbose_flag)
+	{
+	  printf (_("\nFor bug reporting instructions, please see:\n"));
+	  printf ("%s.\n", bug_report_url);
+
+	  return (0);
+	}
+
+      /* We do not exit here.  Instead we have created a fake input file
+	 called 'help-dummy' which needs to be compiled, and we pass this
+	 on the various sub-processes, along with the --help switch.  */
+    }
+
+  if (verbose_flag)
+    {
+      int n;
+      const char *thrmod;
+
+      notice ("Target: %s\n", spec_machine);
+      notice ("Configured with: %s\n", configuration_arguments);
+
+#ifdef THREAD_MODEL_SPEC
+      /* We could have defined THREAD_MODEL_SPEC to "%*" by default,
+	 but there's no point in doing all this processing just to get
+	 thread_model back.  */
+      obstack_init (&obstack);
+      do_spec_1 (THREAD_MODEL_SPEC, 0, thread_model);
+      obstack_1grow (&obstack, '\0');
+      thrmod = XOBFINISH (&obstack, const char *);
+#else
+      thrmod = thread_model;
+#endif
+
+      notice ("Thread model: %s\n", thrmod);
+
+      /* compiler_version is truncated at the first space when initialized
+	 from version string, so truncate version_string at the first space
+	 before comparing.  */
+      for (n = 0; version_string[n]; n++)
+	if (version_string[n] == ' ')
+	  break;
+
+      if (! strncmp (version_string, compiler_version, n)
+	  && compiler_version[n] == 0)
+	notice ("gcc version %s\n", version_string);
+      else
+	notice ("gcc driver version %s executing gcc version %s\n",
+		version_string, compiler_version);
+
+      if (n_infiles == 0)
+	return (0);
+    }
+
+  if (n_infiles == added_libraries)
+    fatal ("no input files");
+
+  /* Make a place to record the compiler output file names
+     that correspond to the input files.  */
+
+  i = n_infiles;
+  i += lang_specific_extra_outfiles;
+  outfiles = xcalloc (i, sizeof (char *));
+
+  /* Record which files were specified explicitly as link input.  */
+
+  explicit_link_files = xcalloc (1, n_infiles);
+
+  if (combine_flag)
+    combine_inputs = true;
+  else
+    combine_inputs = false;  
+
+  for (i = 0; (int) i < n_infiles; i++)
+    {
+      const char *name = infiles[i].name;
+      struct compiler *compiler = lookup_compiler (name,
+						   strlen (name),
+						   infiles[i].language);
+
+      if (compiler && !(compiler->combinable))
+	combine_inputs = false;
+
+      if (lang_n_infiles > 0 && compiler != input_file_compiler
+	  && infiles[i].language && infiles[i].language[0] != '*')
+	infiles[i].incompiler = compiler;
+      else if (compiler)
+	{
+	  lang_n_infiles++;
+	  input_file_compiler = compiler;
+	  infiles[i].incompiler = compiler;
+	}
+      else
+	{
+	  /* Since there is no compiler for this input file, assume it is a
+	     linker file.  */
+	  explicit_link_files[i] = 1;
+	  infiles[i].incompiler = NULL;
+	}
+      infiles[i].compiled = false;
+      infiles[i].preprocessed = false;
+    }
+    
+  if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)
+   fatal ("cannot specify -o with -c or -S with multiple files");
+
+  if (combine_flag && save_temps_flag)
+    {
+      bool save_combine_inputs = combine_inputs;
+      /* Must do a separate pre-processing pass for C & Objective-C files, to
+	 obtain individual .i files.  */
+
+      combine_inputs = false;
+      for (i = 0; (int) i < n_infiles; i++)
+	{
+	  int this_file_error = 0;
+
+	  input_file_number = i;
+	  set_input (infiles[i].name);
+	  if (infiles[i].incompiler
+	      && (infiles[i].incompiler)->needs_preprocessing)
+	    input_file_compiler = infiles[i].incompiler;
+	  else
+	    continue;
+
+	  if (input_file_compiler)
+	    {
+	      if (input_file_compiler->spec[0] == '#')
+		{
+		  error ("%s: %s compiler not installed on this system",
+			 input_filename, &input_file_compiler->spec[1]);
+		  this_file_error = 1;
+		}
+	      else
+		{
+		  value = do_spec (input_file_compiler->spec);
+		  infiles[i].preprocessed = true;
+		  if (!have_o_argbuf_index)
+		    fatal ("spec '%s' is invalid", input_file_compiler->spec);
+		  infiles[i].name = argbuf[have_o_argbuf_index];
+		  infiles[i].incompiler
+		    = lookup_compiler (infiles[i].name,
+				       strlen (infiles[i].name),
+				       infiles[i].language);
+
+		  if (value < 0)
+		    this_file_error = 1;
+		}
+	    }
+
+	  if (this_file_error)
+	    {
+	      delete_failure_queue ();
+	      error_count++;
+	      break;
+	    }
+	  clear_failure_queue ();
+	}
+      combine_inputs = save_combine_inputs;
+    }
+
+  for (i = 0; (int) i < n_infiles; i++)
+    {
+      int this_file_error = 0;
+
+      /* Tell do_spec what to substitute for %i.  */
+
+      input_file_number = i;
+      set_input (infiles[i].name);
+
+      if (infiles[i].compiled)
+	continue;
+
+      /* Use the same thing in %o, unless cp->spec says otherwise.  */
+
+      outfiles[i] = input_filename;
+
+      /* Figure out which compiler from the file's suffix.  */
+
+      if (! combine_inputs)
+	input_file_compiler
+	  = lookup_compiler (infiles[i].name, input_filename_length,
+			     infiles[i].language);
+      else
+	input_file_compiler = infiles[i].incompiler;
+
+      if (input_file_compiler)
+	{
+	  /* Ok, we found an applicable compiler.  Run its spec.  */
+
+	  if (input_file_compiler->spec[0] == '#')
+	    {
+	      error ("%s: %s compiler not installed on this system",
+		     input_filename, &input_file_compiler->spec[1]);
+	      this_file_error = 1;
+	    }
+	  else
+	    {
+	      value = do_spec (input_file_compiler->spec);
+	      infiles[i].compiled = true;
+	      if (value < 0)
+		this_file_error = 1;
+	    }
+	}
+
+      /* If this file's name does not contain a recognized suffix,
+	 record it as explicit linker input.  */
+
+      else
+	explicit_link_files[i] = 1;
+
+      /* Clear the delete-on-failure queue, deleting the files in it
+	 if this compilation failed.  */
+
+      if (this_file_error)
+	{
+	  delete_failure_queue ();
+	  error_count++;
+	}
+      /* If this compilation succeeded, don't delete those files later.  */
+      clear_failure_queue ();
+    }
+
+  /* Reset the input file name to the first compile/object file name, for use
+     with %b in LINK_SPEC. We use the first input file that we can find
+     a compiler to compile it instead of using infiles.language since for
+     languages other than C we use aliases that we then lookup later.  */
+  if (n_infiles > 0)
+    {
+      int i;
+
+      for (i = 0; i < n_infiles ; i++)
+	if (infiles[i].language && infiles[i].language[0] != '*')
+	  {
+	    set_input (infiles[i].name);
+	    break;
+	  }
+    }
+
+  if (error_count == 0)
+    {
+      /* Make sure INPUT_FILE_NUMBER points to first available open
+	 slot.  */
+      input_file_number = n_infiles;
+      if (lang_specific_pre_link ())
+	error_count++;
+    }
+
+  /* Determine if there are any linker input files.  */
+  num_linker_inputs = 0;
+  for (i = 0; (int) i < n_infiles; i++)
+    if (explicit_link_files[i] || outfiles[i] != NULL)
+      num_linker_inputs++;
+
+  /* Run ld to link all the compiler output files.  */
+
+  if (num_linker_inputs > 0 && error_count == 0)
+    {
+      int tmp = execution_count;
+
+      /* We'll use ld if we can't find collect2.  */
+      if (! strcmp (linker_name_spec, "collect2"))
+	{
+	  char *s = find_a_file (&exec_prefixes, "collect2", X_OK, 0);
+	  if (s == NULL)
+	    linker_name_spec = "ld";
+	}
+      /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables
+	 for collect.  */
+      putenv_from_prefixes (&exec_prefixes, "COMPILER_PATH");
+      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV);
+
+      value = do_spec (link_command_spec);
+      if (value < 0)
+	error_count = 1;
+      linker_was_run = (tmp != execution_count);
+    }
+
+  /* If options said don't run linker,
+     complain about input files to be given to the linker.  */
+
+  if (! linker_was_run && error_count == 0)
+    for (i = 0; (int) i < n_infiles; i++)
+      if (explicit_link_files[i])
+	error ("%s: linker input file unused because linking not done",
+	       outfiles[i]);
+
+  /* Delete some or all of the temporary files we made.  */
+
+  if (error_count)
+    delete_failure_queue ();
+  delete_temp_files ();
+
+  if (print_help_list)
+    {
+      printf (("\nFor bug reporting instructions, please see:\n"));
+      printf ("%s\n", bug_report_url);
+    }
+
+  return (signal_count != 0 ? 2
+	  : error_count > 0 ? (pass_exit_codes ? greatest_status : 1)
+	  : 0);
+}
+
+/* Find the proper compilation spec for the file name NAME,
+   whose length is LENGTH.  LANGUAGE is the specified language,
+   or 0 if this file is to be passed to the linker.  */
+
+static struct compiler *
+lookup_compiler (const char *name, size_t length, const char *language)
+{
+  struct compiler *cp;
+
+  /* If this was specified by the user to be a linker input, indicate that.  */
+  if (language != 0 && language[0] == '*')
+    return 0;
+
+  /* Otherwise, look for the language, if one is spec'd.  */
+  if (language != 0)
+    {
+      for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
+	if (cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language))
+	  return cp;
+
+      error ("language %s not recognized", language);
+      return 0;
+    }
+
+  /* Look for a suffix.  */
+  for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
+    {
+      if (/* The suffix `-' matches only the file name `-'.  */
+	  (!strcmp (cp->suffix, "-") && !strcmp (name, "-"))
+	  || (strlen (cp->suffix) < length
+	      /* See if the suffix matches the end of NAME.  */
+	      && !strcmp (cp->suffix,
+			  name + length - strlen (cp->suffix))
+	 ))
+	break;
+    }
+
+#if defined (OS2) ||defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Look again, but case-insensitively this time.  */
+  if (cp < compilers)
+    for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
+      {
+	if (/* The suffix `-' matches only the file name `-'.  */
+	    (!strcmp (cp->suffix, "-") && !strcmp (name, "-"))
+	    || (strlen (cp->suffix) < length
+		/* See if the suffix matches the end of NAME.  */
+		&& ((!strcmp (cp->suffix,
+			     name + length - strlen (cp->suffix))
+		     || !strpbrk (cp->suffix, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
+		    && !strcasecmp (cp->suffix,
+				    name + length - strlen (cp->suffix)))
+	   ))
+	  break;
+      }
+#endif
+
+  if (cp >= compilers)
+    {
+      if (cp->spec[0] != '@')
+	/* A non-alias entry: return it.  */
+	return cp;
+
+      /* An alias entry maps a suffix to a language.
+	 Search for the language; pass 0 for NAME and LENGTH
+	 to avoid infinite recursion if language not found.  */
+      return lookup_compiler (NULL, 0, cp->spec + 1);
+    }
+  return 0;
+}
+
+static char *
+save_string (const char *s, int len)
+{
+  char *result = xmalloc (len + 1);
+
+  memcpy (result, s, len);
+  result[len] = 0;
+  return result;
+}
+
+void
+pfatal_with_name (const char *name)
+{
+  perror_with_name (name);
+  delete_temp_files ();
+  exit (1);
+}
+
+static void
+perror_with_name (const char *name)
+{
+  error ("%s: %s", name, xstrerror (errno));
+}
+
+/* Output an error message and exit.  */
+
+void
+fancy_abort (const char *file, int line, const char *func)
+{
+  fatal ("internal gcc abort in %s, at %s:%d", func, file, line);
+}
+
+/* Output an error message and exit.  */
+
+void
+fatal (const char *cmsgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, cmsgid);
+
+  fprintf (stderr, "%s: ", programname);
+  vfprintf (stderr, _(cmsgid), ap);
+  va_end (ap);
+  fprintf (stderr, "\n");
+  delete_temp_files ();
+  exit (1);
+}
+
+/* The argument is actually c-format, not gcc-internal-format,
+   but because functions with identical names are used through
+   the rest of the compiler with gcc-internal-format, we just
+   need to hope all users of these functions use the common
+   subset between c-format and gcc-internal-format.  */
+
+void
+error (const char *gmsgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, gmsgid);
+  fprintf (stderr, "%s: ", programname);
+  vfprintf (stderr, _(gmsgid), ap);
+  va_end (ap);
+
+  fprintf (stderr, "\n");
+}
+
+static void
+notice (const char *cmsgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, cmsgid);
+  vfprintf (stderr, _(cmsgid), ap);
+  va_end (ap);
+}
+
+static inline void
+validate_switches_from_spec (const char *spec)
+{
+  const char *p = spec;
+  char c;
+  while ((c = *p++))
+    if (c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')))
+      /* We have a switch spec.  */
+      p = validate_switches (p + 1);
+}
+
+static void
+validate_all_switches (void)
+{
+  struct compiler *comp;
+  struct spec_list *spec;
+
+  for (comp = compilers; comp->spec; comp++)
+    validate_switches_from_spec (comp->spec);
+
+  /* Look through the linked list of specs read from the specs file.  */
+  for (spec = specs; spec; spec = spec->next)
+    validate_switches_from_spec (*spec->ptr_spec);
+
+  validate_switches_from_spec (link_command_spec);
+}
+
+/* Look at the switch-name that comes after START
+   and mark as valid all supplied switches that match it.  */
+
+static const char *
+validate_switches (const char *start)
+{
+  const char *p = start;
+  const char *atom;
+  size_t len;
+  int i;
+  bool suffix = false;
+  bool starred = false;
+
+#define SKIP_WHITE() do { while (*p == ' ' || *p == '\t') p++; } while (0)
+
+next_member:
+  SKIP_WHITE ();
+
+  if (*p == '!')
+    p++;
+
+  SKIP_WHITE ();
+  if (*p == '.')
+    suffix = true, p++;
+
+  atom = p;
+  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='
+	 || *p == ',' || *p == '.' || *p == '@')
+    p++;
+  len = p - atom;
+
+  if (*p == '*')
+    starred = true, p++;
+
+  SKIP_WHITE ();
+
+  if (!suffix)
+    {
+      /* Mark all matching switches as valid.  */
+      for (i = 0; i < n_switches; i++)
+	if (!strncmp (switches[i].part1, atom, len)
+	    && (starred || switches[i].part1[len] == 0))
+	  switches[i].validated = 1;
+    }
+
+  if (*p) p++;
+  if (*p && (p[-1] == '|' || p[-1] == '&'))
+    goto next_member;
+
+  if (*p && p[-1] == ':')
+    {
+      while (*p && *p != ';' && *p != '}')
+	{
+	  if (*p == '%')
+	    {
+	      p++;
+	      if (*p == '{' || *p == '<')
+		p = validate_switches (p+1);
+	      else if (p[0] == 'W' && p[1] == '{')
+		p = validate_switches (p+2);
+	    }
+	  else
+	    p++;
+	}
+
+      if (*p) p++;
+      if (*p && p[-1] == ';')
+	goto next_member;
+    }
+
+  return p;
+#undef SKIP_WHITE
+}
+
+struct mdswitchstr
+{
+  const char *str;
+  int len;
+};
+
+static struct mdswitchstr *mdswitches;
+static int n_mdswitches;
+
+/* Check whether a particular argument was used.  The first time we
+   canonicalize the switches to keep only the ones we care about.  */
+
+static int
+used_arg (const char *p, int len)
+{
+  struct mswitchstr
+  {
+    const char *str;
+    const char *replace;
+    int len;
+    int rep_len;
+  };
+
+  static struct mswitchstr *mswitches;
+  static int n_mswitches;
+  int i, j;
+
+  if (!mswitches)
+    {
+      struct mswitchstr *matches;
+      const char *q;
+      int cnt = 0;
+
+      /* Break multilib_matches into the component strings of string
+         and replacement string.  */
+      for (q = multilib_matches; *q != '\0'; q++)
+	if (*q == ';')
+	  cnt++;
+
+      matches = alloca ((sizeof (struct mswitchstr)) * cnt);
+      i = 0;
+      q = multilib_matches;
+      while (*q != '\0')
+	{
+	  matches[i].str = q;
+	  while (*q != ' ')
+	    {
+	      if (*q == '\0')
+		{
+		invalid_matches:
+		  fatal ("multilib spec '%s' is invalid", multilib_matches);
+		}
+	      q++;
+	    }
+	  matches[i].len = q - matches[i].str;
+
+	  matches[i].replace = ++q;
+	  while (*q != ';' && *q != '\0')
+	    {
+	      if (*q == ' ')
+		goto invalid_matches;
+	      q++;
+	    }
+	  matches[i].rep_len = q - matches[i].replace;
+	  i++;
+	  if (*q == ';')
+	    q++;
+	}
+
+      /* Now build a list of the replacement string for switches that we care
+	 about.  Make sure we allocate at least one entry.  This prevents
+	 xmalloc from calling fatal, and prevents us from re-executing this
+	 block of code.  */
+      mswitches
+	= xmalloc (sizeof (struct mswitchstr)
+		   * (n_mdswitches + (n_switches ? n_switches : 1)));
+      for (i = 0; i < n_switches; i++)
+	if (switches[i].live_cond != SWITCH_IGNORE)
+	  {
+	    int xlen = strlen (switches[i].part1);
+	    for (j = 0; j < cnt; j++)
+	      if (xlen == matches[j].len
+		  && ! strncmp (switches[i].part1, matches[j].str, xlen))
+		{
+		  mswitches[n_mswitches].str = matches[j].replace;
+		  mswitches[n_mswitches].len = matches[j].rep_len;
+		  mswitches[n_mswitches].replace = (char *) 0;
+		  mswitches[n_mswitches].rep_len = 0;
+		  n_mswitches++;
+		  break;
+		}
+	  }
+
+      /* Add MULTILIB_DEFAULTS switches too, as long as they were not present
+	 on the command line nor any options mutually incompatible with
+	 them.  */
+      for (i = 0; i < n_mdswitches; i++)
+	{
+	  const char *r;
+
+	  for (q = multilib_options; *q != '\0'; q++)
+	    {
+	      while (*q == ' ')
+		q++;
+
+	      r = q;
+	      while (strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0
+		     || strchr (" /", q[mdswitches[i].len]) == NULL)
+		{
+		  while (*q != ' ' && *q != '/' && *q != '\0')
+		    q++;
+		  if (*q != '/')
+		    break;
+		  q++;
+		}
+
+	      if (*q != ' ' && *q != '\0')
+		{
+		  while (*r != ' ' && *r != '\0')
+		    {
+		      q = r;
+		      while (*q != ' ' && *q != '/' && *q != '\0')
+			q++;
+
+		      if (used_arg (r, q - r))
+			break;
+
+		      if (*q != '/')
+			{
+			  mswitches[n_mswitches].str = mdswitches[i].str;
+			  mswitches[n_mswitches].len = mdswitches[i].len;
+			  mswitches[n_mswitches].replace = (char *) 0;
+			  mswitches[n_mswitches].rep_len = 0;
+			  n_mswitches++;
+			  break;
+			}
+
+		      r = q + 1;
+		    }
+		  break;
+		}
+	    }
+	}
+    }
+
+  for (i = 0; i < n_mswitches; i++)
+    if (len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len))
+      return 1;
+
+  return 0;
+}
+
+static int
+default_arg (const char *p, int len)
+{
+  int i;
+
+  for (i = 0; i < n_mdswitches; i++)
+    if (len == mdswitches[i].len && ! strncmp (p, mdswitches[i].str, len))
+      return 1;
+
+  return 0;
+}
+
+/* Work out the subdirectory to use based on the options. The format of
+   multilib_select is a list of elements. Each element is a subdirectory
+   name followed by a list of options followed by a semicolon. The format
+   of multilib_exclusions is the same, but without the preceding
+   directory. First gcc will check the exclusions, if none of the options
+   beginning with an exclamation point are present, and all of the other
+   options are present, then we will ignore this completely. Passing
+   that, gcc will consider each multilib_select in turn using the same
+   rules for matching the options. If a match is found, that subdirectory
+   will be used.  */
+
+static void
+set_multilib_dir (void)
+{
+  const char *p;
+  unsigned int this_path_len;
+  const char *this_path, *this_arg;
+  const char *start, *end;
+  int not_arg;
+  int ok, ndfltok, first;
+
+  n_mdswitches = 0;
+  start = multilib_defaults;
+  while (*start == ' ' || *start == '\t')
+    start++;
+  while (*start != '\0')
+    {
+      n_mdswitches++;
+      while (*start != ' ' && *start != '\t' && *start != '\0')
+	start++;
+      while (*start == ' ' || *start == '\t')
+        start++;
+    }
+
+  if (n_mdswitches)
+    {
+      int i = 0;
+
+      mdswitches = xmalloc (sizeof (struct mdswitchstr) * n_mdswitches);
+      for (start = multilib_defaults; *start != '\0'; start = end + 1)
+	{
+	  while (*start == ' ' || *start == '\t')
+	    start++;
+
+	  if (*start == '\0')
+	    break;
+
+	  for (end = start + 1;
+	       *end != ' ' && *end != '\t' && *end != '\0'; end++)
+	    ;
+
+	  obstack_grow (&multilib_obstack, start, end - start);
+	  obstack_1grow (&multilib_obstack, 0);
+	  mdswitches[i].str = XOBFINISH (&multilib_obstack, const char *);
+	  mdswitches[i++].len = end - start;
+
+	  if (*end == '\0')
+	    break;
+	}
+    }
+
+  p = multilib_exclusions;
+  while (*p != '\0')
+    {
+      /* Ignore newlines.  */
+      if (*p == '\n')
+	{
+	  ++p;
+	  continue;
+	}
+
+      /* Check the arguments.  */
+      ok = 1;
+      while (*p != ';')
+	{
+	  if (*p == '\0')
+	    {
+	    invalid_exclusions:
+	      fatal ("multilib exclusions '%s' is invalid",
+		     multilib_exclusions);
+	    }
+
+	  if (! ok)
+	    {
+	      ++p;
+	      continue;
+	    }
+
+	  this_arg = p;
+	  while (*p != ' ' && *p != ';')
+	    {
+	      if (*p == '\0')
+		goto invalid_exclusions;
+	      ++p;
+	    }
+
+	  if (*this_arg != '!')
+	    not_arg = 0;
+	  else
+	    {
+	      not_arg = 1;
+	      ++this_arg;
+	    }
+
+	  ok = used_arg (this_arg, p - this_arg);
+	  if (not_arg)
+	    ok = ! ok;
+
+	  if (*p == ' ')
+	    ++p;
+	}
+
+      if (ok)
+	return;
+
+      ++p;
+    }
+
+  first = 1;
+  p = multilib_select;
+  while (*p != '\0')
+    {
+      /* Ignore newlines.  */
+      if (*p == '\n')
+	{
+	  ++p;
+	  continue;
+	}
+
+      /* Get the initial path.  */
+      this_path = p;
+      while (*p != ' ')
+	{
+	  if (*p == '\0')
+	    {
+	    invalid_select:
+	      fatal ("multilib select '%s' is invalid",
+		     multilib_select);
+	    }
+	  ++p;
+	}
+      this_path_len = p - this_path;
+
+      /* Check the arguments.  */
+      ok = 1;
+      ndfltok = 1;
+      ++p;
+      while (*p != ';')
+	{
+	  if (*p == '\0')
+	    goto invalid_select;
+
+	  if (! ok)
+	    {
+	      ++p;
+	      continue;
+	    }
+
+	  this_arg = p;
+	  while (*p != ' ' && *p != ';')
+	    {
+	      if (*p == '\0')
+		goto invalid_select;
+	      ++p;
+	    }
+
+	  if (*this_arg != '!')
+	    not_arg = 0;
+	  else
+	    {
+	      not_arg = 1;
+	      ++this_arg;
+	    }
+
+	  /* If this is a default argument, we can just ignore it.
+	     This is true even if this_arg begins with '!'.  Beginning
+	     with '!' does not mean that this argument is necessarily
+	     inappropriate for this library: it merely means that
+	     there is a more specific library which uses this
+	     argument.  If this argument is a default, we need not
+	     consider that more specific library.  */
+	  ok = used_arg (this_arg, p - this_arg);
+	  if (not_arg)
+	    ok = ! ok;
+
+	  if (! ok)
+	    ndfltok = 0;
+
+	  if (default_arg (this_arg, p - this_arg))
+	    ok = 1;
+
+	  if (*p == ' ')
+	    ++p;
+	}
+
+      if (ok && first)
+	{
+	  if (this_path_len != 1
+	      || this_path[0] != '.')
+	    {
+	      char *new_multilib_dir = xmalloc (this_path_len + 1);
+	      char *q;
+
+	      strncpy (new_multilib_dir, this_path, this_path_len);
+	      new_multilib_dir[this_path_len] = '\0';
+	      q = strchr (new_multilib_dir, ':');
+	      if (q != NULL)
+		*q = '\0';
+	      multilib_dir = new_multilib_dir;
+	    }
+	  first = 0;
+	}
+
+      if (ndfltok)
+	{
+	  const char *q = this_path, *end = this_path + this_path_len;
+
+	  while (q < end && *q != ':')
+	    q++;
+	  if (q < end)
+	    {
+	      char *new_multilib_os_dir = xmalloc (end - q);
+	      memcpy (new_multilib_os_dir, q + 1, end - q - 1);
+	      new_multilib_os_dir[end - q - 1] = '\0';
+	      multilib_os_dir = new_multilib_os_dir;
+	      break;
+	    }
+	}
+
+      ++p;
+    }
+
+  if (multilib_dir == NULL && multilib_os_dir != NULL
+      && strcmp (multilib_os_dir, ".") == 0)
+    {
+      free ((char *) multilib_os_dir);
+      multilib_os_dir = NULL;
+    }
+  else if (multilib_dir != NULL && multilib_os_dir == NULL)
+    multilib_os_dir = multilib_dir;
+}
+
+/* Print out the multiple library subdirectory selection
+   information.  This prints out a series of lines.  Each line looks
+   like SUBDIRECTORY;@OPTION@OPTION, with as many options as is
+   required.  Only the desired options are printed out, the negative
+   matches.  The options are print without a leading dash.  There are
+   no spaces to make it easy to use the information in the shell.
+   Each subdirectory is printed only once.  This assumes the ordering
+   generated by the genmultilib script. Also, we leave out ones that match
+   the exclusions.  */
+
+static void
+print_multilib_info (void)
+{
+  const char *p = multilib_select;
+  const char *last_path = 0, *this_path;
+  int skip;
+  unsigned int last_path_len = 0;
+
+  while (*p != '\0')
+    {
+      skip = 0;
+      /* Ignore newlines.  */
+      if (*p == '\n')
+	{
+	  ++p;
+	  continue;
+	}
+
+      /* Get the initial path.  */
+      this_path = p;
+      while (*p != ' ')
+	{
+	  if (*p == '\0')
+	    {
+	    invalid_select:
+	      fatal ("multilib select '%s' is invalid", multilib_select);
+	    }
+
+	  ++p;
+	}
+
+      /* When --disable-multilib was used but target defines
+	 MULTILIB_OSDIRNAMES, entries starting with .: are there just
+	 to find multilib_os_dir, so skip them from output.  */
+      if (this_path[0] == '.' && this_path[1] == ':')
+	skip = 1;
+
+      /* Check for matches with the multilib_exclusions. We don't bother
+         with the '!' in either list. If any of the exclusion rules match
+         all of its options with the select rule, we skip it.  */
+      {
+	const char *e = multilib_exclusions;
+	const char *this_arg;
+
+	while (*e != '\0')
+	  {
+	    int m = 1;
+	    /* Ignore newlines.  */
+	    if (*e == '\n')
+	      {
+		++e;
+		continue;
+	      }
+
+	    /* Check the arguments.  */
+	    while (*e != ';')
+	      {
+		const char *q;
+		int mp = 0;
+
+		if (*e == '\0')
+		  {
+		  invalid_exclusion:
+		    fatal ("multilib exclusion '%s' is invalid",
+			   multilib_exclusions);
+		  }
+
+		if (! m)
+		  {
+		    ++e;
+		    continue;
+		  }
+
+		this_arg = e;
+
+		while (*e != ' ' && *e != ';')
+		  {
+		    if (*e == '\0')
+		      goto invalid_exclusion;
+		    ++e;
+		  }
+
+		q = p + 1;
+		while (*q != ';')
+		  {
+		    const char *arg;
+		    int len = e - this_arg;
+
+		    if (*q == '\0')
+		      goto invalid_select;
+
+		    arg = q;
+
+		    while (*q != ' ' && *q != ';')
+		      {
+			if (*q == '\0')
+			  goto invalid_select;
+			++q;
+		      }
+
+		    if (! strncmp (arg, this_arg,
+				   (len < q - arg) ? q - arg : len)
+			|| default_arg (this_arg, e - this_arg))
+		      {
+			mp = 1;
+			break;
+		      }
+
+		    if (*q == ' ')
+		      ++q;
+		  }
+
+		if (! mp)
+		  m = 0;
+
+		if (*e == ' ')
+		  ++e;
+	      }
+
+	    if (m)
+	      {
+		skip = 1;
+		break;
+	      }
+
+	    if (*e != '\0')
+	      ++e;
+	  }
+      }
+
+      if (! skip)
+	{
+	  /* If this is a duplicate, skip it.  */
+	  skip = (last_path != 0
+		  && (unsigned int) (p - this_path) == last_path_len
+		  && ! strncmp (last_path, this_path, last_path_len));
+
+	  last_path = this_path;
+	  last_path_len = p - this_path;
+	}
+
+      /* If this directory requires any default arguments, we can skip
+	 it.  We will already have printed a directory identical to
+	 this one which does not require that default argument.  */
+      if (! skip)
+	{
+	  const char *q;
+
+	  q = p + 1;
+	  while (*q != ';')
+	    {
+	      const char *arg;
+
+	      if (*q == '\0')
+		goto invalid_select;
+
+	      if (*q == '!')
+		arg = NULL;
+	      else
+		arg = q;
+
+	      while (*q != ' ' && *q != ';')
+		{
+		  if (*q == '\0')
+		    goto invalid_select;
+		  ++q;
+		}
+
+	      if (arg != NULL
+		  && default_arg (arg, q - arg))
+		{
+		  skip = 1;
+		  break;
+		}
+
+	      if (*q == ' ')
+		++q;
+	    }
+	}
+
+      if (! skip)
+	{
+	  const char *p1;
+
+	  for (p1 = last_path; p1 < p && *p1 != ':'; p1++)
+	    putchar (*p1);
+	  putchar (';');
+	}
+
+      ++p;
+      while (*p != ';')
+	{
+	  int use_arg;
+
+	  if (*p == '\0')
+	    goto invalid_select;
+
+	  if (skip)
+	    {
+	      ++p;
+	      continue;
+	    }
+
+	  use_arg = *p != '!';
+
+	  if (use_arg)
+	    putchar ('@');
+
+	  while (*p != ' ' && *p != ';')
+	    {
+	      if (*p == '\0')
+		goto invalid_select;
+	      if (use_arg)
+		putchar (*p);
+	      ++p;
+	    }
+
+	  if (*p == ' ')
+	    ++p;
+	}
+
+      if (! skip)
+	{
+	  /* If there are extra options, print them now.  */
+	  if (multilib_extra && *multilib_extra)
+	    {
+	      int print_at = TRUE;
+	      const char *q;
+
+	      for (q = multilib_extra; *q != '\0'; q++)
+		{
+		  if (*q == ' ')
+		    print_at = TRUE;
+		  else
+		    {
+		      if (print_at)
+			putchar ('@');
+		      putchar (*q);
+		      print_at = FALSE;
+		    }
+		}
+	    }
+
+	  putchar ('\n');
+	}
+
+      ++p;
+    }
+}
+
+/* if-exists built-in spec function.
+
+   Checks to see if the file specified by the absolute pathname in
+   ARGS exists.  Returns that pathname if found.
+
+   The usual use for this function is to check for a library file
+   (whose name has been expanded with %s).  */
+
+static const char *
+if_exists_spec_function (int argc, const char **argv)
+{
+  /* Must have only one argument.  */
+  if (argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
+    return argv[0];
+
+  return NULL;
+}
+
+/* if-exists-else built-in spec function.
+
+   This is like if-exists, but takes an additional argument which
+   is returned if the first argument does not exist.  */
+
+static const char *
+if_exists_else_spec_function (int argc, const char **argv)
+{
+  /* Must have exactly two arguments.  */
+  if (argc != 2)
+    return NULL;
+
+  if (IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
+    return argv[0];
+
+  return argv[1];
+}
+
+/* replace-outfile built-in spec function.
+
+   This looks for the first argument in the outfiles array's name and
+   replaces it with the second argument.  */
+
+static const char *
+replace_outfile_spec_function (int argc, const char **argv)
+{
+  int i;
+  /* Must have exactly two arguments.  */
+  if (argc != 2)
+    abort ();
+
+  for (i = 0; i < n_infiles; i++)
+    {
+      if (outfiles[i] && !strcmp (outfiles[i], argv[0]))
+	outfiles[i] = xstrdup (argv[1]);
+    }
+  return NULL;
+}
+
+/* Given two version numbers, compares the two numbers.
+   A version number must match the regular expression
+   ([1-9][0-9]*|0)(\.([1-9][0-9]*|0))*
+*/
+static int
+compare_version_strings (const char *v1, const char *v2)
+{
+  int rresult;
+  regex_t r;
+
+  if (regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",
+	       REG_EXTENDED | REG_NOSUB) != 0)
+    abort ();
+  rresult = regexec (&r, v1, 0, NULL, 0);
+  if (rresult == REG_NOMATCH)
+    fatal ("invalid version number `%s'", v1);
+  else if (rresult != 0)
+    abort ();
+  rresult = regexec (&r, v2, 0, NULL, 0);
+  if (rresult == REG_NOMATCH)
+    fatal ("invalid version number `%s'", v2);
+  else if (rresult != 0)
+    abort ();
+
+  return strverscmp (v1, v2);
+}
+
+
+/* version_compare built-in spec function.
+
+   This takes an argument of the following form:
+
+   <comparison-op> <arg1> [<arg2>] <switch> <result>
+
+   and produces "result" if the comparison evaluates to true,
+   and nothing if it doesn't.
+
+   The supported <comparison-op> values are:
+
+   >=  true if switch is a later (or same) version than arg1
+   !>  opposite of >=
+   <   true if switch is an earlier version than arg1
+   !<  opposite of <
+   ><  true if switch is arg1 or later, and earlier than arg2
+   <>  true if switch is earlier than arg1 or is arg2 or later
+
+   If the switch is not present, the condition is false unless
+   the first character of the <comparison-op> is '!'.
+
+   For example,
+   %:version-compare(>= 10.3 mmacosx-version-min= -lmx)
+   adds -lmx if -mmacosx-version-min=10.3.9 was passed.  */
+
+static const char *
+version_compare_spec_function (int argc, const char **argv)
+{
+  int comp1, comp2;
+  size_t switch_len;
+  const char *switch_value = NULL;
+  int nargs = 1, i;
+  bool result;
+
+  if (argc < 3)
+    fatal ("too few arguments to %%:version-compare");
+  if (argv[0][0] == '\0')
+    abort ();
+  if ((argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!')
+    nargs = 2;
+  if (argc != nargs + 3)
+    fatal ("too many arguments to %%:version-compare");
+
+  switch_len = strlen (argv[nargs + 1]);
+  for (i = 0; i < n_switches; i++)
+    if (!strncmp (switches[i].part1, argv[nargs + 1], switch_len)
+	&& check_live_switch (i, switch_len))
+      switch_value = switches[i].part1 + switch_len;
+
+  if (switch_value == NULL)
+    comp1 = comp2 = -1;
+  else
+    {
+      comp1 = compare_version_strings (switch_value, argv[1]);
+      if (nargs == 2)
+	comp2 = compare_version_strings (switch_value, argv[2]);
+      else
+	comp2 = -1;  /* This value unused.  */
+    }
+
+  switch (argv[0][0] << 8 | argv[0][1])
+    {
+    case '>' << 8 | '=':
+      result = comp1 >= 0;
+      break;
+    case '!' << 8 | '<':
+      result = comp1 >= 0 || switch_value == NULL;
+      break;
+    case '<' << 8:
+      result = comp1 < 0;
+      break;
+    case '!' << 8 | '>':
+      result = comp1 < 0 || switch_value == NULL;
+      break;
+    case '>' << 8 | '<':
+      result = comp1 >= 0 && comp2 < 0;
+      break;
+    case '<' << 8 | '>':
+      result = comp1 < 0 || comp2 >= 0;
+      break;
+
+    default:
+      fatal ("unknown operator '%s' in %%:version-compare", argv[0]);
+    }
+  if (! result)
+    return NULL;
+
+  return argv[nargs + 2];
+}
diff --git a/gcc/java/Make-lang.in b/gcc/java/Make-lang.in
index 458d65b..c2c85dc 100644
--- a/gcc/java/Make-lang.in
+++ b/gcc/java/Make-lang.in
@@ -67,9 +67,9 @@ jvspec.o: $(srcdir)/java/jvspec.c $(SYSTEM_H) coretypes.h $(TM_H) \
 		$(INCLUDES) $(srcdir)/java/jvspec.c $(OUTPUT_OPTION))
 
 # Create the compiler driver for $(GCJ).
-$(GCJ)$(exeext): gcc.o jvspec.o version.o \
+$(GCJ)$(exeext): $(GCC_OBJS) jvspec.o version.o \
 	   prefix.o intl.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
-	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o jvspec.o prefix.o intl.o \
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) jvspec.o prefix.o intl.o \
 	  version.o $(EXTRA_GCC_OBJS) $(LIBS)
 
 # Create a version of the $(GCJ) driver which calls the cross-compiler.
diff --git a/gcc/optc-gen.awk b/gcc/optc-gen.awk
index 065972b..98c732b 100644
--- a/gcc/optc-gen.awk
+++ b/gcc/optc-gen.awk
@@ -62,20 +62,27 @@ for (i = 1; i <= n_headers; i++)
 print "#include " quote "opts.h" quote
 print "#include " quote "intl.h" quote
 print ""
+print "int target_flags;"
+print ""
 
 for (i = 0; i < n_opts; i++) {
 	name = var_name(flags[i]);
 	if (name == "")
 		continue;
 
-	if (flag_set_p("VarExists", flags[i]))
-		continue;
-
-	init = opt_args("Init", flags[i])
-	if (init != "")
-		init = " = " init;
-	else if (name in var_seen)
-		continue;
+	if (flag_set_p("VarExists", flags[i])) {
+		# Need it for the gcc driver.
+		if (name in var_seen)
+			continue;
+		init = ""
+	}
+	else {
+		init = opt_args("Init", flags[i])
+		if (init != "")
+			init = " = " init;
+		else if (name in var_seen)
+			continue;
+	}
 
 	print "/* Set by -" opts[i] "."
 	print "   " help[i] "  */"
@@ -107,8 +114,22 @@ print "const unsigned int cl_options_count = N_OPTS;\n"
 
 print "const struct cl_option cl_options[] =\n{"
 
-for (i = 0; i < n_opts; i++)
+j = 0
+for (i = 0; i < n_opts; i++) {
 	back_chain[i] = "N_OPTS";
+	indices[opts[i]] = j;
+	# Combine the flags of identical switches.  Switches
+	# appear many times if they are handled by many front
+	# ends, for example.
+	while( i + 1 != n_opts && opts[i] == opts[i + 1] ) {
+		flags[i + 1] = flags[i] " " flags[i + 1];
+		i++;
+		back_chain[i] = "N_OPTS";
+		indices[opts[i]] = j;
+	}
+	j++;
+}
+
 
 for (i = 0; i < n_opts; i++) {
 	# Combine the flags of identical switches.  Switches
@@ -147,8 +168,22 @@ for (i = 0; i < n_opts; i++) {
 	else
 		hlp = quote help[i] quote;
 
-	printf("  { %c-%s%c,\n    %s,\n    %s, %u,\n",
-	       quote, opts[i], quote, hlp, back_chain[i], len)
+	neg = opt_args("Negative", flags[i]);
+	if (neg != "")
+		idx = indices[neg]
+	else {
+	if (flag_set_p("RejectNegative", flags[i]))
+		idx = -1;
+	else {
+			if (opts[i] ~ "^[Wfm]")
+				idx = indices[opts[i]];
+			else
+				idx = -1;
+		}
+	}
+	printf("  { %c-%s%c,\n    %s,\n    %s, %u, %d,\n",
+	       quote, opts[i], quote, hlp, back_chain[i], len, idx)
+
 	condition = opt_args("Condition", flags[i])
 	cl_flags = switch_flags(flags[i])
 	if (condition != "")
diff --git a/gcc/opts-common.c b/gcc/opts-common.c
new file mode 100644
index 0000000..958e667
--- /dev/null
+++ b/gcc/opts-common.c
@@ -0,0 +1,237 @@
+/* Command line option handling.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include "intl.h"
+#include "coretypes.h"
+#include "opts.h"
+
+/* Perform a binary search to find which option the command-line INPUT
+   matches.  Returns its index in the option array, and N_OPTS
+   (cl_options_count) on failure.
+
+   This routine is quite subtle.  A normal binary search is not good
+   enough because some options can be suffixed with an argument, and
+   multiple sub-matches can occur, e.g. input of "-pedantic" matching
+   the initial substring of "-pedantic-errors".
+
+   A more complicated example is -gstabs.  It should match "-g" with
+   an argument of "stabs".  Suppose, however, that the number and list
+   of switches are such that the binary search tests "-gen-decls"
+   before having tested "-g".  This doesn't match, and as "-gen-decls"
+   is less than "-gstabs", it will become the lower bound of the
+   binary search range, and "-g" will never be seen.  To resolve this
+   issue, opts.sh makes "-gen-decls" point, via the back_chain member,
+   to "-g" so that failed searches that end between "-gen-decls" and
+   the lexicographically subsequent switch know to go back and see if
+   "-g" causes a match (which it does in this example).
+
+   This search is done in such a way that the longest match for the
+   front end in question wins.  If there is no match for the current
+   front end, the longest match for a different front end is returned
+   (or N_OPTS if none) and the caller emits an error message.  */
+size_t
+find_opt (const char *input, int lang_mask)
+{
+  size_t mn, mx, md, opt_len;
+  size_t match_wrong_lang;
+  int comp;
+
+  mn = 0;
+  mx = cl_options_count;
+
+  /* Find mn such this lexicographical inequality holds:
+     cl_options[mn] <= input < cl_options[mn + 1].  */
+  while (mx - mn > 1)
+    {
+      md = (mn + mx) / 2;
+      opt_len = cl_options[md].opt_len;
+      comp = strncmp (input, cl_options[md].opt_text + 1, opt_len);
+
+      if (comp < 0)
+	mx = md;
+      else
+	mn = md;
+    }
+
+  /* This is the switch that is the best match but for a different
+     front end, or cl_options_count if there is no match at all.  */
+  match_wrong_lang = cl_options_count;
+
+  /* Backtrace the chain of possible matches, returning the longest
+     one, if any, that fits best.  With current GCC switches, this
+     loop executes at most twice.  */
+  do
+    {
+      const struct cl_option *opt = &cl_options[mn];
+
+      /* Is the input either an exact match or a prefix that takes a
+	 joined argument?  */
+      if (!strncmp (input, opt->opt_text + 1, opt->opt_len)
+	  && (input[opt->opt_len] == '\0' || (opt->flags & CL_JOINED)))
+	{
+	  /* If language is OK, return it.  */
+	  if (opt->flags & lang_mask)
+	    return mn;
+
+	  /* If we haven't remembered a prior match, remember this
+	     one.  Any prior match is necessarily better.  */
+	  if (match_wrong_lang == cl_options_count)
+	    match_wrong_lang = mn;
+	}
+
+      /* Try the next possibility.  This is cl_options_count if there
+	 are no more.  */
+      mn = opt->back_chain;
+    }
+  while (mn != cl_options_count);
+
+  /* Return the best wrong match, or cl_options_count if none.  */
+  return match_wrong_lang;
+}
+
+/* Return true if NEXT_OPT_IDX cancels OPT_IDX.  Return false if the
+   next one is the same as ORIG_NEXT_OPT_IDX.  */
+
+static bool
+cancel_option (int opt_idx, int next_opt_idx, int orig_next_opt_idx)
+{
+  /* An option can be canceled by the same option or an option with
+     Negative.  */
+  if (cl_options [next_opt_idx].neg_index == opt_idx)
+    return true;
+
+  if (cl_options [next_opt_idx].neg_index != orig_next_opt_idx)
+    return cancel_option (opt_idx, cl_options [next_opt_idx].neg_index,
+			  orig_next_opt_idx);
+    
+  return false;
+}
+
+/* Filter out options canceled by the ones after them.  */
+
+void
+prune_options (int *argcp, char ***argvp)
+{
+  int argc = *argcp;
+  int *options = xmalloc (argc * sizeof (*options));
+  char **argv = xmalloc (argc * sizeof (char *));
+  int i, arg_count, need_prune = 0;
+  const struct cl_option *option;
+  size_t opt_index;
+
+  /* Scan all arguments.  */
+  for (i = 1; i < argc; i++)
+    {
+      int value = 1;
+      const char *opt = (*argvp) [i];
+
+      opt_index = find_opt (opt + 1, -1);
+      if (opt_index == cl_options_count
+	  && (opt[1] == 'W' || opt[1] == 'f' || opt[1] == 'm')
+	  && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')
+	{
+	  char *dup;
+
+	  /* Drop the "no-" from negative switches.  */
+	  size_t len = strlen (opt) - 3;
+
+	  dup = XNEWVEC (char, len + 1);
+	  dup[0] = '-';
+	  dup[1] = opt[1];
+	  memcpy (dup + 2, opt + 5, len - 2 + 1);
+	  opt = dup;
+	  value = 0;
+	  opt_index = find_opt (opt + 1, -1);
+	  free (dup);
+	}
+
+      if (opt_index == cl_options_count)
+	{
+cont:
+	  options [i] = 0;
+	  continue;
+	}
+
+      option = &cl_options[opt_index];
+      if (option->neg_index < 0)
+	goto cont;
+
+      /* Skip joined switches.  */
+      if ((option->flags & CL_JOINED))
+	goto cont;
+
+      /* Reject negative form of switches that don't take negatives as
+	 unrecognized.  */
+      if (!value && (option->flags & CL_REJECT_NEGATIVE))
+	goto cont;
+
+      options [i] = (int) opt_index;
+      need_prune |= options [i];
+    }
+
+  if (!need_prune)
+    goto done;
+
+  /* Remove arguments which are negated by others after them.  */
+  argv [0] = (*argvp) [0];
+  arg_count = 1;
+  for (i = 1; i < argc; i++)
+    {
+      int j, opt_idx;
+
+      opt_idx = options [i];
+      if (opt_idx)
+	{
+	  int next_opt_idx;
+	  for (j = i + 1; j < argc; j++)
+	    {
+	      next_opt_idx = options [j];
+	      if (next_opt_idx
+		  && cancel_option (opt_idx, next_opt_idx,
+				    next_opt_idx))
+		break;
+	    }
+	}
+      else
+	goto keep;
+
+      if (j == argc)
+	{
+keep:
+	  argv [arg_count] = (*argvp) [i];
+	  arg_count++;
+	}
+    }
+
+  if (arg_count != argc)
+    {
+      *argcp = arg_count;
+      *argvp = argv;
+    }
+  else
+    {
+done:
+      free (argv);
+    }
+
+  free (options);
+}
diff --git a/gcc/opts.c b/gcc/opts.c
index e264b4a..037cad2 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -101,7 +101,6 @@ static bool flag_loop_optimize_set;
 const char **in_fnames;
 unsigned num_in_fnames;
 
-static size_t find_opt (const char *, int);
 static int common_handle_option (size_t scode, const char *arg, int value);
 static void handle_param (const char *);
 static void set_Wextra (int);
@@ -119,90 +118,6 @@ static unsigned int print_switch (const char *text, unsigned int indent);
 static void set_debug_level (enum debug_info_type type, int extended,
 			     const char *arg);
 
-/* Perform a binary search to find which option the command-line INPUT
-   matches.  Returns its index in the option array, and N_OPTS
-   (cl_options_count) on failure.
-
-   This routine is quite subtle.  A normal binary search is not good
-   enough because some options can be suffixed with an argument, and
-   multiple sub-matches can occur, e.g. input of "-pedantic" matching
-   the initial substring of "-pedantic-errors".
-
-   A more complicated example is -gstabs.  It should match "-g" with
-   an argument of "stabs".  Suppose, however, that the number and list
-   of switches are such that the binary search tests "-gen-decls"
-   before having tested "-g".  This doesn't match, and as "-gen-decls"
-   is less than "-gstabs", it will become the lower bound of the
-   binary search range, and "-g" will never be seen.  To resolve this
-   issue, opts.sh makes "-gen-decls" point, via the back_chain member,
-   to "-g" so that failed searches that end between "-gen-decls" and
-   the lexicographically subsequent switch know to go back and see if
-   "-g" causes a match (which it does in this example).
-
-   This search is done in such a way that the longest match for the
-   front end in question wins.  If there is no match for the current
-   front end, the longest match for a different front end is returned
-   (or N_OPTS if none) and the caller emits an error message.  */
-static size_t
-find_opt (const char *input, int lang_mask)
-{
-  size_t mn, mx, md, opt_len;
-  size_t match_wrong_lang;
-  int comp;
-
-  mn = 0;
-  mx = cl_options_count;
-
-  /* Find mn such this lexicographical inequality holds:
-     cl_options[mn] <= input < cl_options[mn + 1].  */
-  while (mx - mn > 1)
-    {
-      md = (mn + mx) / 2;
-      opt_len = cl_options[md].opt_len;
-      comp = strncmp (input, cl_options[md].opt_text + 1, opt_len);
-
-      if (comp < 0)
-	mx = md;
-      else
-	mn = md;
-    }
-
-  /* This is the switch that is the best match but for a different
-     front end, or cl_options_count if there is no match at all.  */
-  match_wrong_lang = cl_options_count;
-
-  /* Backtrace the chain of possible matches, returning the longest
-     one, if any, that fits best.  With current GCC switches, this
-     loop executes at most twice.  */
-  do
-    {
-      const struct cl_option *opt = &cl_options[mn];
-
-      /* Is the input either an exact match or a prefix that takes a
-	 joined argument?  */
-      if (!strncmp (input, opt->opt_text + 1, opt->opt_len)
-	  && (input[opt->opt_len] == '\0' || (opt->flags & CL_JOINED)))
-	{
-	  /* If language is OK, return it.  */
-	  if (opt->flags & lang_mask)
-	    return mn;
-
-	  /* If we haven't remembered a prior match, remember this
-	     one.  Any prior match is necessarily better.  */
-	  if (match_wrong_lang == cl_options_count)
-	    match_wrong_lang = mn;
-	}
-
-      /* Try the next possibility.  This is cl_options_count if there
-	 are no more.  */
-      mn = opt->back_chain;
-    }
-  while (mn != cl_options_count);
-
-  /* Return the best wrong match, or cl_options_count if none.  */
-  return match_wrong_lang;
-}
-
 /* If ARG is a non-negative integer made up solely of digits, return its
    value, otherwise return -1.  */
 static int
diff --git a/gcc/opts.h b/gcc/opts.h
index 2c2340c..8f0e979 100644
--- a/gcc/opts.h
+++ b/gcc/opts.h
@@ -46,6 +46,7 @@ struct cl_option
   const char *help;
   unsigned short back_chain;
   unsigned char opt_len;
+  int neg_index;
   unsigned int flags;
   void *flag_var;
   enum cl_var_type var_type;
@@ -83,6 +84,8 @@ extern const char **in_fnames;
 
 extern unsigned num_in_fnames;
 
+size_t find_opt (const char *input, int lang_mask);
+extern void prune_options (int *argcp, char ***argvp);
 extern void decode_options (unsigned int argc, const char **argv);
 extern int option_enabled (int opt_idx);
 extern bool get_option_state (int, struct cl_option_state *);
diff --git a/gcc/treelang/Make-lang.in b/gcc/treelang/Make-lang.in
index 57499e5..26ac3ee 100644
--- a/gcc/treelang/Make-lang.in
+++ b/gcc/treelang/Make-lang.in
@@ -87,10 +87,10 @@ tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/tree-convert.o \
 	$(BACKEND) $(LIBS) attribs.o
 
 # Create the compiler driver treelang.
-gtreelang$(exeext): gcc.o version.o prefix.o intl.o $(EXTRA_GCC_OBJS) \
+gtreelang$(exeext): $(GCC_OBJS) version.o prefix.o intl.o $(EXTRA_GCC_OBJS) \
   $(LIBDEPS) treelang/spec.o
 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ treelang/spec.o \
-	  gcc.o version.o prefix.o intl.o $(EXTRA_GCC_OBJS) $(LIBS)
+	  $(GCC_OBJS) version.o prefix.o intl.o $(EXTRA_GCC_OBJS) $(LIBS)
 
 
 
-- 
1.5.3.8

