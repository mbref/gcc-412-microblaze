From 7a4a1b91002044a4d0ed5c325f79665a82f08e46 Mon Sep 17 00:00:00 2001
Message-Id: <7a4a1b91002044a4d0ed5c325f79665a82f08e46.1241484428.git.john.williams@petalogix.com>
In-Reply-To: <930a7bf07b58a3d6a48393a6419b2c958fc9dc2a.1241484427.git.john.williams@petalogix.com>
References: <930a7bf07b58a3d6a48393a6419b2c958fc9dc2a.1241484427.git.john.williams@petalogix.com>
From: John Williams <john.williams@petalogix.com>
Date: Tue, 28 Apr 2009 14:39:26 +1000
Subject: [PATCH 23/63] microblaze: Default to dwarf2 debug

---
 gcc/config/microblaze/microblaze.c      |   71 +
 gcc/config/microblaze/microblaze.c.orig | 5229 +++++++++++++++++++++++++++++++
 gcc/config/microblaze/microblaze.h      |   79 +-
 gcc/config/microblaze/microblaze.h.orig | 3345 ++++++++++++++++++++
 4 files changed, 8654 insertions(+), 70 deletions(-)
 create mode 100644 gcc/config/microblaze/microblaze.c.orig
 create mode 100644 gcc/config/microblaze/microblaze.h.orig

diff --git a/gcc/config/microblaze/microblaze.c b/gcc/config/microblaze/microblaze.c
index 00c5b94..0aaceeb 100644
--- a/gcc/config/microblaze/microblaze.c
+++ b/gcc/config/microblaze/microblaze.c
@@ -5227,3 +5227,74 @@ microblaze_must_save_register (int regno)
 
   return 0;
 }
+
+/* Output .ascii string. */
+void
+output_ascii (FILE *file, const char *string, int len)
+{
+  register int i, c, cur_pos = 17;
+  fprintf (file, "\t.ascii\t\"");
+  for (i = 0; i < len; i++)
+  {
+    register int c = string[i];
+
+    switch (c)
+    {
+      case '\"':
+      case '\\':
+	putc ('\\', file);
+	putc (c, file);
+	cur_pos += 2;
+	break;
+
+      case '\n':
+	fputs ("\\n", file);
+	if (i+1 < len
+	    && (((c = string[i+1]) >= '\040' && c <= '~')
+		  || c == '\t'))
+	  cur_pos = 32767;		/* break right here */
+	else
+	  cur_pos += 2;
+	break;
+
+      case '\t':
+	fputs ("\\t", file);
+	cur_pos += 2;
+	break;
+
+      case '\f':
+	fputs ("\\f", file);
+	cur_pos += 2;
+	break;
+
+      case '\b':
+	fputs ("\\b", file);
+	cur_pos += 2;
+	break;
+
+      case '\r':
+	fputs ("\\r", file);
+	cur_pos += 2;
+	break;
+
+      default:
+	if (c >= ' ' && c < 0177)
+	{
+	  putc (c, file);
+	  cur_pos++;
+	}
+	else
+	{
+	  fprintf (file, "\\%03o", c);
+	  cur_pos += 4;
+	}
+      }
+
+      if (cur_pos > 72 && i+1 < len)
+      {
+        cur_pos = 17;
+        fprintf (file, "\"\n\t.ascii\t\"");
+      }
+    }
+  fprintf (file, "\"\n");
+}
diff --git a/gcc/config/microblaze/microblaze.c.orig b/gcc/config/microblaze/microblaze.c.orig
new file mode 100644
index 0000000..00c5b94
--- /dev/null
+++ b/gcc/config/microblaze/microblaze.c.orig
@@ -0,0 +1,5229 @@
+/* Copyright (C) 1989, 90, 91, 93-98, 1999 Free Software Foundation, Inc.
+   This file is part of GNU CC.
+
+   GNU CC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU CC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU CC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/***************************************************************************************-*-C-*- 
+ * 
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ * 
+ * microblaze.c : Home
+ * 
+ * MicroBlaze specific file. Contains functions for generating MicroBlaze code
+ * Certain sections of code are from the Free Software Foundation
+ * 
+ * $Header: /devl/xcs/repo/env/Jobs/MDT/sw/ThirdParty/gnu/src/gcc/src-3.4/gcc/config/microblaze/microblaze.c,v 1.14.2.16 2006/05/22 15:25:27 vasanth Exp $
+ * 
+ *******************************************************************************/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include <signal.h>
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-flags.h"
+#include "insn-attr.h"
+#include "recog.h"
+#include "toplev.h"
+
+#undef MAX			/* sys/param.h may also define these */
+#undef MIN
+
+#include "tree.h"
+#include "function.h"
+#include "expr.h"
+#include "flags.h"
+#include "reload.h"
+#include "output.h"
+#include "ggc.h"
+#include "hashtab.h"
+#include "target.h"
+#include "target-def.h"
+#include "tm_p.h"
+
+
+#if defined(USG) || !defined(HAVE_STAB_H)
+#include "gstab.h"  /* If doing DBX on sysV, use our own stab.h.  */
+#else
+#include <stab.h>  /* On BSD, use the system's stab.h.  */
+#endif /* not USG */
+
+#ifdef __GNU_STAB__
+#define STAB_CODE_TYPE enum __stab_debug_code
+#else
+#define STAB_CODE_TYPE int
+#endif
+
+/* Enumeration for all of the relational tests, so that we can build
+   arrays indexed by the test type, and not worry about the order
+   of EQ, NE, etc. */
+
+enum internal_test {
+  ITEST_EQ,
+  ITEST_NE,
+  ITEST_GT,
+  ITEST_GE,
+  ITEST_LT,
+  ITEST_LE,
+  ITEST_GTU,
+  ITEST_GEU,
+  ITEST_LTU,
+  ITEST_LEU,
+  ITEST_MAX
+};
+
+/* Forward declaration for sruct constant */
+struct constant;
+
+/* Classifies an address.
+
+ADDRESS_INVALID
+An invalid address.
+
+ADDRESS_REG
+
+A natural register or a register + const_int offset address.  
+The register satisfies microblaze_valid_base_register_p and the 
+offset is a const_arith_operand.
+
+ADDRESS_REG_INDEX
+
+A natural register offset by the index contained in an index register. The base
+register satisfies microblaze_valid_base_register_p and the index register
+satisfies microblaze_valid_index_register_p
+
+ADDRESS_CONST_INT
+
+A signed 16/32-bit constant address.
+
+ADDRESS_SYMBOLIC:
+
+A constant symbolic address or a (register + symbol).  */
+
+enum microblaze_address_type {
+  ADDRESS_INVALID,
+  ADDRESS_REG,
+  ADDRESS_REG_INDEX,
+  ADDRESS_CONST_INT,
+  ADDRESS_SYMBOLIC
+};
+
+/* Classifies symbols
+
+SYMBOL_TYPE_GENERAL
+        
+A general symbol. */
+enum microblaze_symbol_type {
+  SYMBOL_TYPE_INVALID,
+  SYMBOL_TYPE_GENERAL
+};
+
+/* Classification of a Microblaze address */
+struct microblaze_address_info
+{
+  enum microblaze_address_type type;
+  rtx regA;                       /* Contains valid values on ADDRES_REG, ADDRESS_REG_INDEX, ADDRESS_SYMBOLIC */
+  rtx regB;                       /* Contains valid values on ADDRESS_REG_INDEX */
+  rtx offset;                     /* Contains valid values on ADDRESS_CONST_INT and ADDRESS_REG */
+  rtx symbol;                     /* Contains valid values on ADDRESS_SYMBOLIC */
+  enum microblaze_symbol_type symbol_type;
+};
+
+static void microblaze_encode_section_info	PARAMS ((tree, rtx, int));
+static void microblaze_globalize_label          PARAMS ((FILE*, const char*));
+void  microblaze_declare_comm_object            PARAMS ((FILE *, char *, char *, char *, int size, int align));
+static void microblaze_unique_section           PARAMS ((tree, int));
+static void microblaze_function_prologue        PARAMS ((FILE*, int));
+static void microblaze_function_epilogue        PARAMS ((FILE*, HOST_WIDE_INT));
+static void microblaze_asm_file_start           PARAMS ((void));
+static void microblaze_asm_file_end             PARAMS ((void));
+static char* microblaze_fill_delay_slot         PARAMS ((char *, enum delay_type ,rtx [],rtx ));
+static void microblaze_count_memory_refs        PARAMS ((rtx, int));
+static rtx embedded_pic_fnaddr_reg              PARAMS ((void));
+static void microblaze_internal_label           PARAMS ((FILE *, const char*, unsigned long));
+static bool microblaze_rtx_costs                PARAMS ((rtx, int, int, int*));
+static int microblaze_address_cost              PARAMS ((rtx));
+static int microblaze_address_insns             PARAMS ((rtx, enum machine_mode));
+static void microblaze_asm_constructor          PARAMS ((rtx, int));
+static void microblaze_asm_destructor           PARAMS ((rtx, int));
+static void microblaze_select_section           PARAMS ((tree, int, unsigned HOST_WIDE_INT));
+static void microblaze_select_rtx_section       PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));
+bool microblaze_legitimate_address_p            PARAMS ((enum machine_mode, rtx, int ));
+rtx  microblaze_legitimize_address              PARAMS ((rtx , rtx, enum machine_mode));
+int microblaze_regno_ok_for_base_p              PARAMS ((int, int));
+static const char* microblaze_mode_to_mem_modifier    PARAMS ((int, enum machine_mode));
+static bool microblaze_valid_base_register_p    PARAMS ((rtx, enum machine_mode, int));
+static bool microblaze_valid_index_register_p   PARAMS ((rtx, enum machine_mode, int));
+static bool microblaze_classify_address         PARAMS ((struct microblaze_address_info *, rtx, enum machine_mode, int));
+HOST_WIDE_INT compute_frame_size                PARAMS ((HOST_WIDE_INT));
+int double_memory_operand                       PARAMS ((rtx, enum machine_mode));
+void microblaze_output_filename                 PARAMS ((FILE*, const char*));
+HOST_WIDE_INT microblaze_initial_elimination_offset 
+                                                PARAMS ((int, int));
+int microblaze_sched_use_dfa_pipeline_interface PARAMS ((void));
+void microblaze_function_end_prologue           PARAMS ((FILE *));
+static enum internal_test map_test_to_internal_test	
+                                                PARAMS ((enum rtx_code));
+static void block_move_loop			PARAMS ((rtx, rtx, int, int, rtx, rtx));
+static void block_move_call			PARAMS ((rtx, rtx, rtx));
+static void save_restore_insns			PARAMS ((int));
+static rtx add_constant				PARAMS ((struct constant **, rtx, enum machine_mode));
+static void dump_constants			PARAMS ((struct constant *, rtx));
+static int microblaze_version_to_int            PARAMS ((const char *));
+static int microblaze_version_compare           PARAMS ((const char *, const char *));
+void microblaze_order_regs_for_local_alloc 	PARAMS ((void));
+void print_operand 				PARAMS ((FILE *, rtx, int));
+void print_operand_address 			PARAMS ((FILE *, rtx));
+int microblaze_output_external 			PARAMS ((FILE *, tree, char *));
+void final_prescan_insn 			PARAMS ((rtx, rtx *, int));
+void microblaze_internal_label 			PARAMS ((FILE *, const char*, unsigned long));
+void microblaze_output_float 			PARAMS ((FILE *, REAL_VALUE_TYPE value));
+int microblaze_can_use_return_insn 		PARAMS ((void));
+enum reg_class microblaze_secondary_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx, int));
+int simple_memory_operand 			PARAMS ((rtx, enum machine_mode));
+void trace 					PARAMS ((const char *, const char *, const char *));
+void gen_conditional_branch 			PARAMS ((rtx *, enum rtx_code));
+void init_cumulative_args 			PARAMS ((CUMULATIVE_ARGS *,tree, rtx));
+void function_arg_advance 			PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));
+struct rtx_def *function_arg 			PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));
+int function_arg_partial_nregs 			PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));
+HOST_WIDE_INT microblaze_debugger_offset 	PARAMS ((rtx, HOST_WIDE_INT));
+void microblaze_output_lineno 			PARAMS ((FILE *, int));
+void microblaze_internal_label 			PARAMS ((FILE *, const char*, unsigned long));
+void microblaze_output_double 			PARAMS ((FILE *, REAL_VALUE_TYPE));
+static int microblaze_save_volatiles 		PARAMS ((tree func));
+const char* microblaze_move_2words 		PARAMS ((rtx *, rtx));
+const char * output_block_move 			PARAMS ((rtx, rtx *, int, enum block_move_type));
+void microblaze_declare_object 			PARAMS ((FILE *, char *, char *, char *, int));
+int microblaze_valid_machine_decl_attribute 	PARAMS ((tree, tree, tree, tree));
+static bool microblaze_handle_option 		PARAMS ((size_t, const char *, int));
+int microblaze_is_interrupt_handler		PARAMS ((void));
+int microblaze_const_double_ok 			PARAMS ((rtx, enum machine_mode));
+static int microblaze_must_save_register 	PARAMS ((int));
+
+/* Global variables for machine-dependent things.  */
+
+struct microblaze_cpu_select microblaze_select =
+{
+  MICROBLAZE_DEFAULT_CPU,                 /* CPU      */
+  "none",                                 /* Tuning   */
+  0                                       /* Flags    */
+};
+
+/* Toggle which pipleline interface to use */
+int microblaze_sched_use_dfa = 0;
+
+/* Threshold for data being put into the small data/bss area, instead
+   of the normal data area (references to the small data/bss area take
+   1 instruction, and use the global pointer, references to the normal
+   data area takes 2 instructions).  */
+int microblaze_section_threshold = -1;
+
+/* Prevent scheduling potentially exception causing instructions in delay slots.
+   -mcpu=v3.00.a or v4.00.a turns this on.
+*/
+int microblaze_no_unsafe_delay;
+
+/* Count the number of .file directives, so that .loc is up to date.  */
+int num_source_filenames = 0;
+
+/* Count the number of sdb related labels are generated (to find block
+   start and end boundaries).  */
+int sdb_label_count = 0;
+
+/* Next label # for each statement for Silicon Graphics IRIS systems. */
+int sym_lineno = 0;
+
+/* Non-zero if inside of a function, because the stupid asm can't
+   handle .files inside of functions.  */
+int inside_function = 0;
+
+/* Files to separate the text and the data output, so that all of the data
+   can be emitted before the text, which will mean that the assembler will
+   generate smaller code, based on the global pointer.  */
+FILE *asm_out_data_file;
+FILE *asm_out_text_file;
+
+
+/* Linked list of all externals that are to be emitted when optimizing
+   for the global pointer if they haven't been declared by the end of
+   the program with an appropriate .comm or initialization.  */
+
+struct extern_list
+{
+  struct extern_list *next;	/* next external */
+  char *name;			/* name of the external */
+  int size;			/* size in bytes */
+} *extern_head = 0;
+
+/* Name of the file containing the current function.  */
+const char *current_function_file = "";
+
+int file_in_function_warning = FALSE;
+
+/* Whether to suppress issuing .loc's because the user attempted
+   to change the filename within a function.  */
+int ignore_line_number = FALSE;
+
+/* Number of nested .set noreorder, noat, nomacro, and volatile requests.  */
+int set_noreorder;
+int set_noat;
+int set_nomacro;
+int set_volatile;
+
+
+/* Count of delay slots and how many are filled.  */
+int dslots_load_total;
+int dslots_load_filled;
+int dslots_jump_total;
+int dslots_jump_filled;
+
+/* # of nops needed by previous insn */
+int dslots_number_nops;
+
+/* Number of 1/2/3 word references to data items (ie, not brlid's).  */
+int num_refs[3];
+
+/* registers to check for load delay */
+rtx microblaze_load_reg, microblaze_load_reg2, microblaze_load_reg3, microblaze_load_reg4;
+
+/* Cached operands, and operator to compare for use in set/branch on
+   condition codes.  */
+rtx branch_cmp[2];
+
+/* what type of branch to use */
+enum cmp_type branch_type;
+
+/* Number of previously seen half-pic pointers and references.  */
+static int prev_half_pic_ptrs = 0;
+static int prev_half_pic_refs = 0;
+
+/* Which CPU pipeline do we use. We haven't really standardized on a CPU version 
+   having only a particular type of pipeline. There can still be options on the CPU 
+   to scale pipeline features up or down. :( Bad Presentation (??), so we let the
+   MD file rely on the value of this variable instead 
+   Making PIPE_5 the default. It should be backward optimal with PIPE_3 MicroBlazes */
+enum pipeline_type microblaze_pipe = MICROBLAZE_PIPE_5;
+
+/* Generating calls to position independent functions?  */
+enum microblaze_abicalls_type microblaze_abicalls;
+
+/* High and low marks for floating point values which we will accept
+   as legitimate constants for LEGITIMATE_CONSTANT_P.  These are
+   initialized in override_options.  */
+REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;
+
+/* Mode used for saving/restoring general purpose registers.  */
+static enum machine_mode gpr_mode;
+
+/* Array giving truth value on whether or not a given hard register
+   can support a given mode.  */
+char microblaze_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];
+
+/* Current frame information calculated by compute_frame_size.  */
+struct microblaze_frame_info current_frame_info;
+
+/* Zero structure to initialize current_frame_info.  */
+struct microblaze_frame_info zero_frame_info;
+
+/* Temporary filename used to buffer .text until end of program
+   for -mgpopt.  */
+static char *temp_filename;
+
+/* Pseudo-reg holding the address of the current function when
+   generating embedded PIC code.  Created by LEGITIMIZE_ADDRESS, used
+   by microblaze_finalize_pic if it was created.  */
+rtx embedded_pic_fnaddr_rtx;
+
+struct string_constant
+{
+  struct string_constant *next;
+  char *label;
+};
+
+static struct string_constant *string_constants;
+
+/* List of all MICROBLAZE punctuation characters used by print_operand.  */
+char microblaze_print_operand_punct[256];
+
+/* Map GCC register number to debugger register number.  */
+int microblaze_dbx_regno[FIRST_PSEUDO_REGISTER];
+
+/* Hardware names for the registers.  If -mrnames is used, this
+   will be overwritten with microblaze_sw_reg_names.  */
+
+char microblaze_reg_names[][8] =
+{
+  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
+  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
+  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
+  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+  "hi",   "lo",   "accum","rmsr", "$fcc1","$fcc2","$fcc3","$fcc4",
+  "$fcc5","$fcc6","$fcc7","$ap",  "$rap", "$frp"
+};
+
+/* MicroBlaze software names for the registers, used to overwrite the
+   microblaze_reg_names array.  */
+
+char microblaze_sw_reg_names[][8] =
+{
+  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
+  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
+  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
+  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+  "hi",   "lo",   "accum","rmsr", "$fcc1","$fcc2","$fcc3","$fcc4",
+  "$fcc5","$fcc6","$fcc7","$ap",  "$rap", "$frp"
+};
+
+/* Map hard register number to register class */
+enum reg_class microblaze_regno_to_class[] =
+{
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  FP_REGS,	FP_REGS,	FP_REGS,	FP_REGS,
+  HI_REG,	LO_REG,		HILO_REG,	ST_REGS,
+  ST_REGS,	ST_REGS,	ST_REGS,	ST_REGS,
+  ST_REGS,	ST_REGS,	ST_REGS,	GR_REGS,
+  GR_REGS,    GR_REGS
+};
+
+/* Map register constraint character to register class.  */
+enum reg_class microblaze_char_to_class[256] =
+{
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+  NO_REGS,	NO_REGS,	NO_REGS,	NO_REGS,
+};
+
+int div_count = 0;
+extern void rodata_section(void);
+extern void sbss_section(void);
+extern void bss_section(void);
+extern void sdata2_section(void);
+int get_base_reg(rtx);
+static int printed = 0;
+enum load_store {LOAD = 0, STORE=1};
+char *format_load_store(char*, enum load_store,  enum machine_mode ,  rtx,int);
+static int prev_offset;
+
+/* True if the current function is an interrupt handler
+   (either via #pragma or an attribute specification).  */
+int interrupt_handler;
+int save_volatiles;
+
+/* Microblaze specific machine attributes.
+ * interrupt_handler - Interrupt handler attribute to add interrupt prologue and epilogue and use appropriate interrupt return.
+ * save_volatiles    - Similiar to interrupt handler, but use normal return.
+ */
+const struct attribute_spec microblaze_attribute_table[] = 
+{
+  /* name             , min_len, max_len, decl_req, type_req, fn_type, req_handler */
+  {"interrupt_handler", 0, 0, true, false, false, NULL},
+  {"save_volatiles"   , 0, 0, true, false, false, NULL},
+  { NULL,        0, 0, false, false, false, NULL }
+};
+
+static int microblaze_interrupt_function_p (tree);
+static int microblaze_save_volatiles (tree);
+
+#undef TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO      microblaze_encode_section_info
+
+#undef TARGET_ASM_GLOBALIZE_LABEL
+#define TARGET_ASM_GLOBALIZE_LABEL      microblaze_globalize_label
+
+#undef TARGET_UNIQUE_SECTION
+#define TARGET_UNIQUE_SECTION           microblaze_unique_section
+
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE    microblaze_function_prologue
+
+#undef TARGET_ASM_FUNCTION_EPILOGUE
+#define TARGET_ASM_FUNCTION_EPILOGUE    microblaze_function_epilogue
+
+#undef TARGET_ASM_INTERNAL_LABEL
+#define TARGET_ASM_INTERNAL_LABEL       microblaze_internal_label
+
+#undef TARGET_ASM_FILE_START
+#define TARGET_ASM_FILE_START           microblaze_asm_file_start 
+
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END             microblaze_asm_file_end
+
+#undef TARGET_RTX_COSTS          
+#define TARGET_RTX_COSTS                microblaze_rtx_costs
+
+#undef TARGET_ADDRESS_COST              
+#define TARGET_ADDRESS_COST             microblaze_address_cost
+
+#undef TARGET_ATTRIBUTE_TABLE           
+#define TARGET_ATTRIBUTE_TABLE          microblaze_attribute_table
+
+#undef TARGET_ASM_CONSTRUCTOR
+#define TARGET_ASM_CONSTRUCTOR          microblaze_asm_constructor
+
+#undef TARGET_ASM_DESTRUCTOR
+#define TARGET_ASM_DESTRUCTOR           microblaze_asm_destructor
+
+#undef TARGET_ASM_SELECT_RTX_SECTION   
+#define TARGET_ASM_SELECT_RTX_SECTION   microblaze_select_rtx_section
+
+#undef TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION       microblaze_select_section
+
+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \
+                                        microblaze_sched_use_dfa_pipeline_interface
+
+#undef TARGET_ASM_FUNCTION_END_PROLOGUE 
+#define TARGET_ASM_FUNCTION_END_PROLOGUE \
+                                        microblaze_function_end_prologue 
+
+#undef TARGET_HANDLE_OPTION
+#define TARGET_HANDLE_OPTION		microblaze_handle_option
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+/* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */
+
+int
+microblaze_const_double_ok (rtx op, enum machine_mode mode)
+{
+  REAL_VALUE_TYPE d;
+
+  if (GET_CODE (op) != CONST_DOUBLE)
+    return 0;
+
+  if (mode == VOIDmode)
+    return 1;
+
+  if (mode != SFmode && mode != DFmode)
+    return 0;
+
+  if (op == CONST0_RTX (mode))
+    return 1;
+
+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);
+
+  if (REAL_VALUE_ISNAN (d))
+    return FALSE;
+
+  if (REAL_VALUE_NEGATIVE (d))
+    d = REAL_VALUE_NEGATE (d);
+
+  if (mode == DFmode)
+  {
+    if (REAL_VALUES_LESS (d, dfhigh)
+        && REAL_VALUES_LESS (dflow, d))
+      return 1;
+  }
+  else
+  {
+    if (REAL_VALUES_LESS (d, sfhigh)
+        && REAL_VALUES_LESS (sflow, d))
+      return 1;
+  }
+
+  return 0;
+}
+
+/* Return truth value if a memory operand fits in a single instruction
+   (ie, register + small offset) or (register + register).  */
+
+int
+simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  rtx addr, plus0, plus1;
+
+  /* Eliminate non-memory operations */
+  if (GET_CODE (op) != MEM)
+    return 0;
+
+  /* dword operations really put out 2 instructions, so eliminate them.  */
+  /* ??? This isn't strictly correct.  It is OK to accept multiword modes
+     here, since the length attributes are being set correctly, but only
+     if the address is offsettable.  */
+  if (GET_MODE_SIZE (GET_MODE (op)) > UNITS_PER_WORD)
+    return 0;
+
+ 
+  /* Decode the address now.  */
+  addr = XEXP (op, 0);
+  switch (GET_CODE (addr))
+
+  {
+    case REG:
+      return 1;
+
+      /*    case CONST_INT:
+            return SMALL_INT (op);
+      */
+    case PLUS:
+      plus0 = XEXP (addr, 0);
+      plus1 = XEXP (addr, 1);
+
+      if (GET_CODE (plus0) == REG && GET_CODE (plus1) == CONST_INT && SMALL_INT (plus1)) {
+        return 1;
+      } else if (GET_CODE (plus1) == REG  && GET_CODE (plus0) == CONST_INT){
+        return 1;
+      } else if (GET_CODE (plus0) == REG  && GET_CODE (plus1) == REG) {
+        return 1;
+      } else 
+        return 0;
+
+    case SYMBOL_REF:
+      return 0;
+
+    default:
+      break;
+  }
+
+  return 0;
+}
+
+/* Return nonzero for a memory address that can be used to load or store
+   a doubleword.  */
+
+int
+double_memory_operand (rtx op, enum machine_mode mode)
+{
+  rtx addr;
+   
+  if (GET_CODE (op) != MEM
+      || ! memory_operand (op, mode))
+  {
+    /* During reload, we accept a pseudo register if it has an
+       appropriate memory address.  If we don't do this, we will
+       wind up reloading into a register, and then reloading that
+       register from memory, when we could just reload directly from
+       memory.  */
+    if (reload_in_progress
+        && GET_CODE (op) == REG
+        && REGNO (op) >= FIRST_PSEUDO_REGISTER
+        && reg_renumber[REGNO (op)] < 0
+        && reg_equiv_mem[REGNO (op)] != 0
+        && double_memory_operand (reg_equiv_mem[REGNO (op)], mode))
+      return 1;
+    return 0;
+  }
+
+  /* Make sure that 4 added to the address is a valid memory address.
+     This essentially just checks for overflow in an added constant.  */
+
+  addr = XEXP (op, 0);
+
+  if (CONSTANT_ADDRESS_P (addr))
+    return 1;
+
+  return memory_address_p ((GET_MODE_CLASS (mode) == MODE_INT
+                            ? SImode
+                            : SFmode),
+                           plus_constant (addr, 4));  
+}
+
+
+/* This hook is called many times during insn scheduling. If the hook 
+   returns nonzero, the automaton based pipeline description is used 
+   for insn scheduling. Otherwise the traditional pipeline description 
+   is used. The default is usage of the traditional pipeline description. */
+int microblaze_sched_use_dfa_pipeline_interface (void)
+{
+  return microblaze_sched_use_dfa; 
+}
+
+/* Write a message to stderr (for use in macros expanded in files that do not
+   include stdio.h).  */
+
+void
+trace (const char *s, const char *s1, const char *s2)
+{
+    fprintf (stderr, s, s1, s2);
+}
+
+
+/* Implement REG_OK_FOR_BASE_P -and- REG_OK_FOR_INDEX_P  */
+int
+microblaze_regno_ok_for_base_p (int regno, int strict)
+{
+  if (regno >= FIRST_PSEUDO_REGISTER)
+  {
+    if (!strict)
+      return true;
+    regno = reg_renumber[regno];
+  }
+
+  /* These fake registers will be eliminated to either the stack or
+     hard frame pointer, both of which are usually valid base registers.
+     Reload deals with the cases where the eliminated form isn't valid.  */
+  if (regno == ARG_POINTER_REGNUM || regno == FRAME_POINTER_REGNUM)
+    return true;
+
+  return GP_REG_P (regno);
+}
+
+/* Return true if X is a valid base register for the given mode.
+   Allow only hard registers if STRICT.  */
+
+static bool
+microblaze_valid_base_register_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED, int strict)
+{
+  if (!strict && GET_CODE (x) == SUBREG)
+    x = SUBREG_REG (x);
+
+  return (GET_CODE (x) == REG
+	  && microblaze_regno_ok_for_base_p (REGNO (x), strict));
+}
+
+/* Return true if X is a valid index register for the given mode.
+   Allow only hard registers if STRICT.  */
+
+static bool
+microblaze_valid_index_register_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED, int strict)
+{
+  if (!strict && GET_CODE (x) == SUBREG)
+    x = SUBREG_REG (x);
+
+  return (GET_CODE (x) == REG
+          /* A base register is good enough to be an index register on Microblaze */
+	  && microblaze_regno_ok_for_base_p (REGNO (x), strict));            
+}
+
+/* Return true if X is a valid address for machine mode MODE.  If it is,
+   fill in INFO appropriately.  STRICT is true if we should only accept
+   hard base registers.  
+
+      type                     regA      regB    offset      symbol
+
+   ADDRESS_INVALID             NULL      NULL     NULL        NULL
+
+   ADDRESS_REG                 %0        NULL     const_0 /   NULL
+                                                  const_int
+   ADDRESS_REG_INDEX           %0        %1       NULL        NULL
+
+   ADDRESS_SYMBOLIC            r0 /      NULL     NULL        symbol    
+                           sda_base_reg 
+
+   ADDRESS_CONST_INT           r0       NULL      const       NULL
+
+   For modes spanning multiple registers (DFmode in 32-bit GPRs,
+   DImode, TImode), indexed addressing cannot be used because
+   adjacent memory cells are accessed by adding word-sized offsets
+   during assembly output.  */
+
+static bool
+microblaze_classify_address (struct microblaze_address_info *info, rtx x,
+                             enum machine_mode mode, int strict)
+{
+  rtx xplus0;
+  rtx xplus1;
+    
+  info->type = ADDRESS_INVALID;
+  info->regA = NULL;
+  info->regB = NULL;
+  info->offset = NULL;
+  info->symbol = NULL;
+  info->symbol_type = SYMBOL_TYPE_INVALID;
+
+  switch (GET_CODE (x))
+  {
+    case REG:
+    case SUBREG:
+    {
+      info->type = ADDRESS_REG;
+      info->regA = x;
+      info->offset = const0_rtx;
+      return microblaze_valid_base_register_p (info->regA, mode, strict);
+    }   
+    case PLUS:
+    {
+      xplus0 = XEXP (x, 0);				
+      xplus1 = XEXP (x, 1);				
+            
+      if (microblaze_valid_base_register_p (xplus0, mode, strict)) {								
+        info->type = ADDRESS_REG;
+        info->regA = xplus0;
+
+        if (GET_CODE (xplus1) == CONST_INT) {
+          info->offset = xplus1;
+          return true;							
+        } else if (GET_CODE (xplus1) == SYMBOL_REF || 
+                   GET_CODE (xplus1) == LABEL_REF  || 
+                   GET_CODE (xplus1) == CONST) {                   
+/*           if ((GET_CODE (xplus1) == SYMBOL_REF) &&                  /\* Prevent small data symbols from being accessed off an incompatible base register *\/ */
+/*               ((get_base_reg (xplus1) == MB_ABI_BASE_REGNUM)  */
+/*                ? 0  */
+/*                : get_base_reg (xplus1) != REGNO (info->regA))) */
+/*             return false; */
+          info->type = ADDRESS_SYMBOLIC;
+          info->symbol = xplus1;
+          /* info->regA =  gen_rtx_raw_REG (mode, get_base_reg (xplus1)); */
+          info->symbol_type = SYMBOL_TYPE_GENERAL;
+          return true;
+        } else if (GET_CODE (xplus1) == REG && microblaze_valid_index_register_p (xplus1, mode, strict) &&
+                   (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)) {      /* Restrict larger than word-width modes from using an index register */
+          info->type = ADDRESS_REG_INDEX;
+          info->regB = xplus1;
+          return true;
+        }
+      }
+      break;
+    }
+    case CONST_INT:
+    {
+      info->regA = gen_rtx_raw_REG (mode, 0);
+      info->type = ADDRESS_CONST_INT;
+      info->offset = x;
+      return true;
+    }    
+    case CONST:
+    case LABEL_REF:
+    case SYMBOL_REF:
+    {
+      info->type = ADDRESS_SYMBOLIC;
+      info->symbol_type = SYMBOL_TYPE_GENERAL;
+      info->symbol = x;
+      info->regA =  gen_rtx_raw_REG (mode, get_base_reg (x));
+      if (HALF_PIC_P () || HALF_PIC_ADDRESS_P (x))
+        return false;
+            
+      if (GET_CODE (x) == CONST) {
+        return !(flag_pic && pic_address_needs_scratch (x));
+      }
+
+      return true;           
+    }
+    default:
+      return false;
+  }
+    
+  return false;
+}
+
+/* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It
+   returns a nonzero value if X is a legitimate address for a memory
+   operand of the indicated MODE.  STRICT is nonzero if this function
+   is called during reload.  */
+
+bool
+microblaze_legitimate_address_p (enum machine_mode mode, rtx x, int strict)
+{
+  struct microblaze_address_info addr;
+
+  return microblaze_classify_address (&addr, x, mode, strict);
+}
+
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This is used from only one place: `memory_address' in explow.c.
+
+   OLDX is the address as it was before break_out_memory_refs was
+   called.  In some cases it is useful to look at this to decide what
+   needs to be done.
+
+   MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.
+
+   It is always safe for this function to do nothing.  It exists to
+   recognize opportunities to optimize the output.
+
+   For the MICROBLAZE, transform:
+
+   memory(X + <large int>)
+
+   into:
+
+   Y = <large int> & ~0x7fff;
+   Z = X + Y
+   memory (Z + (<large int> & 0x7fff));
+
+   This is for CSE to find several similar references, and only use one Z.
+
+   When PIC, convert addresses of the form memory (symbol+large int) to
+   memory (reg+large int).  */
+rtx
+microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
+                               enum machine_mode mode ATTRIBUTE_UNUSED)
+{									
+  register rtx xinsn = x, result;						
+									
+  if (TARGET_DEBUG_B_MODE)						
+  {									
+    GO_PRINTF ("\n========== LEGITIMIZE_ADDRESS\n");			
+    GO_DEBUG_RTX (xinsn);						
+  }									
+									
+  if (GET_CODE (xinsn) == CONST						
+      && flag_pic && pic_address_needs_scratch (xinsn))		        
+  {									
+    rtx ptr_reg = gen_reg_rtx (Pmode);				
+    rtx constant = XEXP (XEXP (xinsn, 0), 1);				
+									
+    emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));		
+									
+    result = gen_rtx_PLUS (Pmode, ptr_reg, constant);			
+    if (SMALL_INT (constant))						
+      return result;							
+    /* Otherwise we fall through so the code below will fix the	
+       constant.  */							
+    xinsn = result;							
+  }									
+									
+  if (GET_CODE (xinsn) == PLUS)						
+  {									
+    register rtx xplus0 = XEXP (xinsn, 0);				
+    register rtx xplus1 = XEXP (xinsn, 1);				
+    register enum rtx_code code0 = GET_CODE (xplus0);			
+    register enum rtx_code code1 = GET_CODE (xplus1);			
+									
+    if (code0 != REG && code1 == REG)					
+    {								
+      xplus0 = XEXP (xinsn, 1);					
+      xplus1 = XEXP (xinsn, 0);					
+      code0 = GET_CODE (xplus0);					
+      code1 = GET_CODE (xplus1);					
+    }								
+									
+    if (code0 == REG && REG_OK_FOR_BASE_P (xplus0)		        
+        && code1 == CONST_INT && !SMALL_INT (xplus1))			
+    {								
+      rtx int_reg = gen_reg_rtx (Pmode);				
+      rtx ptr_reg = gen_reg_rtx (Pmode);				
+									
+      emit_move_insn (int_reg,					
+                      GEN_INT (INTVAL (xplus1) & ~ 0x7fff));	
+									
+      emit_insn (gen_rtx_SET (VOIDmode,				
+                          ptr_reg,					
+                          gen_rtx_PLUS (Pmode, xplus0, int_reg)));	
+									
+      result = gen_rtx_PLUS (Pmode, ptr_reg,				
+                        GEN_INT (INTVAL (xplus1) & 0x7fff));		
+      return result;							
+    }								
+  }									
+									
+  if (TARGET_DEBUG_B_MODE)						
+    GO_PRINTF ("LEGITIMIZE_ADDRESS could not fix.\n");			
+
+  return NULL_RTX;
+}
+
+
+/* Returns an operand string for the given instruction's delay slot,
+   after updating filled delay slot statistics.
+
+   We assume that operands[0] is the target register that is set.
+
+   In order to check the next insn, most of this functionality is moved
+   to FINAL_PRESCAN_INSN, and we just set the global variables that
+   it needs.  */
+
+/* ??? This function no longer does anything useful, because final_prescan_insn
+   now will never emit a nop.  */
+
+char *
+microblaze_fill_delay_slot (
+  char *ret,			/* normal string to return */
+  enum delay_type type,		/* type of delay */
+  rtx operands[],		/* operands to use */
+  rtx cur_insn)			/* current insn */
+{
+  register rtx set_reg;
+  register enum machine_mode mode;
+  register rtx next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL_RTX;
+  register int num_nops;
+
+  if (type == DELAY_LOAD || type == DELAY_FCMP)
+    num_nops = 1;
+
+  else if (type == DELAY_HILO)
+    num_nops = 2;
+
+  else
+    num_nops = 0;
+
+  /* Make sure that we don't put nop's after labels.  */
+  next_insn = NEXT_INSN (cur_insn);
+  while (next_insn != 0 && GET_CODE (next_insn) == NOTE)
+    next_insn = NEXT_INSN (next_insn);
+
+  dslots_load_total += num_nops;
+  if (TARGET_DEBUG_F_MODE
+      || !optimize
+      || type == DELAY_NONE
+      || operands == 0
+      || cur_insn == 0
+      || next_insn == 0
+      || GET_CODE (next_insn) == CODE_LABEL
+      || (set_reg = operands[0]) == 0)
+  {
+    dslots_number_nops = 0;
+    microblaze_load_reg  = 0;
+    microblaze_load_reg2 = 0;
+    microblaze_load_reg3 = 0;
+    microblaze_load_reg4 = 0;
+    return ret;
+  }
+
+  set_reg = operands[0];
+  if (set_reg == 0)
+    return ret;
+
+  while (GET_CODE (set_reg) == SUBREG)
+    set_reg = SUBREG_REG (set_reg);
+
+  mode = GET_MODE (set_reg);
+  dslots_number_nops = num_nops;
+  microblaze_load_reg = set_reg;
+  if (GET_MODE_SIZE (mode)
+      > (FP_REG_P (REGNO (set_reg)) ? UNITS_PER_FPREG : UNITS_PER_WORD))
+    microblaze_load_reg2 = gen_rtx_REG (SImode, REGNO (set_reg) + 1);
+  else
+    microblaze_load_reg2 = 0;
+
+  if (type == DELAY_HILO)
+  {
+    microblaze_load_reg3 = gen_rtx_REG (SImode, MD_REG_FIRST);
+    microblaze_load_reg4 = gen_rtx_REG (SImode, MD_REG_FIRST+1);
+  }
+  else
+  {
+    microblaze_load_reg3 = 0;
+    microblaze_load_reg4 = 0;
+  }
+
+  return ret;
+}
+
+
+/* Determine whether a memory reference takes one (based off of the GP
+   pointer), two (normal), or three (label + reg) instructions, and bump the
+   appropriate counter for -mstats.  */
+
+void
+microblaze_count_memory_refs (rtx op, int num)
+{
+  int additional = 0;
+  int n_words = 0;
+  rtx addr, plus0, plus1;
+  enum rtx_code code0, code1;
+  int looping;
+
+  if (TARGET_DEBUG_B_MODE)
+  {
+    fprintf (stderr, "\n========== microblaze_count_memory_refs:\n");
+    debug_rtx (op);
+  }
+
+  /* Skip MEM if passed, otherwise handle movsi of address.  */
+  addr = (GET_CODE (op) != MEM) ? op : XEXP (op, 0);
+
+  /* Loop, going through the address RTL.  */
+  do
+  {
+    looping = FALSE;
+    switch (GET_CODE (addr))
+    {
+      case REG:
+      case CONST_INT:
+        break;
+
+      case PLUS:
+        plus0 = XEXP (addr, 0);
+        plus1 = XEXP (addr, 1);
+        code0 = GET_CODE (plus0);
+        code1 = GET_CODE (plus1);
+
+        if (code0 == REG)
+        {
+          additional++;
+          addr = plus1;
+          looping = 1;
+          continue;
+        }
+
+        if (code0 == CONST_INT)
+        {
+          addr = plus1;
+          looping = 1;
+          continue;
+        }
+
+        if (code1 == REG)
+        {
+          additional++;
+          addr = plus0;
+          looping = 1;
+          continue;
+        }
+
+        if (code1 == CONST_INT)
+        {
+          addr = plus0;
+          looping = 1;
+          continue;
+        }
+
+        if (code0 == SYMBOL_REF || code0 == LABEL_REF || code0 == CONST)
+        {
+          addr = plus0;
+          looping = 1;
+          continue;
+        }
+
+        if (code1 == SYMBOL_REF || code1 == LABEL_REF || code1 == CONST)
+        {
+          addr = plus1;
+          looping = 1;
+          continue;
+        }
+
+        break;
+
+      case LABEL_REF:
+        n_words = 2;		/* always 2 words */
+        break;
+
+      case CONST:
+        addr = XEXP (addr, 0);
+        looping = 1;
+        continue;
+
+      case SYMBOL_REF:
+        n_words = SYMBOL_REF_FLAG (addr) ? 1 : 2;
+        break;
+
+      default:
+        break;
+    }
+  }
+  while (looping);
+
+  if (n_words == 0)
+    return;
+
+  n_words += additional;
+  if (n_words > 3)
+    n_words = 3;
+
+  num_refs[n_words-1] += num;
+}
+
+
+rtx
+embedded_pic_fnaddr_reg (void)
+{
+#if 0
+  if (cfun->machine->embedded_pic_fnaddr_rtx == NULL)
+  {
+    rtx seq;
+
+    cfun->machine->embedded_pic_fnaddr_rtx = gen_reg_rtx (Pmode);
+
+    /* Output code at function start to initialize the pseudo-reg.  */
+    /* ??? We used to do this in FINALIZE_PIC, but that does not work for
+       inline functions, because it is called after RTL for the function
+       has been copied.  The pseudo-reg in embedded_pic_fnaddr_rtx however
+       does not get copied, and ends up not matching the rest of the RTL.
+       This solution works, but means that we get unnecessary code to
+       initialize this value every time a function is inlined into another
+       function.  */
+    start_sequence ();
+    emit_insn (gen_get_fnaddr (cfun->machine->embedded_pic_fnaddr_rtx,
+                               XEXP (DECL_RTL (current_function_decl), 0)));
+    seq = get_insns ();
+    end_sequence ();
+    push_topmost_sequence ();
+    emit_insn_after (seq, get_insns ());
+    pop_topmost_sequence ();
+  }
+
+  return cfun->machine->embedded_pic_fnaddr_rtx;
+#endif
+  /* Returning NULL Pointer. Not a safe way to do this */
+  return NULL;
+}
+
+/* Return RTL for the offset from the current function to the argument.
+   X is the symbol whose offset from the current function we want.  */
+
+/* Looks like this is not called anywhere */
+rtx
+embedded_pic_offset (rtx x)
+{
+  /* Make sure it is emitted.  */
+  embedded_pic_fnaddr_reg ();
+
+  return
+    gen_rtx_CONST (Pmode,
+                   gen_rtx_MINUS (Pmode, x,
+                                  XEXP (DECL_RTL (current_function_decl), 0)));
+}
+
+
+static const char* 
+microblaze_mode_to_mem_modifier (int load, enum machine_mode mode)
+{
+  switch (mode) {
+
+    case QImode:
+      if (load)
+        return "bu";
+      else
+        return "b";
+    case HImode:
+      if (load)
+        return "hu";
+      else
+        return "h";
+    default:
+      return "w";
+  }
+}
+
+/* Return the appropriate instructions to move one operand to another.  */
+
+const char *
+microblaze_move_1word (
+  rtx operands[],
+  rtx insn,
+  int unsignedp ATTRIBUTE_UNUSED)
+{
+  char *ret=0; 
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  enum rtx_code code0 = GET_CODE (op0);
+  enum rtx_code code1 = GET_CODE (op1);
+  enum machine_mode mode0 = GET_MODE (op0);
+#if 0
+  enum machine_mode mode1 = GET_MODE (op1);
+#endif
+  int subreg_word0 = 0;
+  int subreg_word1 = 0;
+  enum delay_type delay = DELAY_NONE;
+  int i;
+  int empty_ret = 0;
+
+  ret = (char*)xmalloc(100);                                                          /* Allocate 50 bytes for the assembly instruction */
+   
+  for(i = 0 ; i < 100; i++) ret[i]='\0';
+
+  while (code0 == SUBREG)
+  {
+    subreg_word0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),
+                                         GET_MODE (SUBREG_REG (op0)),
+                                         SUBREG_BYTE (op0),
+                                         GET_MODE (op0));
+    op0 = SUBREG_REG (op0);
+    code0 = GET_CODE (op0);
+  }
+
+  while (code1 == SUBREG)
+  {
+    subreg_word1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),
+                                         GET_MODE (SUBREG_REG (op1)),
+                                         SUBREG_BYTE (op1),
+                                         GET_MODE (op1));
+    op1 = SUBREG_REG (op1);
+    code1 = GET_CODE (op1);
+  }
+
+  /* For our purposes, a condition code mode is the same as SImode.  */
+  if (mode0 == CCmode)
+    mode0 = SImode;
+
+  if (code0 == REG) {
+    int regno0 = REGNO (op0) + subreg_word0;
+
+    if (code1 == REG) {
+      int regno1 = REGNO (op1) + subreg_word1;
+
+      /* Just in case, don't do anything for assigning a register
+         to itself, unless we are filling a delay slot.  */
+      if (regno0 == regno1 && set_nomacro == 0){
+        empty_ret = 1;
+	ret[0] = '\0';
+      }
+	  
+      else if (GP_REG_P (regno0) && GP_REG_P (regno1) )
+        strcpy(ret, "addk\t%0,%1,r0");
+      else if (GP_REG_P (regno0) && ST_REG_P (regno1))
+        strcpy(ret, "mfs\t%0,%1");
+      else if (ST_REG_P (regno0) && GP_REG_P (regno1))
+        strcpy(ret, "mts\t%0,%1");
+    } else if (code1 == MEM) {
+      rtx offset = const0_rtx;
+      op1 = eliminate_constant_term (XEXP (op1, 0), &offset);
+          
+      delay = DELAY_NONE;
+
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (op1, 1);
+
+      if (GP_REG_P (regno0))
+      {
+        struct microblaze_address_info info;
+        if (!microblaze_classify_address (&info, XEXP (operands[1], 0), GET_MODE (operands[1]), 1)) 
+          fatal_insn ("insn contains an invalid address !", insn);
+
+        switch (info.type) {
+          case ADDRESS_REG:
+            if ((GET_CODE (info.offset) == CONST_INT)) 
+              sprintf (ret, "l%si\t%%0,%%1", microblaze_mode_to_mem_modifier (1, GET_MODE (operands[1])));
+            break;
+          case ADDRESS_REG_INDEX:
+            sprintf (ret, "l%s\t%%0,%%1", microblaze_mode_to_mem_modifier (1, GET_MODE (operands[1])));
+            break;
+          case ADDRESS_CONST_INT:
+          case ADDRESS_SYMBOLIC:
+            sprintf (ret, "l%si\t%%0,%%1", microblaze_mode_to_mem_modifier (1, GET_MODE (operands[1])));
+            break;
+	  case ADDRESS_INVALID:
+	    fatal_insn("Invalid address", operands[1]);
+	    break;
+        }
+        return ret;
+      }
+    } else if ((code1 == CONST_INT) || 
+               (code1 == CONST_DOUBLE && GET_MODE (op1) == VOIDmode)) {
+      if (code1 == CONST_DOUBLE) {
+        /* This can happen when storing constants into long long
+           bitfields.  Just store the least significant word of
+           the value.  */
+        operands[1] = op1 = GEN_INT (CONST_DOUBLE_LOW (op1));
+      }
+
+      if (INTVAL (op1) == 0 )
+      {
+        if (GP_REG_P (regno0))
+          strcpy(ret, "addk\t%0,r0,%z1");
+      } else if (GP_REG_P (regno0))
+      {
+        strcpy(ret, "addik\t%0,r0,%1\t# %X1");
+      }
+    }
+    /* Sid [07/16/01] Need to get DOUBLE and FLOATS out . Instead have either normal moves or function calls */
+    else if (code1 == CONST_DOUBLE && mode0 == SFmode)
+    {
+      if (op1 == CONST0_RTX (SFmode))
+      {
+        if (GP_REG_P (regno0))
+          strcpy(ret, "addk\t%0,r0,%.");
+      }
+
+      else
+      {
+        delay = DELAY_NONE;
+        {
+          unsigned int value_long;
+          int i;
+          REAL_VALUE_TYPE value;
+
+          REAL_VALUE_FROM_CONST_DOUBLE(value,operands[1]);
+          REAL_VALUE_TO_TARGET_SINGLE (value, value_long);
+		
+          ret = (char*)xmalloc(30); 
+                    
+          for(i = 0; i < 30; i++) 
+            ret[i] = 0;
+
+          sprintf (ret, "addik\t%%0,r0,0x%x", value_long);
+        }
+	      
+      }
+    }
+
+    else if (code1 == LABEL_REF)
+    {
+
+#if 0
+      int base_reg = get_base_reg (XEXP (operands[1], 0));
+#endif
+      
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (op1, 1);
+      
+      ret = (char*)xmalloc (strlen ("addik\t%%0,r13,%%a1")); /* need r2 as the reg, but use r13 to get more space */
+      sprintf (ret, "addik\t%%0,%%a1");
+    }
+
+    else if (code1 == SYMBOL_REF || code1 == CONST)
+    {
+      if (HALF_PIC_P () && CONSTANT_P (op1) && HALF_PIC_ADDRESS_P (op1))
+      {
+        rtx offset = const0_rtx;
+
+        if (GET_CODE (op1) == CONST)
+          op1 = eliminate_constant_term (XEXP (op1, 0), &offset);
+
+        if (GET_CODE (op1) == SYMBOL_REF)
+        {
+          operands[2] = HALF_PIC_PTR (op1);
+
+          if (TARGET_STATS)
+            microblaze_count_memory_refs (operands[2], 1);
+
+          if (INTVAL (offset) == 0)
+          {
+            /*		      delay = DELAY_LOAD;*/
+            delay = DELAY_NONE;
+            strcpy (ret, "lw\t%0,%2");
+          }
+          else
+          {
+            /* XLNX [Check out]*/
+            dslots_load_total++;
+            operands[3] = offset;
+            strcpy (ret, "lwi\t%0,%2,0\n\tadd\t%0,%0,%3");
+          }
+        }
+      }
+      else
+      {
+#if 0
+        int base_reg = get_base_reg (operands[1]);
+#endif
+        sprintf (ret,"addik\t%%0,%%a1");
+        
+        if (TARGET_STATS)
+          microblaze_count_memory_refs (op1, 1);
+      }
+    }
+
+    else if (code1 == PLUS)
+    {
+      rtx add_op0 = XEXP (op1, 0);
+      rtx add_op1 = XEXP (op1, 1);
+
+      if (GET_CODE (XEXP (op1, 1)) == REG
+          && GET_CODE (XEXP (op1, 0)) == CONST_INT)
+        add_op0 = XEXP (op1, 1), add_op1 = XEXP (op1, 0);
+
+      operands[2] = add_op0;
+      operands[3] = add_op1;
+      strcpy (ret, "addk%:\t%0,%2,%3");
+    }
+
+    else if (code1 == HIGH)
+    {
+      operands[1] = XEXP (op1, 0);
+      strcpy (ret, "lui\t%0,%%hi(%1)");
+    }
+  }
+
+  else if (code0 == MEM)
+  {
+        
+    struct microblaze_address_info info;
+    if (!microblaze_classify_address (&info, XEXP (operands[0], 0), GET_MODE (operands[0]), 1)) 
+      fatal_insn ("insn contains an invalid addresss !", insn);
+        
+    switch (info.type) {
+      case ADDRESS_REG:
+          sprintf (ret, "s%si\t%%z1,%%0", microblaze_mode_to_mem_modifier (0, GET_MODE (operands[0])));
+        break;
+      case ADDRESS_REG_INDEX:
+        sprintf (ret, "s%s\t%%z1,%%0", microblaze_mode_to_mem_modifier (0, GET_MODE (operands[0])));
+        break;
+      case ADDRESS_CONST_INT:
+      case ADDRESS_SYMBOLIC:
+        sprintf (ret, "s%si\t%%z1,%%0", microblaze_mode_to_mem_modifier (0, GET_MODE (operands[0])));
+        break;
+      case ADDRESS_INVALID:
+	fatal_insn ("invalid address", insn);
+	break;
+    }
+    return ret;
+  }
+
+  if (ret == 0)
+  {
+    fatal_insn ("Bad move", insn);
+    return 0;
+  }
+  else
+    if (!empty_ret && strlen(ret) == 0){
+      fatal_insn ("Bad move", insn);
+      return 0;
+    }
+
+  if (delay != DELAY_NONE)
+    return microblaze_fill_delay_slot (ret, delay, operands, insn);
+
+  return ret;
+}
+
+
+/* Return the appropriate instructions to move 2 words */
+
+const char*
+microblaze_move_2words (
+  rtx operands[],
+  rtx insn)
+{
+  static char ret[100];
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  enum rtx_code code0 = GET_CODE (operands[0]);
+  enum rtx_code code1 = GET_CODE (operands[1]);
+  int subreg_word0 = 0;
+  int subreg_word1 = 0;
+  enum delay_type delay = DELAY_NONE;
+
+  ret[0] = 0;
+
+  while (code0 == SUBREG)
+  {
+    subreg_word0 += /* SUBREG_REG (op0) MJE */ 1;
+    op0 = SUBREG_REG (op0);
+    code0 = GET_CODE (op0);
+  }
+
+  if (code1 == SIGN_EXTEND)
+  {
+    op1 = XEXP (op1, 0);
+    code1 = GET_CODE (op1);
+  }
+
+  while (code1 == SUBREG)
+  {
+    subreg_word1 += /* SUBREG_REG (op1) MJE */ 1;
+    op1 = SUBREG_REG (op1);
+    code1 = GET_CODE (op1);
+  }
+      
+  /* Sanity check.  */
+  if (GET_CODE (operands[1]) == SIGN_EXTEND
+      && code1 != REG
+      && code1 != CONST_INT
+      /* The following three can happen as the result of a questionable
+         cast.  */
+      && code1 != LABEL_REF
+      && code1 != SYMBOL_REF
+      && code1 != CONST)
+    abort ();
+
+  if (code0 == REG)
+  {
+    int regno0 = REGNO (op0) + subreg_word0;
+
+    if (code1 == REG)
+    {
+      int regno1 = REGNO (op1) + subreg_word1;
+
+      /* Just in case, don't do anything for assigning a register
+         to itself, unless we are filling a delay slot.  */
+      if (regno0 == regno1 && set_nomacro == 0)
+        strcpy (ret, "");
+      else if (regno0 != (regno1+1))
+        strcpy (ret, "addk\t%0,r0,%1\n\taddk\t%D0,r0,%D1");
+
+      else
+        strcpy (ret, "addk\t%D0,r0,%D1\n\taddk\t%0,r0,%1");
+    }
+
+    else if (code1 == CONST_DOUBLE)
+    {
+      /* Move zero from $0 unless recipient
+         is 64-bit fp reg, in which case generate a constant.  */
+      if (op1 != CONST0_RTX (GET_MODE (op1)))
+      {
+        if (GET_MODE (op1) == DFmode)
+        {
+          /*		  delay = DELAY_LOAD;*/
+          delay = DELAY_NONE;
+
+#ifdef TARGET_FP_CALL_32
+          if (FP_CALL_GP_REG_P (regno0))
+          {
+            strcpy (ret, "li.d\t%0,%1\n\tdsll\t%D0,%0,32\n\tdsrl\t%D0,32\n\tdsrl\t%0,32");
+          }
+          else
+#endif
+          {
+            union { long value_long; unsigned int value_int[2]; } val;
+            REAL_VALUE_TYPE value;
+            REAL_VALUE_FROM_CONST_DOUBLE(value,operands[1]);
+            REAL_VALUE_TO_TARGET_DOUBLE (value, &(val.value_long));
+
+            sprintf (ret, "addik\t%%0,r0,0x%x \n\taddik\t%%D0,r0,0x%x #Xfer Lo", 
+		     val.value_int[0], val.value_int[1]);
+            printed = 1;
+          }
+        }
+
+        else
+        {
+          split_double (op1, operands + 2, operands + 3);
+          /*		  strcpy (ret, "MICROBLAZEli\t%0,%2\n\tMICROBLAZEli\t%D0,%3 #li1");*/
+          /*   	          fprintf(stderr,"li ==> la\n");*/
+          strcpy (ret, "addik\t%0,r0,%2\n\taddik\t%D0,r0,%3 #li => la");
+        }
+      }
+
+      else
+      {
+        if (GP_REG_P (regno0))
+          strcpy (ret, "addk\t%0,r0,%.\n\taddk\t%D0,r0,%.");
+      }
+    }
+
+    else if (code1 == CONST_INT && INTVAL (op1) == 0 )
+    {
+      if (GP_REG_P (regno0))
+        strcpy (ret, "addk\t%0,r0,%.\n\taddk\t%D0,r0,%.");
+    }
+	
+    else if (code1 == CONST_INT && GET_MODE (op0) == DImode
+             && GP_REG_P (regno0)){
+      if (HOST_BITS_PER_WIDE_INT < 64) {
+        operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);
+        /*	      strcpy (ret, "MICROBLAZEli\t%M0,%2\n\tMICROBLAZEli\t%L0,%1 #li7");*/
+        strcpy (ret, "addik\t%M0,r0,%2\n\taddik\t%L0,r0,%1");
+      }
+      else {
+        /* We use multiple shifts here, to avoid warnings about out
+           of range shifts on 32 bit hosts.  */
+        operands[2] = GEN_INT (INTVAL (operands[1]) >> 16 >> 16);
+        operands[1]
+          = GEN_INT (INTVAL (operands[1]) << 16 << 16 >> 16 >> 16);
+        /*strcpy (ret, "MICROBLAZEli\t%M0,%2\n\tMICROBLAZEli\t%L0,%1 #li8");*/
+        strcpy (ret, "addik\t%M0,r0,%2\n\taddik\t%L0,r0,%1");
+      }
+    }
+
+    else if (code1 == MEM){
+      /*	  delay = DELAY_LOAD;*/
+      delay = DELAY_NONE;
+
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (op1, 2);
+
+      if (double_memory_operand (op1, GET_MODE (op1))) {
+        operands[2] = adjust_address (op1, GET_MODE(op1),4);
+            
+        /* if operands[1] is REG or op1 = MEM, which points to REG */
+        if (GET_CODE(op1) == REG || GET_CODE (XEXP (op1,0)) == REG)
+          strcpy (ret, (reg_mentioned_p (op0, op1)
+                 ? "lwi\t%D0,%2\n\tlwi\t%0,%1"
+                 : "lwi\t%0,%1\n\tlwi\t%D0,%2"));
+        else
+          if (GET_CODE(op1) == SYMBOL_REF || GET_CODE (XEXP (op1, 0)) == SYMBOL_REF) {
+            int ret_reg;
+            if (GET_CODE(op1) == SYMBOL_REF)
+              ret_reg = get_base_reg(op1);
+            else
+              ret_reg = get_base_reg (XEXP (op1,0));
+            
+            if (reg_mentioned_p (op0, op1)){
+              sprintf (ret,"lwi\t%%D0,%%2\n\tlwi\t%%0,%%1");
+            }
+            else
+              sprintf (ret,"lwi\t%%0,%%1\n\tlwi\t%%D0,%%2 #MICROBLAZE-CHECK");
+          }
+          else if (GET_CODE(op1) == CONST || GET_CODE (XEXP (op1,0)) == CONST || GET_CODE (XEXP (op1, 0)) == CONST_INT) {
+            strcpy (ret, (reg_mentioned_p (op0, op1)
+                   ? "lwi\t%D0,%2\n\tlwi\t%0,%1"
+                   : "lwi\t%0,%1\n\tlwi\t%D0,%2"));
+          }
+          else {
+            strcpy (ret, (reg_mentioned_p (op0, op1)
+                   ? "lwi\t%D0,%2\n\tlwi\t%0,%1"
+                   : "lwi\t%0,%1\n\tlwi\t%D0,%2"));
+          }
+      }
+    }
+      
+    else if (code1 == LABEL_REF)
+    {
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (op1, 2);
+    }
+    else if (code1 == SYMBOL_REF || code1 == CONST)
+    {
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (op1, 2);
+    }
+  }
+
+  else if (code0 == MEM)
+  {
+    if (code1 == REG)
+    {
+      int regno1 = REGNO (op1) + subreg_word1;
+
+      if (FP_REG_P (regno1))
+        strcpy (ret, "s.d\t%1,%0");
+
+      else if (double_memory_operand (op0, GET_MODE (op0)))
+      {
+#if 0
+        int op0_base_reg = get_base_reg(op0);
+#endif
+        operands[2] = adjust_address(op0,GET_MODE (op0), 4);
+	      
+        /* if operands[0] happens to be plus, we shdn't add r0 to the resulting output */
+        /* Check this code properly..Seems to be complicated */
+        if (GET_CODE (XEXP (operands[0], 0)) == PLUS) 
+          if (GET_CODE (XEXP (operands[2], 0)) == PLUS)
+            strcpy (ret, "swi\t%1,%0\n\tswi\t%D1,%2");
+          else
+            strcpy (ret, "swi\t%1,%0\n\tswi\t%D1,%2");
+        else
+          if ((GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF) ||
+              (GET_CODE (XEXP (operands[0], 0)) == CONST)) {
+            sprintf (ret, "swi\t%%1,%%0\n\tswi\t%%D1,%%2");
+          }
+          else
+            if (GET_CODE (XEXP (operands[2], 0)) == PLUS)
+              strcpy (ret, "swi\t%1,%0\n\tswi\t%D1,%2");
+            else
+              strcpy (ret, "swi\t%1,%0\n\tswi\t%D1,%2");
+
+      }
+    }
+
+    else if (((code1 == CONST_INT && INTVAL (op1) == 0)
+              || (code1 == CONST_DOUBLE
+                  && op1 == CONST0_RTX (GET_MODE (op1))))
+             && (double_memory_operand (op0, GET_MODE (op0))))
+    {
+      operands[2] = adjust_address(op0, GET_MODE(op0),4);
+      /*         operands[2] = adj_offsettable_operand (op0, 4);*/
+      strcpy (ret, "swi\t%.,%0\n\tswi\t%.,%2");
+    }
+
+    if (TARGET_STATS)
+      microblaze_count_memory_refs (op0, 2);
+  }
+
+  if (ret[0] == 0)
+  {
+    fatal_insn ("Bad move", insn);
+    return 0;
+  }
+
+  if (delay != DELAY_NONE)
+    return microblaze_fill_delay_slot (ret, delay, operands, insn);
+
+  return ret;
+}
+
+
+bool 
+microblaze_rtx_costs (
+  rtx x,
+  int code,
+  int outer_code ATTRIBUTE_UNUSED,
+  int *total)
+{
+  enum machine_mode mode = GET_MODE (x);
+
+  switch (code) {
+    case MEM:							
+    {									
+      int num_words = (GET_MODE_SIZE (mode) > UNITS_PER_WORD) ? 2 : 1; 
+      if (simple_memory_operand (x, mode)) 
+        *total = COSTS_N_INSNS (2 * num_words);			
+      else
+        *total = COSTS_N_INSNS (2 * (2 * num_words));				
+        
+      return true;
+    }									       
+    case NOT: 
+    {
+      if (mode == DImode) {
+        *total = COSTS_N_INSNS (2);
+      } else 
+        *total = COSTS_N_INSNS (1);
+      return false;
+    }   
+    case AND:								
+    case IOR:								
+    case XOR:								
+    {
+      if (mode == DImode) {
+        *total = COSTS_N_INSNS (2);						
+      } else 
+        *total = COSTS_N_INSNS (1);
+
+      return false;
+    }
+    case ASHIFT:								
+    case ASHIFTRT:							
+    case LSHIFTRT:	
+    {
+      if (TARGET_BARREL_SHIFT) {
+        if (microblaze_version_compare (microblaze_select.cpu, "v5.00.a") >= 0)
+          *total = COSTS_N_INSNS (1);                                         
+        else
+          *total = COSTS_N_INSNS (2);
+      }
+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT) 
+        *total = COSTS_N_INSNS (INTVAL (XEXP (x, 1)));
+      else 
+        *total = COSTS_N_INSNS (32 * 4);                /* Double the worst cost of shifts when there is no barrel shifter and the shift amount is in a reg */
+      return true;
+    }
+    case PLUS:								
+    case MINUS:								
+    {									
+      if (mode == SFmode || mode == DFmode)				
+      {						
+        if (TARGET_HARD_FLOAT)
+          *total = COSTS_N_INSNS (6);					
+	return true;
+      } 
+      else if (mode == DImode)
+      {
+        *total = COSTS_N_INSNS (4);					
+	return true;
+      } 
+      else
+      {
+        *total = COSTS_N_INSNS (1);
+	return true;
+      }
+
+      return false;
+    }									
+    case NEG:								
+    {
+      if (mode == DImode) 
+        *total = COSTS_N_INSNS (4);
+
+      return false;
+    }
+    case MULT:								
+    {									
+      if (mode == SFmode) {
+        if (TARGET_HARD_FLOAT)
+          *total = COSTS_N_INSNS (6);					
+      }
+      else if (!TARGET_SOFT_MUL) {                                                       if (microblaze_version_compare (microblaze_select.cpu, "v5.00.a") >= 0)
+         *total = COSTS_N_INSNS (1);
+      else
+          *total = COSTS_N_INSNS (3);
+      }
+      else *total =  COSTS_N_INSNS (10);
+      return true;
+    }									
+    case DIV:								
+    case UDIV:								
+    {									
+      if (mode == SFmode)						
+      {			
+        if (TARGET_HARD_FLOAT)
+          *total = COSTS_N_INSNS (23);					
+      }								
+      return false;
+    }									
+    case SIGN_EXTEND:							
+    {
+      *total = COSTS_N_INSNS (1);						
+      return false;
+    }
+    case ZERO_EXTEND:							
+    {
+      *total = COSTS_N_INSNS (1);
+      return false;
+    }
+  }
+    
+  return false;
+}
+
+
+
+/* Return the number of instructions needed to load or store a value
+   of mode MODE at X.  Return 0 if X isn't valid for MODE.
+
+*/
+
+int
+microblaze_address_insns (rtx x, enum machine_mode mode)
+{
+  struct microblaze_address_info addr;
+
+  if (microblaze_classify_address (&addr, x, mode, false)) {
+    switch (addr.type)
+    {
+      case ADDRESS_REG:
+        if (SMALL_INT (addr.offset)) 
+          return 1;
+        else
+          return 2;
+      case ADDRESS_CONST_INT:
+        if (SMALL_INT (x))
+          return 1;
+        else
+          return 2;
+      case ADDRESS_REG_INDEX:
+      case ADDRESS_SYMBOLIC:
+        return 1;
+      default:
+        break;
+    }
+  }
+  return 0;
+}
+
+/* Provide the costs of an addressing mode that contains ADDR.
+   If ADDR is not a valid address, its cost is irrelevant.  */
+int
+microblaze_address_cost (rtx addr)
+{
+  return COSTS_N_INSNS (microblaze_address_insns (addr, GET_MODE (addr)));
+}
+
+/* Return nonzero if X is an address which needs a temporary register when 
+   reloaded while generating PIC code.  */
+
+/* XLNX [08/16/01] Need to look into this*/
+int
+pic_address_needs_scratch (rtx x)
+{
+  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS
+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
+      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))
+    return 1;
+
+  return 0;
+}
+
+/* Make normal rtx_code into something we can index from an array */
+
+static enum internal_test
+map_test_to_internal_test (enum rtx_code test_code)
+{
+  enum internal_test test = ITEST_MAX;
+
+  switch (test_code)
+  {
+    case EQ:  test = ITEST_EQ;  break;
+    case NE:  test = ITEST_NE;  break;
+    case GT:  test = ITEST_GT;  break;
+    case GE:  test = ITEST_GE;  break;
+    case LT:  test = ITEST_LT;  break;
+    case LE:  test = ITEST_LE;  break;
+    case GTU: test = ITEST_GTU; break;
+    case GEU: test = ITEST_GEU; break;
+    case LTU: test = ITEST_LTU; break;
+    case LEU: test = ITEST_LEU; break;
+    default:			break;
+  }
+
+  return test;
+}
+
+/* Emit the common code for doing conditional branches.
+   operand[0] is the label to jump to.
+   The comparison operands are saved away by cmp{si,di,sf,df}.  */
+
+void
+gen_conditional_branch (rtx operands[], enum rtx_code test_code)
+{
+  enum cmp_type type = branch_type;
+  rtx cmp0 = branch_cmp[0];
+  rtx cmp1 = branch_cmp[1];
+  enum machine_mode mode;
+#if 0
+  rtx reg0, reg1;
+#endif
+  rtx reg0;
+  rtx label1, label2;
+
+  switch (type)
+  {
+    case CMP_SI:
+    case CMP_DI:
+      mode = type == CMP_SI ? SImode : DImode; 
+      break;
+   case CMP_SF:
+      if (TARGET_HARD_FLOAT) {
+        reg0 = gen_reg_rtx (SImode);
+        /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result == 0 in the following instruction. */
+        emit_insn (gen_rtx_SET (VOIDmode, reg0,
+                            gen_rtx_fmt_ee ((test_code == NE ? EQ : test_code), SImode, cmp0, cmp1)));
+
+        /* Setup test and branch for following instruction
+           Setup a test for zero as opposed to non-zero.
+           This is more optimally implemented. */
+        test_code = (test_code == NE) ? EQ : NE;
+        mode = SImode;
+        cmp0 = reg0;
+        cmp1 = const0_rtx;
+        break;
+      } else
+        fatal_insn ("gen_conditional_branch:", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));
+    default:
+      fatal_insn ("gen_conditional_branch:", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));
+  }
+
+  /* Generate the branch.  */
+
+  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);
+  label2 = pc_rtx;
+
+  if (!(GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)) {          /* Except for branch_zero */
+    emit_jump_insn (
+      gen_rtx_PARALLEL (VOIDmode, 
+	gen_rtvec (2,
+          gen_rtx_SET (VOIDmode, pc_rtx, 
+	    gen_rtx_IF_THEN_ELSE (VOIDmode, 
+	      gen_rtx_fmt_ee (test_code, mode, cmp0, cmp1),
+	      label1, label2)),
+          gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM)))));
+  } else 
+    emit_jump_insn (
+      gen_rtx_SET (VOIDmode, pc_rtx, 
+        gen_rtx_IF_THEN_ELSE (VOIDmode, 
+	  gen_rtx_fmt_ee (test_code, mode, cmp0, cmp1),
+	  label1, label2)));
+}
+
+/* Write a loop to move a constant number of bytes.
+   Generate load/stores as follows:
+
+   do {
+   temp1 = src[0];
+   temp2 = src[1];
+   ...
+   temp<last> = src[MAX_MOVE_REGS-1];
+   dest[0] = temp1;
+   dest[1] = temp2;
+   ...
+   dest[MAX_MOVE_REGS-1] = temp<last>;
+   src += MAX_MOVE_REGS;
+   dest += MAX_MOVE_REGS;
+   } while (src != final);
+
+   This way, no NOP's are needed, and only MAX_MOVE_REGS+3 temp
+   registers are needed.
+
+   Aligned moves move MAX_MOVE_REGS*4 bytes every (2*MAX_MOVE_REGS)+3
+   cycles, unaligned moves move MAX_MOVE_REGS*4 bytes every
+   (4*MAX_MOVE_REGS)+3 cycles, assuming no cache misses.  */
+/*#undef UNITS_PER_WORD
+  #define UNITS_PER_WORD 1
+*/
+#define MAX_MOVE_REGS 4
+#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)
+
+
+
+static void
+block_move_loop (
+  rtx dest_reg,		/* register holding destination address */
+  rtx src_reg,		/* register holding source address */
+  int bytes,		/* # bytes to move */
+  int align,		/* alignment */
+  rtx orig_dest,	/* original dest for change_address */
+  rtx orig_src)		/* original source for making a reg note */
+{
+  rtx dest_mem = change_address (orig_dest, BLKmode, dest_reg);
+  rtx src_mem = change_address (orig_src, BLKmode, src_reg);
+  rtx align_rtx = GEN_INT (align);
+  rtx label;
+  rtx final_src;
+  rtx bytes_rtx;
+  int leftover;
+
+  if (bytes < 2 * MAX_MOVE_BYTES)
+    abort ();
+
+  leftover = bytes % MAX_MOVE_BYTES;
+  bytes -= leftover;
+
+  label = gen_label_rtx ();
+  final_src = gen_reg_rtx (Pmode);
+  bytes_rtx = GEN_INT (bytes);
+
+  if (bytes > 0x7fff)
+  {
+    emit_insn (gen_movsi (final_src, bytes_rtx));
+    emit_insn (gen_addsi3 (final_src, final_src, src_reg));
+  }
+  else
+  {
+    emit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));
+  }
+
+  emit_label (label);
+
+  bytes_rtx = GEN_INT (MAX_MOVE_BYTES);
+
+  emit_insn (gen_movstrsi_internal (dest_mem, src_mem, bytes_rtx, align_rtx));
+
+  emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));
+  emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));
+  emit_insn (gen_cmpsi (src_reg, final_src));
+
+  emit_jump_insn (gen_bne (label));
+
+  if (leftover)
+    emit_insn (gen_movstrsi_internal (dest_mem, src_mem, GEN_INT (leftover),
+                                      align_rtx));
+}
+
+/* Use a library function to move some bytes.  */
+
+static void
+block_move_call (
+  rtx dest_reg,
+  rtx src_reg,
+  rtx bytes_rtx)
+{
+  /* We want to pass the size as Pmode, which will normally be SImode
+     but will be DImode if we are using 64 bit longs and pointers.  */
+  if (GET_MODE (bytes_rtx) != VOIDmode
+      && GET_MODE (bytes_rtx) != Pmode)
+    bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);
+
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "memcpy"), 0,
+                     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,
+                     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,
+                                      /* TREE_UNSIGNED (sizetype) */ 1),
+                     TYPE_MODE (sizetype));
+}
+
+/* Expand string/block move operations.
+
+operands[0] is the pointer to the destination.
+operands[1] is the pointer to the source.
+operands[2] is the number of bytes to move.
+operands[3] is the alignment.  */
+
+void
+expand_block_move (rtx operands[])
+{
+  rtx bytes_rtx	= operands[2];
+  rtx align_rtx = operands[3];
+  int constp = GET_CODE (bytes_rtx) == CONST_INT;
+  HOST_WIDE_INT bytes = constp ? INTVAL (bytes_rtx) : 0;
+  int align = INTVAL (align_rtx);
+  rtx orig_src	= operands[1];
+  rtx orig_dest	= operands[0];
+  rtx src_reg;
+  rtx dest_reg;
+
+  if (constp && bytes <= 0)
+    return;
+
+  if (align > UNITS_PER_WORD)
+    align = UNITS_PER_WORD;
+
+  /* Move the address into scratch registers.  */
+  dest_reg = copy_addr_to_reg (XEXP (orig_dest, 0));
+  src_reg  = copy_addr_to_reg (XEXP (orig_src, 0));
+
+  if (constp && bytes <= 2 * MAX_MOVE_BYTES
+           && align == UNITS_PER_WORD) {
+    move_by_pieces (orig_dest, orig_src, bytes, align, 0);                  
+  }	
+  else if (constp && bytes <= 2 * MAX_MOVE_BYTES) {
+    emit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,
+                                                      dest_reg),
+                                      change_address (orig_src, BLKmode,
+                                                      src_reg),
+                                      bytes_rtx, align_rtx));
+  }
+  else if (constp && align >= UNITS_PER_WORD && optimize) {
+    block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src);
+  }
+  else if (constp /* && optimize */)
+  {
+    /* If the alignment is not word aligned, generate a test at
+       runtime, to see whether things wound up aligned, and we
+       can use the faster lw/sw instead ulw/usw.  */
+
+    rtx temp = gen_reg_rtx (Pmode);
+    rtx aligned_label = gen_label_rtx ();
+    rtx join_label = gen_label_rtx ();
+    int leftover = bytes % MAX_MOVE_BYTES;
+
+    bytes -= leftover;
+    emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));
+    emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD - 1)));
+    emit_insn (gen_cmpsi (temp, const0_rtx));
+    emit_jump_insn (gen_beq (aligned_label));
+
+    /* Unaligned loop.  */
+    block_move_loop (dest_reg, src_reg, bytes, 1, orig_dest, orig_src);
+    emit_jump_insn (gen_jump (join_label));
+    emit_barrier ();
+
+    /* Aligned loop.  */
+    emit_label (aligned_label);
+    block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_dest,
+                     orig_src);
+    emit_label (join_label);
+
+    /* Bytes at the end of the loop.  */
+    if (leftover)
+      emit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,
+                                                        dest_reg),
+                                        change_address (orig_src, BLKmode,
+                                                        src_reg),
+                                        GEN_INT (leftover),
+                                        GEN_INT (align)));
+  }
+
+  else {
+    block_move_call (dest_reg, src_reg, bytes_rtx);
+  }
+}
+
+/* Emit load/stores for a small constant block_move. 
+
+operands[0] is the memory address of the destination.
+operands[1] is the memory address of the source.
+operands[2] is the number of bytes to move.
+operands[3] is the alignment.
+operands[4] is a temp register.
+operands[5] is a temp register.
+...
+operands[3+num_regs] is the last temp register.
+
+The block move type can be one of the following:
+BLOCK_MOVE_NORMAL	Do all of the block move.
+BLOCK_MOVE_NOT_LAST	Do all but the last store.
+BLOCK_MOVE_LAST		Do just the last store. */
+
+const char *
+output_block_move (
+  rtx insn,
+  rtx operands[],
+  int num_regs,
+  enum block_move_type move_type)
+{
+  rtx dest_reg = XEXP (operands[0], 0);
+  rtx src_reg = XEXP (operands[1], 0);
+  HOST_WIDE_INT bytes = INTVAL (operands[2]);
+  int align = INTVAL (operands[3]);
+  int num = 0;
+  int offset = 0;
+  int use_lwl_lwr = 0;
+  int last_operand = num_regs + 4;
+  int safe_regs = 4;
+  int i;
+  rtx xoperands[10];
+  int op0_base_reg=0;
+  int op1_base_reg=0;
+
+  struct {
+    char *load;		/* load insn without nop */
+    char *load_nop;	/* load insn with trailing nop */
+    char *store;		/* store insn */
+    char *final;		/* if last_store used: NULL or swr */
+    char *last_store;	/* last store instruction */
+    int offset;			/* current offset */
+    enum machine_mode mode;	/* mode to use on (MEM) */
+  } load_store[4];
+
+  /* ??? Detect a bug in GCC, where it can give us a register
+     the same as one of the addressing registers and reduce
+     the number of registers available.  */
+  for (i = 4;
+       i < last_operand
+         && safe_regs < (int)(sizeof(xoperands) / sizeof(xoperands[0]));
+       i++)
+    if (! reg_mentioned_p (operands[i], operands[0])
+        && ! reg_mentioned_p (operands[i], operands[1]))
+      xoperands[safe_regs++] = operands[i];
+
+  if (safe_regs < last_operand)
+  {
+    xoperands[0] = operands[0];
+    xoperands[1] = operands[1];
+    xoperands[2] = operands[2];
+    xoperands[3] = operands[3];
+    return output_block_move (insn, xoperands, safe_regs - 4, move_type);
+  }
+
+  /* If we are given global or static addresses, and we would be
+     emitting a few instructions, try to save time by using a
+     temporary register for the pointer.  */
+  if (num_regs > 2 && (bytes > 2 * align || move_type != BLOCK_MOVE_NORMAL))
+  {
+    if (CONSTANT_P (src_reg))
+    {
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (operands[1], 1);
+
+      src_reg = operands[3 + num_regs--];
+      if (move_type != BLOCK_MOVE_LAST)
+      {
+        xoperands[1] = operands[1];
+        xoperands[0] = src_reg;
+        if (GET_CODE(xoperands[1]) == MEM){
+          char *output_string = (char*)xmalloc(sizeof("addik\t%%0,r13,%%1"));		  
+          if ((GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF) ||
+              (GET_CODE (XEXP (xoperands[1], 0)) == CONST)){
+            sprintf (output_string, "addik\t%%0,%%1");
+            output_asm_insn (output_string, xoperands);
+            free (output_string);
+          }
+        }
+        else
+          fprintf(stderr,"Error!!Block move has operations other than MEM %d\n",GET_MODE(xoperands[1]));
+      }
+    }
+
+    if (CONSTANT_P (dest_reg))
+    {
+      if (TARGET_STATS)
+        microblaze_count_memory_refs (operands[0], 1);
+
+      dest_reg = operands[3 + num_regs--];
+      if (move_type != BLOCK_MOVE_LAST)
+      {
+        xoperands[1] = operands[0];
+        xoperands[0] = dest_reg;
+        if (GET_CODE(xoperands[1]) == MEM){
+          if ((GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF)||
+              (GET_CODE (XEXP (xoperands[1], 0)) == CONST)){
+            char *output_string = (char*)xmalloc(sizeof("addik\t%%0,r13,%%1"));
+            sprintf (output_string," addik\t%%0,%%1");
+            output_asm_insn (output_string, xoperands);
+            free (output_string);
+          }
+        }
+        else
+          fprintf(stderr,"Error!!Block move has operations other than MEM (2)\n");
+      }
+    }
+  }
+
+  if (num_regs > (int)(sizeof (load_store) / sizeof (load_store[0])))
+    num_regs = sizeof (load_store) / sizeof (load_store[0]);
+
+  else if (num_regs < 1)
+    fatal_insn ("Cannot do block move, not enough scratch registers", insn);
+
+  op0_base_reg = get_base_reg (XEXP (operands[0],0));
+  op1_base_reg = get_base_reg (XEXP (operands[1],0));
+
+  while (bytes > 0)
+  {
+    load_store[num].offset = offset;
+
+    if (bytes >= 4 && align >= 4)
+    {
+      /*if (offset == 0) {
+        load_store[num].load = "lw\t%0,r0,%1 # MICROBLAZElw78";
+        load_store[num].load_nop = "lw\t%0,r0,%1%# # MICROBLAZElw78";
+        load_store[num].store = "sw\t%0,r0,%1 # MICROBLAZEsw67";
+        load_store[num].last_store = "sw\t%0,r0,%1 # MICROBLAZEsw67";
+        }
+        else {
+        load_store[num].load = "lwi\t%0,%1 # MICROBLAZElwi78";
+        load_store[num].load_nop = "lwi\t%0,%1%# # MICROBLAZElwi78";
+        load_store[num].store = "swi\t%0,%1 # MICROBLAZEswi67";
+        load_store[num].last_store = "swi\t%0,%1 # MICROBLAZEswi67";
+        }*/
+      load_store[num].load=format_load_store(load_store[num].load,LOAD,SImode,src_reg,offset);
+      load_store[num].load_nop = load_store[num].load;
+      load_store[num].store=format_load_store(load_store[num].store,STORE,SImode,dest_reg,offset);
+      load_store[num].last_store = load_store[num].store;
+	    
+      load_store[num].final = 0;
+      load_store[num].mode = SImode;
+      offset += 4;
+      bytes -= 4;
+    }
+    else if (bytes >= 2 && align >= 2)
+    {
+      /*	  if(offset ==0){
+                  load_store[num].load = "lhu\t%0,%1 # MICROBLAZElhu121";
+                  load_store[num].load_nop = "lhu\t%0,%1% #MICROBLAZElhu122";
+                  load_store[num].store = "sh\t%0,%1 #MICROBLAZEsh121 ";
+                  load_store[num].last_store = "sh\t%0,%1 #MICROBLAZEshu122 ";
+                  }
+                  else	  
+                  {
+                  load_store[num].load = "lhui\t%0,%1 # MICROBLAZElhu111";
+                  load_store[num].load_nop = "lhui\t%0,%1% #MICROBLAZElhu112";
+                  load_store[num].store = "shi\t%0,%1 #MICROBLAZEsh111 ";
+                  load_store[num].last_store = "shi\t%0,%1 #MICROBLAZEshu112 ";
+                  }*/
+      load_store[num].load = 
+        format_load_store(load_store[num].load,LOAD,HImode,src_reg,offset);
+      load_store[num].load_nop = load_store[num].load;
+
+      load_store[num].store = 
+        format_load_store(load_store[num].store,STORE,HImode,dest_reg,offset);
+      load_store[num].last_store = load_store[num].store;
+	  
+      load_store[num].final = 0;
+      load_store[num].mode = HImode;
+      offset += 2;
+      bytes -= 2;
+    }
+    else
+    {
+      /*	  if (offset == 0) {
+                  load_store[num].load = "lbu\t%0,%1,r0 # MICROBLAZElbu45";
+                  load_store[num].load_nop = "lbu\t%0,r0,%1%# # MICROBLAZElbu45";
+                  load_store[num].store = "sbi\t%0,%1 # MICROBLAZEsb4";
+                  load_store[num].last_store = "sbi\t%0,%1 # MICROBLAZEsb5";
+                  }
+                  else {
+                  load_store[num].load = "lbui\t%0,%1 # MICROBLAZElbui45";
+                  load_store[num].load_nop = "lbui\t%0,%1%# # MICROBLAZElbui45";
+                  load_store[num].store = "sbi\t%0,%1 # MICROBLAZEsbi45";
+                  load_store[num].last_store = "sbi\t%0,%1 # MICROBLAZEsbi45";
+                  }
+      */
+      load_store[num].load = 
+        format_load_store(load_store[num].load,LOAD,QImode,src_reg,offset);
+      load_store[num].load_nop = load_store[num].load;
+
+      load_store[num].store = 
+        format_load_store(load_store[num].store,STORE,QImode,dest_reg,offset);
+      load_store[num].last_store = load_store[num].store;
+		    
+      load_store[num].final = 0;
+      load_store[num].mode = QImode;
+      offset++;
+      bytes--;
+    }
+
+    if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)
+    {
+      dslots_load_total++;
+      dslots_load_filled++;
+
+      if (CONSTANT_P (src_reg))
+        microblaze_count_memory_refs (src_reg, 1);
+
+      if (CONSTANT_P (dest_reg))
+        microblaze_count_memory_refs (dest_reg, 1);
+    }
+
+    /* Emit load/stores now if we have run out of registers or are
+       at the end of the move.  */
+
+    if (++num == num_regs || bytes == 0)
+    {
+      /* If only load/store, we need a NOP after the load.  */
+      if (num == 1)
+      {
+        load_store[0].load = load_store[0].load_nop;
+        if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)
+          dslots_load_filled--;
+      }
+
+      if (move_type != BLOCK_MOVE_LAST)
+      {
+        for (i = 0; i < num; i++)
+        {
+          int offset;
+
+          if (!operands[i + 4])
+            abort ();
+
+          if (GET_MODE (operands[i + 4]) != load_store[i].mode)
+            operands[i + 4] = gen_rtx_REG (load_store[i].mode,
+                                       REGNO (operands[i + 4]));
+
+          offset = load_store[i].offset;
+          xoperands[0] = operands[i + 4];
+          xoperands[1] = gen_rtx_MEM (load_store[i].mode,
+                                  plus_constant (src_reg, offset));
+
+          /*		  if(offset == 0){
+                          load_store[i].load = 
+                          format_load_store(load_store[num].load,LOAD,load_store[num].mode,
+                          xoperands[1],offset);
+                          load_store[i].load_nop = load_store[i].load; */
+          /*load_store[i].load = "lbu\t%0,%1,r0 # MICROBLAZElbu451";
+            load_store[i].load_nop = "lbu\t%0,r0,%1%# # MICROBLAZElbu452";*/
+          /*		  }*/
+		  
+
+          if (use_lwl_lwr)
+          {
+            int extra_offset
+              = GET_MODE_SIZE (load_store[i].mode) - 1;
+
+            xoperands[2] = gen_rtx_MEM (load_store[i].mode,
+                                    plus_constant (src_reg,
+                                                   extra_offset
+                                                   + offset));
+
+          }
+
+          output_asm_insn (load_store[i].load, xoperands);
+        }
+      }
+
+      for (i = 0; i < num; i++)
+      {
+        int last_p = (i == num-1 && bytes == 0);
+        int offset = load_store[i].offset;
+
+        xoperands[0] = operands[i + 4];
+        xoperands[1] = gen_rtx_MEM (load_store[i].mode,
+                                plus_constant (dest_reg, offset));
+
+	      
+        if (use_lwl_lwr)
+        {
+          int extra_offset = GET_MODE_SIZE (load_store[i].mode) - 1;
+          xoperands[2] = gen_rtx_MEM (load_store[i].mode,
+                                  plus_constant (dest_reg,
+                                                 extra_offset
+                                                 + offset));
+        }
+
+
+        if (move_type == BLOCK_MOVE_NORMAL)
+          output_asm_insn (load_store[i].store, xoperands);
+
+        else if (move_type == BLOCK_MOVE_NOT_LAST)
+        {
+          if (!last_p)
+            output_asm_insn (load_store[i].store, xoperands);
+
+          else if (load_store[i].final != 0)
+            output_asm_insn (load_store[i].final, xoperands);
+        }
+
+        else if (last_p)
+          output_asm_insn (load_store[i].last_store, xoperands);
+      }
+
+      num = 0;		/* reset load_store */
+      use_lwl_lwr = 0;
+    }
+  }
+
+  return "";
+}
+
+
+
+/* Argument support functions.  */
+
+/* Initialize CUMULATIVE_ARGS for a function.  */
+
+void
+init_cumulative_args (
+  CUMULATIVE_ARGS *cum,		/* argument info to initialize */
+  tree fntype,			/* tree ptr for function decl */
+  rtx libname ATTRIBUTE_UNUSED)	/* SYMBOL_REF of library name or 0 */
+{
+  static CUMULATIVE_ARGS zero_cum;
+  tree param, next_param;
+
+  if (TARGET_DEBUG_E_MODE)
+  {
+    fprintf (stderr,
+             "\ninit_cumulative_args, fntype = 0x%.8lx", (long)fntype);
+
+    if (!fntype)
+      fputc ('\n', stderr);
+
+    else
+    {
+      tree ret_type = TREE_TYPE (fntype);
+      fprintf (stderr, ", fntype code = %s, ret code = %s\n",
+               tree_code_name[(int)TREE_CODE (fntype)],
+               tree_code_name[(int)TREE_CODE (ret_type)]);
+    }
+  }
+
+  *cum = zero_cum;
+
+  /* Determine if this function has variable arguments.  This is
+     indicated by the last argument being 'void_type_mode' if there
+     are no variable arguments.  The standard MICROBLAZE calling sequence
+     passes all arguments in the general purpose registers in this case. */
+
+  for (param = fntype ? TYPE_ARG_TYPES (fntype) : 0;
+       param != 0; param = next_param)
+  {
+    next_param = TREE_CHAIN (param);
+    if (next_param == 0 && TREE_VALUE (param) != void_type_node)
+      cum->gp_reg_found = 1;
+  }
+}
+
+/* Advance the argument to the next argument position.  */
+
+void
+function_arg_advance (
+  CUMULATIVE_ARGS *cum,		/* current arg information */
+  enum machine_mode mode,	/* current arg mode */
+  tree type,			/* type of the argument or 0 if lib support */
+  int named)			/* whether or not the argument was named */
+{
+  if (TARGET_DEBUG_E_MODE)
+  {
+    fprintf (stderr,
+             "function_adv({gp reg found = %d, arg # = %2d, words = %2d}, %4s, ",
+             cum->gp_reg_found, cum->arg_number, cum->arg_words,
+             GET_MODE_NAME (mode));
+    fprintf (stderr, "%p", (void *)type);
+    fprintf (stderr, ", %d )\n\n", named);
+  }
+
+  cum->arg_number++;
+  switch (mode)
+  {
+    case VOIDmode:
+      break;
+
+    default:
+      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
+          && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)
+        abort ();
+
+      cum->gp_reg_found = 1;
+      cum->arg_words += ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)
+                         / UNITS_PER_WORD);
+      break;
+
+    case BLKmode:
+      cum->gp_reg_found = 1;
+      cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)
+                         / UNITS_PER_WORD);
+      break;
+
+    case SFmode:
+      cum->arg_words++;
+      if (! cum->gp_reg_found && cum->arg_number <= 2)
+        cum->fp_code += 1 << ((cum->arg_number - 1) * 2);
+      break;
+
+    case DFmode:
+      cum->arg_words += 2;
+      if (! cum->gp_reg_found && ! TARGET_SINGLE_FLOAT && cum->arg_number <= 2)
+        cum->fp_code += 2 << ((cum->arg_number - 1) * 2);
+      break;
+
+    case DImode:
+      cum->gp_reg_found = 1;
+      cum->arg_words += 2;
+      break;
+
+    case QImode:
+    case HImode:
+    case SImode:
+      cum->gp_reg_found = 1;
+      cum->arg_words++;
+      break;
+  }
+}
+
+/* Return an RTL expression containing the register for the given mode,
+   or 0 if the argument is to be passed on the stack.  */
+
+struct rtx_def *
+function_arg (
+  CUMULATIVE_ARGS *cum,		/* current arg information */
+  enum machine_mode mode,	/* current arg mode */
+  tree type,			/* type of the argument or 0 if lib support */
+  int named)			/* != 0 for normal args, == 0 for ... args */
+{
+  rtx ret;
+  int regbase = -1;
+  int *arg_words = &cum->arg_words;
+  int struct_p = (type != 0
+                  && (TREE_CODE (type) == RECORD_TYPE
+                      || TREE_CODE (type) == UNION_TYPE
+                      || TREE_CODE (type) == QUAL_UNION_TYPE));
+
+  if (TARGET_DEBUG_E_MODE)
+  {
+    fprintf (stderr,
+             "function_arg( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, ",
+             cum->gp_reg_found, cum->arg_number, cum->arg_words,
+             GET_MODE_NAME (mode));
+    fprintf (stderr, "%p", (void *)type);
+    fprintf (stderr, ", %d ) = ", named);
+  }
+  
+  cum->last_arg_fp = 0;
+  switch (mode)
+  {
+    case SFmode:
+      regbase = GP_ARG_FIRST;
+      break;
+    case DFmode:
+      regbase = GP_ARG_FIRST;
+      break;
+    default:
+      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
+          && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)
+        abort ();
+      /* Drops through.  */
+    case BLKmode:
+      regbase = GP_ARG_FIRST;
+      break;
+
+    case VOIDmode:
+    case QImode:
+    case HImode:
+    case SImode:
+      regbase = GP_ARG_FIRST;
+      break;
+    case DImode:
+      regbase = GP_ARG_FIRST;
+  }
+
+  if (*arg_words >= MAX_ARGS_IN_REGISTERS)
+  {
+    if (TARGET_DEBUG_E_MODE)
+      fprintf (stderr, "<stack>%s\n", struct_p ? ", [struct]" : "");
+
+    ret = 0;
+  }
+  else
+  {
+    if (regbase == -1)
+      abort ();
+
+    ret = gen_rtx_REG (mode, regbase + *arg_words);
+
+    if (TARGET_DEBUG_E_MODE)
+      fprintf (stderr, "%s%s\n", reg_names[regbase + *arg_words],
+               struct_p ? ", [struct]" : "");
+
+    /* The following is a hack in order to pass 1 byte structures
+       the same way that the MICROBLAZE compiler does (namely by passing
+       the structure in the high byte or half word of the register).
+       This also makes varargs work.  If we have such a structure,
+       we save the adjustment RTL, and the call define expands will
+       emit them.  For the VOIDmode argument (argument after the
+       last real argument), pass back a parallel vector holding each
+       of the adjustments.  */
+
+    /* ??? function_arg can be called more than once for each argument.
+       As a result, we compute more adjustments than we need here.
+       See the CUMULATIVE_ARGS definition in microblaze.h.  */
+
+    /* ??? This scheme requires everything smaller than the word size to
+       shifted to the left
+    */
+
+    /* XLNX [We might not need to do this for MicroBlaze . Seems to cause a problem 
+       while passing small structs */
+#if 0
+    if (struct_p && int_size_in_bytes (type) < UNITS_PER_WORD)
+    {
+      rtx amount = GEN_INT (BITS_PER_WORD
+                            - int_size_in_bytes (type) * BITS_PER_UNIT);
+      rtx reg = gen_rtx_REG (word_mode, regbase + *arg_words);
+
+	  
+      cum->adjust[cum->num_adjusts++] = gen_ashlsi3 (reg, reg, amount);
+    }
+#endif
+      }
+
+  if (mode == VOIDmode)
+  {
+    if (cum->num_adjusts > 0)
+      ret = gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,
+                     gen_rtvec_v (cum->num_adjusts, cum->adjust));
+  }
+
+  return ret;
+}
+
+int
+function_arg_partial_nregs (
+  CUMULATIVE_ARGS *cum,		/* current arg information */
+  enum machine_mode mode,	/* current arg mode */
+  tree type,			/* type of the argument or 0 if lib support */
+  int named ATTRIBUTE_UNUSED)   /* != 0 for normal args, == 0 for ... args */
+{
+  if ((mode == BLKmode
+       || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
+       || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)
+      && cum->arg_words < MAX_ARGS_IN_REGISTERS)
+  {
+    int words;
+    if (mode == BLKmode)
+      words = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)
+               / UNITS_PER_WORD);
+    else
+      words = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+
+    if (words + cum->arg_words <= MAX_ARGS_IN_REGISTERS)
+      return 0;		/* structure fits in registers */
+
+    if (TARGET_DEBUG_E_MODE)
+      fprintf (stderr, "function_arg_partial_nregs = %d\n",
+               MAX_ARGS_IN_REGISTERS - cum->arg_words);
+
+    return MAX_ARGS_IN_REGISTERS - cum->arg_words;
+  }
+
+  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS-1)
+  {
+    if (TARGET_DEBUG_E_MODE)
+      fprintf (stderr, "function_arg_partial_nregs = 1\n");
+        
+    return 1;
+  }
+    
+  return 0;
+}
+
+/*  Convert a version number of the form "vX.YY.Z" to an integer encoding 
+    for easier range comparison */
+static int 
+microblaze_version_to_int (const char *version)
+{
+  const char *p, *v;
+  const char *tmpl = "vX.YY.Z";
+  int iver = 0;
+#if 0
+  int pos = 0;
+#endif
+  
+  iver = 0;
+  
+  p = (char *)version;
+  v = tmpl;
+  
+  while (*v) {
+    if (*v == 'X') {            /* Looking for major */
+      if (!(*p >= '0' && *p <= '9'))
+        return -1;
+      iver += (int)(*p - '0');
+      iver *= 10;
+    } else if (*v == 'Y') {     /* Looking for minor */
+      if (!(*p >= '0' && *p <= '9'))
+        return -1;
+      iver += (int)(*p - '0');
+      iver *= 10;
+    } else if (*v == 'Z') {     /* Looking for compat */
+      if (!(*p >= 'a' && *p <= 'z'))
+        return -1;
+      iver *= 10;
+      iver += (int)(*p - 'a');
+    } else {
+      if (*p != *v)
+        return -1;
+    }
+        
+    v++;
+    p++;
+  }
+    
+  if (*p)
+    return -1;
+
+  return iver;
+}
+
+/* Compare two given microblaze versions and return a verdict
+ */
+static int
+microblaze_version_compare (const char *va, const char *vb) 
+{
+  return strcasecmp (va, vb);
+}
+
+/* Set up the threshold for data to go into the small data area, instead
+   of the normal data area, and detect any conflicts in the switches.  */
+
+static bool
+microblaze_handle_option (size_t code, 
+			  const char *arg ATTRIBUTE_UNUSED, 
+		          int value ATTRIBUTE_UNUSED)
+{
+  switch (code)
+    {
+    /* Check if we are asked to not clear BSS 
+       If YES, we do not place zero initialized in BSS  */
+    case OPT_mno_clearbss:
+      flag_zero_initialized_in_bss = 0;
+      break;
+    }
+  return true;
+}
+
+
+void
+override_options (void)
+{
+  register int i, start;
+  register int regno;
+  register enum machine_mode mode;
+  int ver;
+
+
+  microblaze_section_threshold = g_switch_set ? g_switch_value : MICROBLAZE_DEFAULT_GVALUE;
+
+  /* Check the Microblaze CPU version for any special action that needs to be done */
+  ver = microblaze_version_to_int (microblaze_select.cpu);
+  if (ver == -1) {
+    error ("(%s) is an invalid argument to -mcpu=\n", microblaze_select.cpu);
+  }
+
+  ver = microblaze_version_compare (microblaze_select.cpu, "v3.00.a");
+  if (ver < 0) {                                                        /* No hardware exceptions in earlier versions. So no worries */
+    microblaze_select.flags &= ~(MICROBLAZE_MASK_NO_UNSAFE_DELAY);
+    microblaze_no_unsafe_delay = 0;
+    microblaze_pipe = MICROBLAZE_PIPE_3;
+  } else if (ver == 0 || (microblaze_version_compare (microblaze_select.cpu, "v4.00.b") == 0)) {
+    microblaze_select.flags |= (MICROBLAZE_MASK_NO_UNSAFE_DELAY);
+    microblaze_no_unsafe_delay = 1;
+    microblaze_pipe = MICROBLAZE_PIPE_3;
+  } else {
+    microblaze_select.flags &= ~(MICROBLAZE_MASK_NO_UNSAFE_DELAY);
+    microblaze_no_unsafe_delay = 0;
+    microblaze_pipe = MICROBLAZE_PIPE_5;                                /* We agree to use 5 pipe-stage model even on area optimized 3 pipe-stage variants. */
+    if (microblaze_version_compare (microblaze_select.cpu, "v5.00.a") == 0 ||
+        microblaze_version_compare (microblaze_select.cpu, "v5.00.b") == 0 ||
+        microblaze_version_compare (microblaze_select.cpu, "v5.00.c") == 0) {
+        target_flags |= MASK_PATTERN_COMPARE;                           /* Pattern compares are to be turned on by default only when compiling for MB v5.00.'z' */
+    }
+  }
+
+  ver = microblaze_version_compare (microblaze_select.cpu, "v6.00.a");
+  if (ver < 0) {
+      if (TARGET_MULTIPLY_HIGH)
+          warning (0, "-mxl-multiply-high can be used only with -mcpu=v6.00.a or greater.\n");
+  }
+
+  if (TARGET_MULTIPLY_HIGH && TARGET_SOFT_MUL)
+      error ("-mxl-multiply-high requires -mno-xl-soft-mul.\n");
+
+  /* Always use DFA scheduler */
+  microblaze_sched_use_dfa = 1;
+  
+  /* Tell halfpic.c that we have half-pic code if we do.  */
+  if (TARGET_HALF_PIC)
+    HALF_PIC_INIT ();
+
+  microblaze_abicalls = MICROBLAZE_ABICALLS_NO;
+  /* printf("microblaze_abi %d microblaze_abicalls %d\n",
+     microblaze_abi, microblaze_abicalls); */
+  /* -membedded-pic is a form of PIC code suitable for embedded
+     systems.  All calls are made using PC relative addressing, and
+     all data is addressed using the $gp register.  This requires gas,
+     which does most of the work, and GNU ld, which automatically
+     expands PC relative calls which are out of range into a longer
+     instruction sequence.  All gcc really does differently is
+     generate a different sequence for a switch.  */
+  if (TARGET_EMBEDDED_PIC)
+  {
+    flag_pic = 1;
+
+    if (g_switch_set)
+      warning (0, "-G and -membedded-pic are incompatible");
+
+    /* Setting microblaze_section_threshold is not required, because gas
+       will force everything to be GP addressable anyhow, but
+       setting it will cause gcc to make better estimates of the
+       number of instructions required to access a particular data
+       item.  */
+    microblaze_section_threshold = 0x7fffffff;
+  }
+
+  /* Initialize the high and low values for legitimate floating point
+     constants.  Rather than trying to get the accuracy down to the
+     last bit, just use approximate ranges.  */
+  dfhigh = REAL_VALUE_ATOF ("1.0e300", DFmode);
+  dflow = REAL_VALUE_ATOF ("1.0e-300", DFmode);
+  sfhigh = REAL_VALUE_ATOF ("1.0e38", SFmode);
+  sflow = REAL_VALUE_ATOF ("1.0e-38", SFmode);
+
+  microblaze_print_operand_punct['?'] = 1;
+  microblaze_print_operand_punct['#'] = 1;
+  microblaze_print_operand_punct['&'] = 1;
+  microblaze_print_operand_punct['!'] = 1;
+  microblaze_print_operand_punct['*'] = 1;
+  microblaze_print_operand_punct['@'] = 1;
+  microblaze_print_operand_punct['.'] = 1;
+  microblaze_print_operand_punct['('] = 1;
+  microblaze_print_operand_punct[')'] = 1;
+  microblaze_print_operand_punct['['] = 1;
+  microblaze_print_operand_punct[']'] = 1;
+  microblaze_print_operand_punct['<'] = 1;
+  microblaze_print_operand_punct['>'] = 1;
+  microblaze_print_operand_punct['{'] = 1;
+  microblaze_print_operand_punct['}'] = 1;
+  microblaze_print_operand_punct['^'] = 1;
+  microblaze_print_operand_punct['$'] = 1;
+  microblaze_print_operand_punct['+'] = 1;
+
+  microblaze_char_to_class['d'] = GR_REGS;
+  microblaze_char_to_class['f'] = NO_REGS;
+  microblaze_char_to_class['h'] = HI_REG;
+  microblaze_char_to_class['l'] = LO_REG;
+  microblaze_char_to_class['a'] = HILO_REG;
+  microblaze_char_to_class['x'] = MD_REGS;
+  microblaze_char_to_class['b'] = ALL_REGS;
+  microblaze_char_to_class['y'] = GR_REGS;
+  microblaze_char_to_class['z'] = ST_REGS;
+
+  /* For Divide count increments */
+  microblaze_print_operand_punct['-'] = 1;  /* print divide label */
+  microblaze_print_operand_punct['_'] = 1;  /* increment divide label */
+
+  /* Set up array to map GCC register number to debug register number.
+     Ignore the special purpose register numbers.  */
+
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    microblaze_dbx_regno[i] = -1;
+
+  start = GP_DBX_FIRST - GP_REG_FIRST;
+  for (i = GP_REG_FIRST; i <= GP_REG_LAST; i++)
+    microblaze_dbx_regno[i] = i + start;
+
+  start = FP_DBX_FIRST - FP_REG_FIRST;
+  for (i = FP_REG_FIRST; i <= FP_REG_LAST; i++)
+    microblaze_dbx_regno[i] = i + start;
+
+
+  /* Save GPR registers in word_mode sized hunks.  word_mode hasn't been
+     initialized yet, so we can't use that here.  */
+  gpr_mode = SImode;
+
+  /* Set up array giving whether a given register can hold a given mode.
+     At present, restrict ints from being in FP registers, because reload
+     is a little enthusiastic about storing extra values in FP registers,
+     and this is not good for things like OS kernels.  Also, due to the
+     mandatory delay, it is as fast to load from cached memory as to move
+     from the FP register.  */
+
+  for (mode = VOIDmode;
+       mode != MAX_MACHINE_MODE;
+       mode = (enum machine_mode) ((int)mode + 1))
+  {
+    register int size              = GET_MODE_SIZE (mode);
+#if 0
+    register enum mode_class class = GET_MODE_CLASS (mode);
+#endif
+
+    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    {
+      register int ok;
+
+      if (mode == CCmode) {
+        ok = (ST_REG_P (regno) || GP_REG_P (regno)
+              || FP_REG_P (regno));
+      }
+      else if (GP_REG_P (regno))
+        ok = ((regno & 1) == 0 || size <= UNITS_PER_WORD); 
+      else 
+        ok = 0;
+
+      microblaze_hard_regno_mode_ok[(int)mode][regno] = ok;
+    }
+  }
+}
+
+void
+microblaze_order_regs_for_local_alloc (void)
+{
+  register int i;
+
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    reg_alloc_order[i] = i;
+
+}
+
+
+/* The MICROBLAZE debug format wants all automatic variables and arguments
+   to be in terms of the virtual frame pointer (stack pointer before
+   any adjustment in the function), while the MICROBLAZE 3.0 linker wants
+   the frame pointer to be the stack pointer after the initial
+   adjustment.  So, we do the adjustment here.  The arg pointer (which
+   is eliminated) points to the virtual frame pointer, while the frame
+   pointer (which may be eliminated) points to the stack pointer after
+   the initial adjustments.  */
+
+HOST_WIDE_INT
+microblaze_debugger_offset (
+  rtx addr,
+  HOST_WIDE_INT offset)
+{
+  rtx offset2 = const0_rtx;
+  rtx reg = eliminate_constant_term (addr, &offset2);
+
+  if (offset == 0)
+    offset = INTVAL (offset2);
+
+  if (reg == stack_pointer_rtx || reg == frame_pointer_rtx
+      || reg == hard_frame_pointer_rtx)
+  {
+    HOST_WIDE_INT frame_size = (!current_frame_info.initialized)
+      ? compute_frame_size (get_frame_size ())
+      : current_frame_info.total_size;
+
+    offset = offset - frame_size;
+  }
+
+  /* sdbout_parms does not want this to crash for unrecognized cases.  */
+#if 0
+  else if (reg != arg_pointer_rtx)
+    fatal_insn ("microblaze_debugger_offset called with non stack/frame/arg pointer.", addr);
+#endif
+
+  return offset;
+}
+
+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame
+   pointer or argument pointer or the return address pointer.  TO is either the stack pointer or
+   hard frame pointer.  */
+
+HOST_WIDE_INT
+microblaze_initial_elimination_offset (int from, int to)
+{  
+  HOST_WIDE_INT offset;
+    
+  switch (from) {
+    case FRAME_POINTER_REGNUM:
+      offset = 0;
+      break;
+    case ARG_POINTER_REGNUM:
+      if (to == STACK_POINTER_REGNUM || to == HARD_FRAME_POINTER_REGNUM)
+        offset = compute_frame_size (get_frame_size ());				 
+      else {
+        abort ();
+      }
+      break;
+    case RETURN_ADDRESS_POINTER_REGNUM:
+      if (current_function_is_leaf) 						 
+        offset = 0;				 			 
+      else 
+        offset = current_frame_info.gp_offset + 
+          ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT)));
+      break;
+    default:
+      abort ();
+  }
+  return offset;
+}
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand X.  X is an RTL
+   expression.
+
+   CODE is a value that can be used to specify one of several ways
+   of printing the operand.  It is used when identical operands
+   must be printed differently depending on the context.  CODE
+   comes from the `%' specification that was used to request
+   printing of the operand.  If the specification was just `%DIGIT'
+   then CODE is 0; if the specification was `%LTR DIGIT' then CODE
+   is the ASCII code for LTR.
+
+   If X is a register, this macro should print the register's name.
+   The names can be found in an array `reg_names' whose type is
+   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.
+
+   When the machine description has a specification `%PUNCT' (a `%'
+   followed by a punctuation character), this macro is called with
+   a null pointer for X and the punctuation character for CODE.
+
+   The MICROBLAZE specific codes are:
+
+   'X'  X is CONST_INT, prints 32 bits in hexadecimal format = "0x%08x",
+   'x'  X is CONST_INT, prints 16 bits in hexadecimal format = "0x%04x",
+   'd'  output integer constant in decimal,
+   'z'	if the operand is 0, use $0 instead of normal operand.
+   'D'  print second register of double-word register operand.
+   'L'  print low-order register of double-word register operand.
+   'M'  print high-order register of double-word register operand.
+   'C'  print part of opcode for a branch condition.
+   'N'  print part of opcode for a branch condition, inverted.
+   'S'  X is CODE_LABEL, print with prefix of "LS" (for embedded switch).
+   'B'  print 'z' for EQ, 'n' for NE
+   'b'  print 'n' for EQ, 'z' for NE
+   'T'  print 'f' for EQ, 't' for NE
+   't'  print 't' for EQ, 'f' for NE
+   'Z'  print register and a comma, but print nothing for $fcc0
+   '?'	Print 'd' if we are to use a branch with delay slot instead of normal branch.
+   '@'	Print the name of the assembler temporary register (at or rMB_ABI_ASM_TEMP_REGNUM).
+   '.'	Print the name of the register with a hard-wired zero (zero or r0).
+   '^'	Print the name of the pic call-through register (t9 or rMB_ABI_PIC_FUNC_REGNUM).
+   '$'	Print the name of the stack pointer register (sp or rMB_ABI_STACK_POINTER_REGNUM).
+   '+'	Print the name of the gp register (gp or rMB_ABI_GPRO_REGNUM).  
+   '#'	Print nop if NOT in a .set noreorder section ie if the delay slot of a branch is not filled. */
+
+void
+print_operand (
+  FILE *file,		/* file to write to */
+  rtx op,		/* operand to print */
+  int letter)		/* %<letter> or 0 */
+{
+  register enum rtx_code code;
+
+  if (PRINT_OPERAND_PUNCT_VALID_P (letter))
+  {
+    switch (letter)
+    {
+      case '?':                             /* Conditionally add a 'd' to indicate filled delay slot */
+        if (final_sequence != NULL)
+          fputs ("d", file);
+        break;
+
+      case '#':                             /* Conditionally add a nop in unfilled delay slot */
+        if (final_sequence == NULL) 
+          fputs ("nop\t\t# Unfilled delay slot\n", file);
+        break;
+
+      case '@':
+        fputs (reg_names [GP_REG_FIRST + MB_ABI_ASM_TEMP_REGNUM], file);
+        break;
+
+      case '^':
+        fputs (reg_names [PIC_FUNCTION_ADDR_REGNUM], file);
+        break;
+
+      case '.':
+        fputs (reg_names [GP_REG_FIRST + 0], file);
+        break;
+
+      case '$':
+        fputs (reg_names[STACK_POINTER_REGNUM], file);
+        break;
+
+      case '+':
+        fputs (reg_names[GP_REG_FIRST + MB_ABI_GPRO_REGNUM], file);
+        break;
+
+      case '-':
+        fprintf(file,"%sL%d_",LOCAL_LABEL_PREFIX,div_count);
+        break;
+
+      case '_':
+        div_count++;
+        break;
+
+        /*  case 'g':
+            fputs("i",file);
+     
+            break;
+        */
+      default:
+        error ("PRINT_OPERAND: Unknown punctuation '%c'", letter);
+        break;
+    }
+
+    return;
+  }
+
+  if (! op)
+  {
+    error ("PRINT_OPERAND null pointer");
+    return;
+  }
+
+  code = GET_CODE (op);
+
+  if (code == SIGN_EXTEND)
+    op = XEXP (op, 0), code = GET_CODE (op);
+
+  if (letter == 'C')
+    switch (code)
+    {
+      case EQ:	fputs ("eq",  file); break;
+      case NE:	fputs ("ne",  file); break;
+      case GT:	fputs ("gt",  file); break;
+      case GE:	fputs ("ge",  file); break;
+      case LT:	fputs ("lt",  file); break;
+      case LE:	fputs ("le",  file); break;
+      case GTU: fputs ("gtu", file); break;
+      case GEU: fputs ("geu", file); break;
+      case LTU: fputs ("ltu", file); break;
+      case LEU: fputs ("leu", file); break;
+      default:
+        fatal_insn ("PRINT_OPERAND, invalid insn for %%C", op);
+    }
+
+  else if (letter == 'N')
+    switch (code)
+    {
+      case EQ:	fputs ("ne",  file); break;
+      case NE:	fputs ("eq",  file); break;
+      case GT:	fputs ("le",  file); break;
+      case GE:	fputs ("lt",  file); break;
+      case LT:	fputs ("ge",  file); break;
+      case LE:	fputs ("gt",  file); break;
+      case GTU: fputs ("leu", file); break;
+      case GEU: fputs ("ltu", file); break;
+      case LTU: fputs ("geu", file); break;
+      case LEU: fputs ("gtu", file); break;
+      default:
+        fatal_insn ("PRINT_OPERAND, invalid insn for %%N", op);
+    }
+
+  else if (letter == 'S')
+  {
+    char buffer[100];
+
+    ASM_GENERATE_INTERNAL_LABEL (buffer, "LS", CODE_LABEL_NUMBER (op));
+    assemble_name (file, buffer);
+  }
+
+  else if (letter == 'Z')
+  {
+    register int regnum;
+
+    if (code != REG)
+      abort ();
+
+    regnum = REGNO (op);
+    if (! ST_REG_P (regnum))
+      abort ();
+
+    if (regnum != ST_REG_FIRST)
+      fprintf (file, "%s,", reg_names[regnum]);
+  }
+
+  else if (code == REG || code == SUBREG)
+  {
+    register int regnum;
+
+    if (code == REG)
+      regnum = REGNO (op);
+    else
+      regnum = true_regnum (op);
+
+    if ((letter == 'M' && ! WORDS_BIG_ENDIAN)
+        || (letter == 'L' && WORDS_BIG_ENDIAN)
+        || letter == 'D')
+      regnum++;
+
+    fprintf (file, "%s", reg_names[regnum]);
+  }
+
+  else if (code == MEM)
+    output_address (XEXP (op, 0));
+
+  else if (code == CONST_DOUBLE
+           && GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT)
+  {
+/* GCC 3.4.1 
+ * Removed the REAL_VALUE_TO_DECIMAL part 
+ */
+#if 0 
+    REAL_VALUE_TYPE d;
+    char s[30];
+    if(!printed){
+      /*fprintf(stderr,"Printing done here\n");*/
+      REAL_VALUE_FROM_CONST_DOUBLE (d, op);
+      REAL_VALUE_TO_DECIMAL (d, "%.20e", s);
+      fprintf (file, s);
+    }
+#else
+    char s[60];
+
+    real_to_decimal (s, CONST_DOUBLE_REAL_VALUE (op), sizeof (s), 0, 1);
+    fputs (s, file);
+#endif
+  }
+   
+
+  else if (letter == 'x' && GET_CODE (op) == CONST_INT)
+    fprintf (file, HOST_WIDE_INT_PRINT_HEX, 0xffff & INTVAL(op));
+
+  else if (letter == 'X' && GET_CODE(op) == CONST_INT)
+    fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));
+
+  else if (letter == 'd' && GET_CODE(op) == CONST_INT)
+    fprintf (file, HOST_WIDE_INT_PRINT_DEC, (INTVAL(op)));
+
+  else if (letter == 'z' && GET_CODE (op) == CONST_INT && INTVAL (op) == 0)
+    fputs (reg_names[GP_REG_FIRST], file);
+
+  else if (letter == 'd' || letter == 'x' || letter == 'X')
+    error ("PRINT_OPERAND: letter %c was found & insn was not CONST_INT",
+           letter);
+
+  else if (letter == 'B')
+    fputs (code == EQ ? "z" : "n", file);
+  else if (letter == 'b')
+    fputs (code == EQ ? "n" : "z", file);
+  else if (letter == 'T')
+    fputs (code == EQ ? "f" : "t", file);
+  else if (letter == 't')
+    fputs (code == EQ ? "t" : "f", file);
+
+  else if (code == CONST && GET_CODE (XEXP (op, 0)) == REG)
+  {
+    print_operand (file, XEXP (op, 0), letter);
+  }
+  else if (letter == 'I')
+    div_count++;
+  else
+    output_addr_const (file, op);
+}
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand that is a memory
+   reference whose address is ADDR.  ADDR is an RTL expression.
+
+   Possible address classifications and output formats are,
+   
+   ADDRESS_REG                  "%0, r0"
+
+   ADDRESS_REG with non-zero    "%0, <addr_const>"
+   offset       
+
+   ADDRESS_REG_INDEX            "rA, RB"    
+                                (if rA is r0, rA and rB are swapped)
+
+   ADDRESS_CONST_INT            "r0, <addr_const>"
+
+   ADDRESS_SYMBOLIC             "rBase, <addr_const>"   
+                                (rBase is a base register suitable for the symbol's type)
+*/
+
+void
+print_operand_address (
+  FILE *file,
+  rtx addr)
+{
+  struct microblaze_address_info info;
+  if (!microblaze_classify_address (&info, addr, GET_MODE (addr), 1)) 
+    fatal_insn ("insn contains an invalid address !", addr);
+  
+  switch (info.type) {
+    case ADDRESS_REG:
+      fprintf (file, "%s,", reg_names[REGNO (info.regA)]);
+      output_addr_const (file, info.offset);             
+      break;
+    case ADDRESS_REG_INDEX:
+      if (REGNO (info.regA) == 0)                                       /* Make rB == r0 instead of rA == r0. This helps reduce read port congestion */
+        fprintf (file, "%s,%s", reg_names[REGNO (info.regB)], reg_names[REGNO (info.regA)]);    
+      else if (REGNO (info.regB) != 0)
+        fprintf (file, "%s,%s", reg_names[REGNO (info.regB)], reg_names[REGNO (info.regA)]);        /* This is a silly swap to help Dhrystone */
+      break;
+    case ADDRESS_CONST_INT:
+      fprintf (file, "%s,", reg_names[REGNO (info.regA)]);
+      output_addr_const (file, info.offset);
+      break;
+    case ADDRESS_SYMBOLIC:
+      fprintf (file, "%s,", reg_names[REGNO (info.regA)]);
+      output_addr_const (file, info.symbol);
+      break;
+    case ADDRESS_INVALID:
+      fatal_insn ("invalid address", addr);
+      break;
+  }
+}
+
+/* If optimizing for the global pointer, keep track of all of the externs, so
+   that at the end of the file, we can emit the appropriate .extern
+   declaration for them, before writing out the text section.  We assume all
+   names passed to us are in the permanent obstack, so they will be valid at
+   the end of the compilation.
+
+   If we have -G 0, or the extern size is unknown, or the object is in a user
+   specified section that is not .sbss/.sdata, don't bother emitting the
+   .externs.  In the case of user specified sections this behaviour is
+   required as otherwise GAS will think the object lives in .sbss/.sdata.  */
+
+int
+microblaze_output_external (
+  FILE *file ATTRIBUTE_UNUSED,
+  tree decl,
+  char *name)
+{
+  register struct extern_list *p;
+  int len;
+  tree section_name;
+
+  if (TARGET_GP_OPT
+      && TREE_CODE (decl) != FUNCTION_DECL
+      && (len = int_size_in_bytes (TREE_TYPE (decl))) > 0
+      && ((section_name = DECL_SECTION_NAME (decl)) == NULL
+          || strcmp (TREE_STRING_POINTER (section_name), ".sbss") == 0
+          || strcmp (TREE_STRING_POINTER (section_name), ".sdata") == 0))
+  {
+    p = (struct extern_list *) /* permalloc */ xmalloc (sizeof (struct extern_list));
+    p->next = extern_head;
+    p->name = name;
+    p->size = len;
+    extern_head = p;
+  }
+
+#ifdef ASM_OUTPUT_UNDEF_FUNCTION
+  if (TREE_CODE (decl) == FUNCTION_DECL
+      /* ??? Don't include alloca, since gcc will always expand it
+         inline.  If we don't do this, the C++ library fails to build.  */
+      && strcmp (name, "alloca")
+      /* ??? Don't include __builtin_next_arg, because then gcc will not
+         bootstrap under Irix 5.1.  */
+      && strcmp (name, "__builtin_next_arg"))
+  {
+    p = (struct extern_list *) /* permalloc */ xmalloc (sizeof (struct extern_list));
+    p->next = extern_head;
+    p->name = name;
+    p->size = -1;
+    extern_head = p;
+  }
+#endif
+
+  return 0;
+}
+
+#ifdef ASM_OUTPUT_UNDEF_FUNCTION
+int
+microblaze_output_external_libcall (file, name)
+  FILE *file;
+  char *name;
+{
+  register struct extern_list *p;
+
+  p = (struct extern_list *) /* permalloc */ xmalloc (sizeof (struct extern_list));
+  p->next = extern_head;
+  p->name = name;
+  p->size = -1;
+  extern_head = p;
+
+  return 0;
+}
+#endif
+
+/* Compute a string to use as a temporary file name.  */
+
+/* On MSDOS, write temp files in current dir
+   because there's no place else we can expect to use.  */
+#if __MSDOS__
+#ifndef P_tmpdir
+#define P_tmpdir "./"
+#endif
+#endif
+
+/* Emit a new filename to a stream.  If this is MICROBLAZE ECOFF, watch out
+   for .file's that start within a function.  If we are smuggling stabs, try to
+   put out a MICROBLAZE ECOFF file and a stab.  */
+
+void
+microblaze_output_filename (
+  FILE *stream,
+  const char* name)
+{
+  static int first_time = 1;
+  char ltext_label_name[100];
+
+  if (first_time)
+  {
+    first_time = 0;
+    SET_FILE_NUMBER ();
+    current_function_file = name;
+    fprintf (stream, "\t.file\t%d ", num_source_filenames);
+    output_quoted_string (stream, name);
+    putc ('\n', stream);
+  }
+
+  else if (write_symbols == DBX_DEBUG)
+  {
+    ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, "Ltext", 0);
+    fprintf (stream, "%s ", ASM_STABS_OP);
+    output_quoted_string (stream, name);
+    fprintf (stream, ",%d,0,0,%s\n", N_SOL, &ltext_label_name[1]);
+  }
+
+  else if (name != current_function_file
+           && strcmp (name, current_function_file) != 0)
+  {
+    SET_FILE_NUMBER ();
+    current_function_file = name;
+    fprintf (stream, "\t.file\t%d", num_source_filenames);
+    output_quoted_string (stream, name);
+  }
+}
+
+/* Emit a linenumber.  For encapsulated stabs, we need to put out a stab
+   as well as a .loc, since it is possible that MICROBLAZE ECOFF might not be
+   able to represent the location for inlines that come from a different
+   file.  */
+
+void
+microblaze_output_lineno (
+  FILE *stream,
+  int line)
+{
+  if (write_symbols == DBX_DEBUG)
+  {
+    ++sym_lineno;
+    fprintf (stream, "%sLM%d:\n\t%s %d,0,%d,%sLM%d",
+             LOCAL_LABEL_PREFIX, sym_lineno, ASM_STABN_OP, N_SLINE, line,
+             LOCAL_LABEL_PREFIX, sym_lineno);
+    fputc ('-', stream);
+    assemble_name (stream, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));
+    fprintf(stream,"\n");
+  }
+
+  else
+  {
+    fprintf (stream, "\n\t%s.loc\t%d %d\n",
+             (ignore_line_number) ? "#" : "",
+             num_source_filenames, line);
+  
+    LABEL_AFTER_LOC (stream);
+  }
+}
+
+/* Code to be executed just prior to the output of assembler code for INSN, 
+   to modify the extracted operands so they will be output differently.
+
+   Here the argument OPVEC is the vector containing the operands extracted
+   from INSN, and NOPERANDS is the number of elements of the vector which
+   contain meaningful data for this insn.  The contents of this vector are
+   what will be used to convert the insn template into assembler code, so you
+   can change the assembler output by changing the contents of the vector.
+
+   We use it to 
+    1) For the Gti pipeline, swap Ra and Rb, is Ra has the potential of being forwarded. 
+       There is congestion at the read port for Rd and Ra. So we want 
+       to minimize the number of times that this congestion occurs
+    3) Update the delay slot statistics.  */
+void
+final_prescan_insn (rtx insn, 
+		    rtx opvec[] ATTRIBUTE_UNUSED, 
+		    int noperands ATTRIBUTE_UNUSED)
+{
+  /* GTi stuff here 
+     -- Scan instruction sequence to see if a stall on a 'sw' can be avoided
+        by swapping operands, thus using a forwarding path from a preceding
+        instruction.
+
+        FIXME
+  */
+  
+  if (TARGET_STATS
+      && (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN))
+    dslots_jump_total++;
+}
+
+
+/* Output at beginning of assembler file.
+
+If we are optimizing to use the global pointer, create a temporary file to
+hold all of the text stuff, and write it out to the end. This is needed
+because the MICROBLAZE assembler is evidently one pass, and if it hasn't seen the
+relevant .comm/.lcomm/.extern/.sdata declaration when the code is
+processed, it generates a two instruction sequence.  */
+
+void
+microblaze_asm_file_start (void)
+{
+  default_file_start ();
+  /* GCC 3.4.1
+   * Removed. Caused segfaults.
+   */
+  /* ASM_OUTPUT_SOURCE_FILENAME (asm_out_file, main_input_filename); */
+    
+  /* Generate the pseudo ops that System V.4 wants.  */
+#ifndef ABICALLS_ASM_OP
+#define ABICALLS_ASM_OP ".abicalls"
+#endif
+    
+  /* This code exists so that we can put all externs before all symbol
+     references.  This is necessary for the MICROBLAZE assembler's global pointer
+     optimizations to work.  */
+  if (TARGET_FILE_SWITCHING )
+  {
+    asm_out_data_file = asm_out_file;
+    /* asm_out_text_file = xlnx_make_temp_file (); */
+    asm_out_text_file = tmpfile ();
+  }
+
+  else
+    asm_out_data_file = asm_out_text_file = asm_out_file;
+
+  if (flag_verbose_asm)
+    fprintf (asm_out_file, "\n%s -G value = %d\n",
+             ASM_COMMENT_START,
+             microblaze_section_threshold);
+}
+
+/* If we are optimizing the global pointer, emit the text section now and any
+   small externs which did not have .comm, etc that are needed.  Also, give a
+   warning if the data area is more than 32K and -pic because 3 instructions
+   are needed to reference the data pointers.  */
+
+void
+microblaze_asm_file_end (void)
+{
+  char buffer[8192];
+  tree name_tree;
+  struct extern_list *p;
+  int len;
+
+  if (HALF_PIC_P ())
+  {
+    HALF_PIC_FINISH (asm_out_file);
+  }
+
+  if (extern_head)
+  {
+    fputs ("\n", asm_out_file);
+
+    for (p = extern_head; p != 0; p = p->next)
+    {
+      name_tree = get_identifier (p->name);
+
+      /* Positively ensure only one .extern for any given symbol.  */
+      if (! TREE_ASM_WRITTEN (name_tree))
+      {
+        TREE_ASM_WRITTEN (name_tree) = 1;
+#ifdef ASM_OUTPUT_UNDEF_FUNCTION
+        if (p->size == -1)
+          ASM_OUTPUT_UNDEF_FUNCTION (asm_out_file, p->name);
+        else
+#endif
+        {
+          fputs ("\t.extern\t", asm_out_file);
+          assemble_name (asm_out_file, p->name);
+          fprintf (asm_out_file, ", %d\n", p->size);
+        }
+      }
+    }
+  }
+      
+  if (TARGET_FILE_SWITCHING )
+  {
+    fprintf (asm_out_file, "\n\t.text\n");
+    rewind (asm_out_text_file);
+    if (ferror (asm_out_text_file))
+      fatal_error ("can't rewind asm text file");
+
+    while ((len = fread (buffer, 1, sizeof (buffer), asm_out_text_file)) > 0)
+      if ((int) fwrite (buffer, 1, len, asm_out_file) != len)
+        fatal_error ("while reading asm text file");
+
+    if (len < 0)
+      fatal_error ("while reading asm text file");
+
+    if (fclose (asm_out_text_file) != 0)
+      fatal_error ("closing asm text file");
+
+#ifdef __MSDOS__
+    unlink (temp_filename);
+#endif
+  }
+}
+
+/* Output an element in the table of global constructors. */
+void 
+microblaze_asm_constructor (rtx symbol ATTRIBUTE_UNUSED, int priority) 
+{ 
+
+  const char *section = ".ctors";
+  char buf[16];
+
+  if (priority != DEFAULT_INIT_PRIORITY)
+  {
+    sprintf (buf, ".ctors.%.5u",
+             /* Invert the numbering so the linker puts us in the proper
+                order; constructors are run from right to left, and the
+                linker sorts in increasing order.  */
+             MAX_INIT_PRIORITY - priority);
+    section = buf;
+  }
+
+  named_section_flags (section, SECTION_WRITE);
+  fputs ("\t.word\t", asm_out_file);
+  output_addr_const (asm_out_file, symbol);
+  fputs ("\n", asm_out_file);
+} 
+
+/* Output an element in the table of global destructors. */
+void 
+microblaze_asm_destructor (rtx symbol, int priority) 
+{ 
+  const char *section = ".dtors";
+  char buf[16];
+
+  if (priority != DEFAULT_INIT_PRIORITY)
+  {
+    sprintf (buf, ".dtors.%.5u",
+             /* Invert the numbering so the linker puts us in the proper
+                order; constructors are run from right to left, and the
+                linker sorts in increasing order.  */
+             MAX_INIT_PRIORITY - priority);
+    section = buf;
+  }
+
+  named_section_flags (section, SECTION_WRITE);
+  fputs ("\t.word\t", asm_out_file);
+  output_addr_const (asm_out_file, symbol);
+  fputs ("\n", asm_out_file);
+} 
+   
+
+/* A function to output to the stdio stream stream a label whose name is made from the string prefix 
+   and the number labelno. */
+void 
+microblaze_internal_label (
+  FILE *STREAM,
+  const char* prefix,
+  unsigned long labelno)
+{
+  fprintf (STREAM, "%s%s%ld:\n", LOCAL_LABEL_PREFIX, prefix, labelno);
+}
+
+/* Emit either a label, .comm, or .lcomm directive, and mark that the symbol
+   is used, so that we don't emit an .extern for it in microblaze_asm_file_end.  */
+
+void
+microblaze_declare_object (FILE *stream, char *name, char *section, char *fmt, int size)
+{
+
+  fputs (section, stream);		/* "", "\t.comm\t", or "\t.lcomm\t" */
+  assemble_name (stream, name);
+  fprintf (stream, fmt, size);	/* ":\n", ",%u\n", ",%u\n" */
+
+  if (TARGET_GP_OPT)
+  {
+    tree name_tree = get_identifier (name);
+    TREE_ASM_WRITTEN (name_tree) = 1;
+  }
+}
+
+void
+microblaze_declare_comm_object (FILE *stream, char *name, char *section, char *fmt, int size, int align)
+{
+  if (size > 0 && size <= microblaze_section_threshold && TARGET_XLGP_OPT)
+    named_section (0, ".sbss", 0);
+  else
+    named_section (0, ".bss", 0);
+
+  fputs (section, stream);		
+  assemble_name (stream, name);
+  fprintf (stream, fmt, size, ((align)/BITS_PER_UNIT));	 
+  ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, "object");		       
+/*   if (!flag_inhibit_size_directive) */
+/*     ASM_OUTPUT_SIZE_DIRECTIVE (stream, name, size); */
+
+  if (TARGET_GP_OPT)
+  {
+    tree name_tree = get_identifier (name);
+    TREE_ASM_WRITTEN (name_tree) = 1;
+  }
+}
+
+/* Output a double precision value to the assembler.  If both the
+   host and target are IEEE, emit the values in hex.  */
+
+void
+microblaze_output_double (FILE *stream, REAL_VALUE_TYPE value)
+{
+  union {double d; REAL_VALUE_TYPE value; } val;
+#ifdef REAL_VALUE_TO_TARGET_DOUBLE
+  long value_long[2];
+  val.value = value;
+  REAL_VALUE_TO_TARGET_DOUBLE (value, value_long);
+   
+  fprintf (stream, "\t.word\t0x%08lx\t\t# %.20g\n\t.word\t0x%08lx\n",
+           value_long[0], val.d, value_long[1]);
+#else
+  val.value = value;
+  fprintf (stream, "\t.double\t%.20g\n", val.d);
+#endif
+}
+
+/* Output a single precision value to the assembler.  If both the
+   host and target are IEEE, emit the values in hex.  */
+
+void
+microblaze_output_float (FILE *stream, REAL_VALUE_TYPE value)
+{
+  union {double d; REAL_VALUE_TYPE value; } val;
+#ifdef REAL_VALUE_TO_TARGET_SINGLE
+  long value_long;
+  val.value = value;
+  REAL_VALUE_TO_TARGET_SINGLE (value, value_long);
+    
+  fprintf (stream, "\t.word\t0x%08lx\t\t# %.12g (float)\n", value_long, val.d);
+#else
+  val.value = value;
+  fprintf (stream, "\t.float\t%.12g\n", val.d);
+#endif
+}
+
+/* Return the bytes needed to compute the frame pointer from the current
+   stack pointer.
+
+   MicroBlaze stack frames look like:
+
+
+
+             Before call		        After call
+        +-----------------------+	+-----------------------+
+   high |			|       |      			|
+   mem. |  local variables,     |	|  local variables,	|
+        |  callee saved and     |       |  callee saved and    	|
+	|  temps     		|       |  temps     	        |
+        +-----------------------+	+-----------------------+
+        |  arguments for called	|       |  arguments for called |
+	|  subroutines		|	|  subroutines  	|
+        |  (optional)           |       |  (optional)           |
+        +-----------------------+	+-----------------------+
+	|  Link register 	|	|  Link register        |
+    SP->|                       |       |                       |
+	+-----------------------+       +-----------------------+
+					|		        |
+                                        |  local variables,     |
+                                        |  callee saved and     |
+                                        |  temps                |
+					+-----------------------+
+                                        |   MSR (optional if,   |
+                                        |   interrupt handler)  |
+					+-----------------------+
+					|			|
+                                        |  alloca allocations   |
+        				|			|
+					+-----------------------+
+					|			|
+                                        |  arguments for called |
+                                        |  subroutines          |
+                                        |  (optional)           |
+        				|		        |
+					+-----------------------+
+                                        |  Link register        |
+   low                           FP,SP->|                       |
+   memory        			+-----------------------+
+
+*/
+
+HOST_WIDE_INT
+compute_frame_size (
+  HOST_WIDE_INT size)                 /* # of var. bytes allocated */
+{
+  int regno;
+  HOST_WIDE_INT total_size;           /* # bytes that the entire frame takes up */
+  HOST_WIDE_INT var_size;             /* # bytes that local variables take up */
+  HOST_WIDE_INT args_size;            /* # bytes that outgoing arguments take up */
+  int link_debug_size;                /* # bytes for link register */
+  HOST_WIDE_INT gp_reg_size;          /* # bytes needed to store calle-saved gp regs */
+  long mask;                          /* mask of saved gp registers */
+#if 0
+  static int check = 0;
+#endif
+
+  interrupt_handler   = (microblaze_interrupt_function_p (current_function_decl));
+  save_volatiles      = (microblaze_save_volatiles (current_function_decl));
+
+  gp_reg_size = 0;
+  mask = 0;
+  var_size   = size;
+  args_size  = current_function_outgoing_args_size;
+  
+  if ((args_size == 0) && current_function_calls_alloca)
+    args_size = NUM_OF_ARGS * UNITS_PER_WORD;
+    
+  total_size = var_size + args_size;
+
+  /* Calculate space needed for gp registers.  */
+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)
+  {
+    if (MUST_SAVE_REGISTER (regno))
+    {
+      
+      if (regno != MB_ABI_SUB_RETURN_ADDR_REGNUM)               /* Don't account for link register. It is accounted specially below */
+        gp_reg_size += GET_MODE_SIZE (gpr_mode);
+
+      mask |= (1L << (regno - GP_REG_FIRST));
+    }
+  }
+  
+  total_size += gp_reg_size;
+
+  /* Add 4 bytes for MSR */                        
+  if (interrupt_handler)
+    total_size += 4; 
+                                              
+  /* No space to be allocated for link register in leaf functions with no other stack requirements */
+  if (total_size == 0 && current_function_is_leaf)
+    link_debug_size = 0;
+  else
+    link_debug_size = UNITS_PER_WORD;    
+
+  total_size += link_debug_size;
+
+  /* Save other computed information.  */
+  current_frame_info.total_size = total_size;
+  current_frame_info.var_size = var_size;
+  current_frame_info.args_size = args_size;
+  current_frame_info.gp_reg_size = gp_reg_size;
+  current_frame_info.mask = mask;
+  current_frame_info.initialized = reload_completed;
+  current_frame_info.num_gp = gp_reg_size / UNITS_PER_WORD;
+  current_frame_info.link_debug_size = link_debug_size; 
+
+#if 0
+  {
+    char *fnname;
+
+    fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+    fprintf(stderr," ----- stack usage stats for (%s) ---- \n", fnname);
+    fprintf(stderr,"total_size %d\n",total_size);
+    fprintf(stderr,"var_size %d\n",var_size);
+    fprintf(stderr,"args_size %d\n",args_size);
+    fprintf(stderr,"gp_reg_size %d\n",gp_reg_size);
+    fprintf(stderr,"mask %x\n",mask);
+    fprintf(stderr,"num_gp %d\n",current_frame_info.num_gp);
+    fprintf(stderr,"link_debug %d\n",link_debug_size);
+    fprintf(stderr," ----- end stack usage stats ---- \n");
+  }
+#endif
+
+  if (mask)
+    current_frame_info.gp_offset = (total_size - gp_reg_size);      /* Offset from which to callee-save GP regs */
+  else
+    current_frame_info.gp_offset = 0;
+  
+  /* Ok, we're done.  */
+  return total_size;
+}
+
+/* Common code to emit the insns (or to write the instructions to a file)
+   to save/restore registers.
+
+   Other parts of the code assume that MICROBLAZE_TEMP1_REGNUM (aka large_reg)
+   is not modified within save_restore_insns.  */
+
+#define BITSET_P(VALUE,BIT) (((VALUE) & (1L << (BIT))) != 0)
+
+/* Save or restore instructions based on whether this is the prologue or epilogue. 
+   prologue is 1 for the prologue */
+static void
+save_restore_insns (int prologue)
+{
+  rtx base_reg_rtx, reg_rtx, mem_rtx, /* msr_rtx, */ isr_reg_rtx, isr_mem_rtx, isr_msr_rtx, insn;
+  long mask = current_frame_info.mask;
+  HOST_WIDE_INT base_offset, gp_offset;
+  int regno;
+
+  if (frame_pointer_needed
+      && ! BITSET_P (mask, HARD_FRAME_POINTER_REGNUM - GP_REG_FIRST))
+    abort ();
+
+  if (mask == 0)
+    return;
+
+  /* Save registers starting from high to low.  The debuggers prefer at least
+     the return register be stored at func+4, and also it allows us not to
+     need a nop in the epilog if at least one register is reloaded in
+     addition to return address.  */
+  
+  
+  /* Pick which pointer to use as a base register.  For small frames, just
+     use the stack pointer.  Otherwise, use a temporary register.  Save 2
+     cycles if the save area is near the end of a large frame, by reusing
+     the constant created in the prologue/epilogue to adjust the stack
+     frame.  */
+  
+  gp_offset  = current_frame_info.gp_offset;
+  
+  if (gp_offset <= 0)
+    error ("gp_offset (%ld) is less than or equal to zero.", (long) gp_offset);
+  
+  base_reg_rtx = stack_pointer_rtx;
+  base_offset  = 0;
+  
+  /* For interrupt_handlers, need to save/restore the MSR */
+  if (interrupt_handler) {
+    isr_mem_rtx = gen_rtx_MEM (gpr_mode, 
+                           gen_rtx_PLUS (Pmode, base_reg_rtx, 
+                                    GEN_INT (current_frame_info.gp_offset - UNITS_PER_WORD)));
+
+    MEM_VOLATILE_P (isr_mem_rtx) = 1;                             /* Do not optimize in flow analysis */
+    isr_reg_rtx = gen_rtx_REG (gpr_mode, MB_ABI_MSR_SAVE_REG);
+    isr_msr_rtx = gen_rtx_REG (gpr_mode, ST_REG_FIRST);
+  }
+
+  if (interrupt_handler && !prologue) {
+    emit_move_insn (isr_reg_rtx, isr_mem_rtx);
+    emit_move_insn (isr_msr_rtx, isr_reg_rtx);
+    emit_insn (gen_rtx_USE (SImode, isr_reg_rtx));                  /* Do not optimize in flow analysis */
+    emit_insn (gen_rtx_USE (SImode, isr_msr_rtx));                  /* Do not optimize in flow analysis */
+  } 
+
+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++) 
+  {
+    if (BITSET_P (mask, regno - GP_REG_FIRST))
+    {
+      if (regno == MB_ABI_SUB_RETURN_ADDR_REGNUM)             /* Don't handle here. Already handled as the first register */
+        continue;
+
+      reg_rtx = gen_rtx_REG (gpr_mode, regno);  
+      insn = gen_rtx_PLUS (Pmode, base_reg_rtx, GEN_INT (gp_offset));
+      mem_rtx = gen_rtx_MEM (gpr_mode, insn);
+      if (interrupt_handler)
+        MEM_VOLATILE_P (mem_rtx) = 1;                         /* Do not optimize in flow analysis */    
+
+      if (prologue)
+      {
+        insn = emit_move_insn (mem_rtx, reg_rtx);
+        RTX_FRAME_RELATED_P (insn) = 1;
+      }
+      else if (regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))
+      {
+        insn = emit_move_insn (reg_rtx, mem_rtx);
+        REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL_RTX);
+      }
+      
+      gp_offset += GET_MODE_SIZE (gpr_mode);
+    }
+  }
+
+  if (interrupt_handler && prologue) {
+    emit_move_insn (isr_reg_rtx, isr_msr_rtx);
+    emit_move_insn (isr_mem_rtx, isr_reg_rtx);
+
+    emit_insn (gen_rtx_USE (SImode, isr_reg_rtx));                  /* Do not optimize in flow analysis */
+    emit_insn (gen_rtx_USE (SImode, isr_msr_rtx));                  /* Do not optimize in flow analysis */
+  }
+
+  /* Done saving and restoring */
+}
+
+
+/* Set up the stack and frame (if desired) for the function.  */
+static void
+microblaze_function_prologue (
+  FILE *file,
+  int size ATTRIBUTE_UNUSED)
+{
+#ifndef FUNCTION_NAME_ALREADY_DECLARED
+  const char *fnname;
+#endif
+  long fsiz = current_frame_info.total_size;
+
+#if 0   
+  ASM_OUTPUT_SOURCE_FILENAME (file, DECL_SOURCE_FILE (current_function_decl));
+
+#ifdef SDB_DEBUGGING_INFO
+  if (debug_info_level != DINFO_LEVEL_TERSE && write_symbols == SDB_DEBUG)
+    microblaze_output_lineno (file, DECL_SOURCE_LINE (current_function_decl));
+#endif
+#endif
+  inside_function = 1;
+
+#ifndef FUNCTION_NAME_ALREADY_DECLARED
+  /* Get the function name the same way that toplev.c does before calling
+     assemble_start_function.  This is needed so that the name used here
+     exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */
+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+  if (!flag_inhibit_size_directive)
+  {
+    fputs ("\t.ent\t", file);
+    if (interrupt_handler && strcmp(INTERRUPT_HANDLER_NAME,fnname))  
+      fputs ("_interrupt_handler", file); 
+    else 
+      assemble_name (file, fnname); 
+    fputs ("\n", file);
+  }
+
+  assemble_name (file, fnname);
+  fputs (":\n", file);
+
+  if (interrupt_handler && strcmp (INTERRUPT_HANDLER_NAME, fnname)) 
+    fputs ("_interrupt_handler:\n",file); 
+#endif
+
+  if (!flag_inhibit_size_directive)
+  {
+    /* .frame FRAMEREG, FRAMESIZE, RETREG */
+    fprintf (file,
+             "\t.frame\t%s,%ld,%s\t\t# vars= %ld, regs= %d, args= %d\n",
+             (reg_names[(frame_pointer_needed)
+                        ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),
+             fsiz,
+             reg_names[MB_ABI_SUB_RETURN_ADDR_REGNUM + GP_REG_FIRST],
+             current_frame_info.var_size,
+             current_frame_info.num_gp,
+             current_function_outgoing_args_size);
+    fprintf (file, "\t.mask\t0x%08lx\n", current_frame_info.mask);
+  }
+}
+
+/* Output extra assembler code at the end of a prologue */
+void
+microblaze_function_end_prologue (FILE *file)
+{
+  if (TARGET_STACK_CHECK) {
+    fprintf (file, "\t# Stack Check Stub -- Start.\n\t");
+    fprintf (file, "ori\tr18,r0,_stack_end\n\t");
+    fprintf (file, "cmpu\tr18,r1,r18\n\t");
+    fprintf (file, "bgei\tr18,_stack_overflow_exit\n\t");
+    fprintf (file, "# Stack Check Stub -- End.\n");        
+  }
+}
+
+/* Expand the prologue into a bunch of separate insns.  */
+
+void
+microblaze_expand_prologue (void)
+{
+  int regno;
+  HOST_WIDE_INT fsiz;
+  const char *arg_name = 0;
+  tree fndecl = current_function_decl;
+  tree fntype = TREE_TYPE (fndecl);
+  tree fnargs = DECL_ARGUMENTS (fndecl);
+  rtx next_arg_reg;
+  int i;
+  tree next_arg;
+  tree cur_arg;
+  CUMULATIVE_ARGS args_so_far;
+#if 0
+  rtx reg_18_save = NULL_RTX;
+#endif
+  rtx mem_rtx, reg_rtx;
+
+  /* If struct value address is treated as the first argument, make it so.  */
+  if (aggregate_value_p (DECL_RESULT (fndecl), fntype)
+      && ! current_function_returns_pcc_struct)                                               
+  {
+    tree type = build_pointer_type (fntype);
+    tree function_result_decl = build_decl (PARM_DECL, NULL_TREE, type);
+
+    DECL_ARG_TYPE (function_result_decl) = type;
+    TREE_CHAIN (function_result_decl) = fnargs;
+    fnargs = function_result_decl;
+  }
+
+  /* Determine the last argument, and get its name.  */
+
+  INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, 0, 0);
+  regno = GP_ARG_FIRST;
+
+  for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)
+  {
+    tree passed_type = DECL_ARG_TYPE (cur_arg);
+    enum machine_mode passed_mode = TYPE_MODE (passed_type);
+    rtx entry_parm;
+
+    if (TREE_ADDRESSABLE (passed_type))
+    {
+      passed_type = build_pointer_type (passed_type);
+      passed_mode = Pmode;
+    }
+
+    entry_parm = FUNCTION_ARG (args_so_far, passed_mode, passed_type, 1);
+
+    if (entry_parm)
+    {
+      int words;
+
+      /* passed in a register, so will get homed automatically */
+      if (GET_MODE (entry_parm) == BLKmode)
+        words = (int_size_in_bytes (passed_type) + 3) / 4;
+      else
+        words = (GET_MODE_SIZE (GET_MODE (entry_parm)) + 3) / 4;
+
+      regno = REGNO (entry_parm) + words - 1;
+    }
+    else
+    {
+      regno = GP_ARG_LAST+1;
+      break;
+    }
+
+    FUNCTION_ARG_ADVANCE (args_so_far, passed_mode, passed_type, 1);
+
+    next_arg = TREE_CHAIN (cur_arg);
+    if (next_arg == 0)
+    {
+      if (DECL_NAME (cur_arg))
+        arg_name = IDENTIFIER_POINTER (DECL_NAME (cur_arg));
+
+      break;
+    }
+  }
+
+  /* In order to pass small structures by value in registers compatibly with
+     the MicroBlaze compiler, we need to shift the value into the high part of the
+     register.  Function_arg has encoded a PARALLEL rtx, holding a vector of
+     adjustments to be made as the next_arg_reg variable, so we split up the
+     insns, and emit them separately.  */
+
+  /* IN MicroBlaze shift has been modified to be a combination of adds
+     and shifts in other directions, Hence we need to change the code
+     a bit */
+
+  next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);
+  if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)
+  {
+    rtvec adjust = XVEC (next_arg_reg, 0);
+    int num = GET_NUM_ELEM (adjust);
+
+    for (i = 0; i < num; i++)
+    {
+      rtx pattern = RTVEC_ELT (adjust, i);
+      /* 	  if (GET_CODE (pattern) != SET */
+      /* 	      || GET_CODE (SET_SRC (pattern)) != ASHIFT) */
+      /* 	    fatal_insn ("Insn is not a shift", pattern); */
+      /* 	  if (GET_CODE (pattern) != SET )
+                  fatal_insn ("Insn is Not Set", pattern); */
+
+      /*	  PUT_CODE (SET_SRC (pattern), ASHIFTRT);*/
+      emit_insn (pattern);
+    }
+  }
+
+  fsiz = compute_frame_size (get_frame_size ());
+
+  /* If this function is a varargs function, store any registers that
+     would normally hold arguments ($5 - $10) on the stack.  */
+  if (((TYPE_ARG_TYPES (fntype) != 0
+        && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+            != void_type_node))
+       || (arg_name != 0
+           && ((arg_name[0] == '_'
+                && strcmp (arg_name, "__builtin_va_alist") == 0)
+               || (arg_name[0] == 'v'
+                   && strcmp (arg_name, "va_alist") == 0)))))
+  {
+    int offset = (regno - GP_ARG_FIRST + 1) * UNITS_PER_WORD;
+    rtx ptr = stack_pointer_rtx;
+
+    /* If we are doing svr4-abi, sp has already been decremented by fsiz. */
+    for (; regno <= GP_ARG_LAST; regno++)
+    {
+      if (offset != 0)
+        ptr = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));
+      emit_move_insn (gen_rtx_MEM (gpr_mode, ptr),
+                      gen_rtx_REG (gpr_mode, regno));
+         
+      offset += GET_MODE_SIZE (gpr_mode);
+    }
+      
+  }
+  
+  if (fsiz > 0)
+  {
+    rtx fsiz_rtx = GEN_INT (fsiz);
+
+    rtx insn = NULL;
+    insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,
+                                  fsiz_rtx));
+    if (insn)
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+    /* Handle SUB_RETURN_ADDR_REGNUM specially at first */
+    if (!current_function_is_leaf || interrupt_handler) {
+      mem_rtx = gen_rtx_MEM (gpr_mode,
+                         gen_rtx_PLUS (Pmode, stack_pointer_rtx, const0_rtx));
+      
+      if (interrupt_handler)
+        MEM_VOLATILE_P (mem_rtx) = 1;                     /* Do not optimize in flow analysis */
+    
+      reg_rtx = gen_rtx_REG (gpr_mode, MB_ABI_SUB_RETURN_ADDR_REGNUM);
+      insn = emit_move_insn (mem_rtx, reg_rtx);
+      RTX_FRAME_RELATED_P (insn) = 1;
+     }
+
+    save_restore_insns (1);                             /* _save_ registers for prologue */
+  
+    if (frame_pointer_needed)
+    {
+      rtx insn = 0;
+
+      insn = emit_insn (gen_movsi (hard_frame_pointer_rtx,
+                                   stack_pointer_rtx));
+      
+      if (insn)
+        RTX_FRAME_RELATED_P (insn) = 1;
+    }
+
+  }
+
+  /* If we are profiling, make sure no instructions are scheduled before
+     the call to mcount.  */
+  /* profile_block_flag killed in GCC 3.4.1 */
+   
+  /*   if (profile_flag || profile_block_flag)*/
+  if (profile_flag)
+    emit_insn (gen_blockage ());
+
+  /* [02/01/02] This section checks the stack at runtime to see if it
+     has passed the malloc_base_Addr */
+
+  /*  GCC 3.4.1
+   *  This does not work reliably. Instruction scheduling seems intent on 
+   *  killing the stack check insns and later complains about deleting
+   *  frame related stuff. Doing the stack check in function_end_prologue instead.
+   */ 
+  /* 
+     if (TARGET_STACK_CHECK){
+     rtx insn;
+     insn = emit_insn (gen_stack_check ());
+     emit_insn (gen_blockage ());
+     }
+  */
+}
+
+
+
+/* Do any necessary cleanup after a function to restore stack, frame,
+   and regs. */
+
+#define RA_MASK ((long) 0x80000000)	/* 1 << 31 */
+#define PIC_OFFSET_TABLE_MASK (1 << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))
+
+void
+microblaze_function_epilogue (
+  FILE *file ATTRIBUTE_UNUSED,
+  HOST_WIDE_INT size ATTRIBUTE_UNUSED)
+{
+  const char *fnname;
+
+#ifndef FUNCTION_NAME_ALREADY_DECLARED
+  /* Get the function name the same way that toplev.c does before calling
+     assemble_start_function.  This is needed so that the name used here
+     exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */
+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+
+  if (!flag_inhibit_size_directive)
+  {
+    fputs ("\t.end\t", file);
+    if (interrupt_handler)
+      fputs("_interrupt_handler",file);
+    else
+      assemble_name (file, fnname);
+    fputs ("\n", file);
+  }
+#endif
+
+  if (TARGET_STATS)
+  {
+    int num_gp_regs = current_frame_info.gp_reg_size / 4;
+    int num_regs = num_gp_regs;
+    const char *name = fnname;
+      
+    if (name[0] == '*')
+      name++;
+      
+    dslots_load_total += num_regs;
+      
+    fprintf (stderr,
+             "%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3d reg=%2d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d",
+             name, frame_pointer_needed ? 'y' : 'n',
+             (current_frame_info.mask & RA_MASK) != 0 ? 'n' : 'y',
+             current_function_calls_alloca ? 'y' : 'n',
+             current_function_calls_setjmp ? 'y' : 'n',
+             current_frame_info.total_size,
+             current_function_outgoing_args_size, num_gp_regs,
+             dslots_load_total, dslots_load_filled,
+             dslots_jump_total, dslots_jump_filled,
+             num_refs[0], num_refs[1], num_refs[2]);
+
+    if (HALF_PIC_NUMBER_PTRS > prev_half_pic_ptrs)
+    {
+      fprintf (stderr,
+               " half-pic=%3d", HALF_PIC_NUMBER_PTRS - prev_half_pic_ptrs);
+      prev_half_pic_ptrs = HALF_PIC_NUMBER_PTRS;
+    }
+
+    if (HALF_PIC_NUMBER_REFS > prev_half_pic_refs)
+    {
+      fprintf (stderr,
+               " pic-ref=%3d", HALF_PIC_NUMBER_REFS - prev_half_pic_refs);
+      prev_half_pic_refs = HALF_PIC_NUMBER_REFS;
+    }
+
+    fputc ('\n', stderr);
+  }
+
+  /* Reset state info for each function.  */
+  inside_function = 0;
+  ignore_line_number = 0;
+  dslots_load_total = 0;
+  dslots_jump_total = 0;
+  dslots_load_filled = 0;
+  dslots_jump_filled = 0;
+  num_refs[0] = 0;
+  num_refs[1] = 0;
+  num_refs[2] = 0;
+  microblaze_load_reg = 0;
+  microblaze_load_reg2 = 0;
+  current_frame_info = zero_frame_info;
+
+  while (string_constants != NULL)
+  {
+    struct string_constant *next;
+
+    next = string_constants->next;
+    free (string_constants);
+    string_constants = next;
+  }
+
+  /* Restore the output file if optimizing the GP (optimizing the GP causes
+     the text to be diverted to a tempfile, so that data decls come before
+     references to the data).  */
+}
+
+/* Expand the epilogue into a bunch of separate insns.  */
+
+void
+microblaze_expand_epilogue (void)
+{
+  HOST_WIDE_INT fsiz = current_frame_info.total_size;
+  rtx fsiz_rtx = GEN_INT (fsiz);
+  rtx reg_rtx;
+  rtx mem_rtx;
+  
+#if 0
+  char *fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+#endif
+    
+  /* In case of interrupt handlers use addki instead of addi for changing the stack pointer value */
+  
+  if (microblaze_can_use_return_insn ())
+  {
+    emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,
+                                                  GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)));
+    return;
+  }
+
+  if (fsiz > 0)
+  {
+    /* Restore SUB_RETURN_ADDR_REGNUM at first. This is to prevent the sequence of load-followed by a use (in rtsd) 
+       in every prologue. Saves a load-use stall cycle  :) 
+       This is also important to handle alloca. (See comments for if (frame_pointer_needed) below */
+
+    if (!current_function_is_leaf || interrupt_handler) {
+      mem_rtx = gen_rtx_MEM (gpr_mode, gen_rtx_PLUS (Pmode, stack_pointer_rtx, const0_rtx));
+      if (interrupt_handler)
+        MEM_VOLATILE_P (mem_rtx) = 1;                       /* Do not optimize in flow analysis */
+      reg_rtx = gen_rtx_REG (gpr_mode, MB_ABI_SUB_RETURN_ADDR_REGNUM);
+      emit_move_insn (reg_rtx, mem_rtx);
+    }
+
+    /* It is important that this is done after we restore the return address register (above).
+       When alloca is used, we want to restore the sub-routine return address only from the current
+       stack top and not from the frame pointer (which we restore below). (frame_pointer + 0) might have
+       been over-written since alloca allocates memory on the current stack */
+    if (frame_pointer_needed)
+      emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));
+    
+    save_restore_insns (0);                             /* _restore_ registers for epilogue */
+    emit_insn (gen_blockage ());
+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, fsiz_rtx));
+  }
+
+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)));
+}
+
+
+/* Return nonzero if this function is known to have a null epilogue.
+   This allows the optimizer to omit jumps to jumps if no stack
+   was created.  */
+
+int
+microblaze_can_use_return_insn (void)
+{
+  if (! reload_completed)
+    return 0;
+
+  if (regs_ever_live[MB_ABI_SUB_RETURN_ADDR_REGNUM] || profile_flag)
+    return 0;
+
+  if (current_frame_info.initialized)
+    return current_frame_info.total_size == 0;
+
+  return compute_frame_size (get_frame_size ()) == 0;
+}
+
+/* This function returns the register class required for a secondary
+   register when copying between one of the registers in CLASS, and X,
+   using MODE.  If IN_P is nonzero, the copy is going from X to the
+   register, otherwise the register is the source.  A return value of
+   NO_REGS means that no secondary register is required.  */
+
+enum reg_class
+microblaze_secondary_reload_class (
+  enum reg_class class,
+  enum machine_mode mode ATTRIBUTE_UNUSED,
+  rtx x,
+  int in_p)
+{
+  enum reg_class gr_regs = GR_REGS;
+  int regno = -1;
+  int gp_reg_p;
+
+  if (GET_CODE (x) == SIGN_EXTEND)
+  {
+    int off = 0;
+
+    x = XEXP (x, 0);
+
+    /* We may be called with reg_renumber NULL from regclass.
+       ??? This is probably a bug.  */
+    if (reg_renumber)
+      regno = true_regnum (x);
+    else
+    {
+      while (GET_CODE (x) == SUBREG)
+      {
+#ifdef MJE_SUBREG_REG
+        off += SUBREG_REG (x);
+#endif
+        x = SUBREG_REG (x);
+      }
+
+      if (GET_CODE (x) == REG)
+        regno = REGNO (x) + off;
+    }
+  }
+
+  else if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)
+    regno = true_regnum (x);
+
+  gp_reg_p = GP_REG_P (regno);
+
+  if (MD_REG_P (regno))
+  {
+    return class == gr_regs ? NO_REGS : gr_regs;
+  }
+
+  /* We can only copy a value to a condition code register from a
+     floating point register, and even then we require a scratch
+     floating point register.  We can only copy a value out of a
+     condition code register into a general register.  */
+  if (class == ST_REGS)
+  {
+    if (in_p)
+      return FP_REGS;
+    return GP_REG_P (regno) ? NO_REGS : GR_REGS;
+  }
+  if (ST_REG_P (regno))
+  {
+    if (! in_p)
+      return FP_REGS;
+    return class == GR_REGS ? NO_REGS : GR_REGS;
+  }
+
+  return NO_REGS;
+}
+
+
+/* We keep a list of constants we which we have to add to internal
+   constant tables in the middle of large functions.  */
+
+struct constant
+{
+  struct constant *next;
+  rtx value;
+  rtx label;
+  enum machine_mode mode;
+};
+
+/* Add a constant to the list in *PCONSTANTS.  */
+
+static rtx
+add_constant (
+  struct constant **pconstants,
+  rtx val,
+  enum machine_mode mode)
+{
+  struct constant *c;
+
+  for (c = *pconstants; c != NULL; c = c->next)
+    if (mode == c->mode && rtx_equal_p (val, c->value))
+      return c->label;
+
+  c = (struct constant *) xmalloc (sizeof *c);
+  c->value = val;
+  c->mode = mode;
+  c->label = gen_label_rtx ();
+  c->next = *pconstants;
+  *pconstants = c;
+  return c->label;
+}
+
+
+/* Exported to toplev.c.
+   Do a final pass over the function, just before delayed branch scheduling.  */
+void
+machine_dependent_reorg (void)
+{
+  return;
+
+}
+
+/* Get the base register for accessing a value from the memory or
+   Symbol ref. Used for Microblaze Small Data Area Pointer Optimization */
+
+int
+get_base_reg(rtx x)
+{
+  int base_reg = (flag_pic ? 
+                  MB_ABI_PIC_ADDR_REGNUM : 
+                  MB_ABI_BASE_REGNUM );
+  
+  if (TARGET_XLGP_OPT){
+    if (VAR_SECTION(x) ==  SDATA_VAR || VAR_SECTION(x) ==  SBSS_VAR )
+      base_reg = MB_ABI_GPRW_REGNUM ;
+    else if (VAR_SECTION(x) ==  SDATA2_VAR)
+      base_reg = MB_ABI_GPRO_REGNUM ;
+  }
+
+  return base_reg;
+}
+
+#define SIZE_FMT 70
+
+
+char *
+format_load_store (char* ls_fmt, 
+                   enum load_store ls_type, 
+                   enum machine_mode ls_mode,
+                   rtx operand,
+                   int offset)
+{
+
+  int base_reg = 0;
+  int i;
+  const char* ld_mode_text,*st_mode_text;
+  rtx temp;
+
+  /*  if(ls_fmt) free(ls_fmt);*/
+  ls_fmt = (char*)xmalloc(SIZE_FMT);
+  for(i = 0 ;i < SIZE_FMT; i++) ls_fmt[i] = 0;
+  /* certain operands are mem */
+  while (GET_CODE(operand)== MEM)
+    operand = XEXP (operand, 0);
+  /* set the mode_text */
+  switch(ls_mode){
+    case SImode:
+    case SFmode: 
+      st_mode_text="w";
+      ld_mode_text="w";
+      break;
+    case HImode: 
+      st_mode_text="h";
+      ld_mode_text="hu";
+      break;
+    case QImode: 
+      st_mode_text="b";
+      ld_mode_text="bu";
+      break;
+    default:
+      break;
+  }
+
+
+  if (ls_type == LOAD){
+    /* Get the base register for Memory operations */  
+    if(GET_CODE(operand) != PLUS ){
+      base_reg = get_base_reg(operand);
+    }
+    switch(GET_CODE(operand)){
+      /* Assumed PLUS will always be reg + constant */ 
+      case PLUS:
+        temp = XEXP (operand, 1);
+        if(INTVAL(temp) + offset)
+          sprintf(ls_fmt,"l%si\t%%0,%%1",
+                  ld_mode_text);
+        break; 
+      case SYMBOL_REF:
+        sprintf(ls_fmt,"l%si\t%%0,%%1",
+                ld_mode_text);
+      
+        break;
+      case CONST:
+      case CONST_INT:
+        sprintf(ls_fmt,"l%si\t%%0,%%1",
+                ld_mode_text);
+        break; 
+      case REG:
+          sprintf(ls_fmt,"l%si\t%%0,%%1",
+                  ld_mode_text);
+        break; 
+      default:
+        fprintf(stderr,"Error!! unknown block move %d\n",GET_CODE(operand));
+        return "MicroBlaze Code error here %0 %1 LOAD";
+    } /* operands1 switch */
+    return ls_fmt;
+  }
+  else
+  {
+    /* Get the base register for Memory operations */  
+    if(GET_CODE(operand) != PLUS)
+      base_reg = get_base_reg(operand);
+
+    switch(GET_CODE(operand)){
+      /* Assumed PLUS will always be reg + constant */ 
+      case PLUS:
+        temp = XEXP (operand, 1);
+        if(INTVAL(temp) + offset)
+          sprintf(ls_fmt,"s%si\t%%0,%%1",
+                  st_mode_text);
+        break;
+         
+      case SYMBOL_REF:
+        sprintf(ls_fmt,"s%si\t%%0,%%1",
+                st_mode_text);        
+        break;
+         
+      case CONST:
+      case CONST_INT:
+        sprintf(ls_fmt,"s%si\t%%0,%%1",
+                st_mode_text);
+        break;    
+      case REG:
+        sprintf(ls_fmt,"s%si\t%%0,%%1",
+                st_mode_text);
+        break;
+      default:
+        fprintf(stderr,"Error!! unknown block move %d\n",GET_CODE(operand));
+        return "MicroBlaze Code error here %0 %1 STORE";
+    } /* operands0 switch */
+    return ls_fmt;
+      
+  } /* store part*/
+}
+
+
+/* Added to handle Xilinx interrupt handler for MicroBlaze */
+
+int
+microblaze_valid_machine_decl_attribute (
+  tree decl,
+  tree attributes ATTRIBUTE_UNUSED,
+  tree attr,
+  tree args)
+{
+  if (args != NULL_TREE)
+    return 0;
+
+  if (is_attribute_p ("interrupt_handler", attr) ||
+      is_attribute_p ("save_volatiles", attr)){
+    /*    fprintf(stderr,"INTERRUPT HANDLER RECOGNIZED\n");*/
+    return TREE_CODE (decl) == FUNCTION_DECL;
+  }
+ 
+  return 0;
+}
+
+/* Return nonzero if FUNC is an interrupt function as specified
+   by the "interrupt" attribute.  */
+
+/* Xilinx
+ * Eventually remove both the functions below 
+ */
+static int
+microblaze_interrupt_function_p (tree func)
+{
+  tree a;
+
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return 0;
+
+  a = lookup_attribute ("interrupt_handler", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+static int
+microblaze_save_volatiles (tree func)
+{
+  tree a;
+
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return 0;
+
+  a = lookup_attribute ("save_volatiles", DECL_ATTRIBUTES (func)); 
+  return a != NULL_TREE;
+}
+
+int microblaze_is_interrupt_handler(void){
+  return interrupt_handler;
+}
+
+static void
+microblaze_globalize_label (
+  FILE *stream,
+  const char *name)
+{									
+  fputs ("\t.globl\t", stream);					
+  if (interrupt_handler && strcmp (name, INTERRUPT_HANDLER_NAME)){      
+    fputs (INTERRUPT_HANDLER_NAME, stream);                          
+    fputs ("\n\t.globl\t", stream);                                  
+  }									
+  assemble_name (stream, name);					
+  fputs ("\n", stream);						
+} 
+
+
+
+/* Choose the section to use for the constant rtx expression X that has
+   mode MODE.  */
+
+/* This macro is not defined any more. The constants will be moved to
+   Readonly section */
+void
+microblaze_select_rtx_section (
+  enum machine_mode mode ATTRIBUTE_UNUSED,
+  rtx x ATTRIBUTE_UNUSED,
+  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  READONLY_DATA_SECTION ();
+}
+
+/* Choose the section to use for DECL.  RELOC is true if its value contains
+   any relocatable expression.
+
+   Some of the logic used here needs to be replicated in
+   ENCODE_SECTION_INFO in microblaze.h so that references to these symbols
+   are done correctly.  Specifically, at least all symbols assigned
+   here to rom (.text and/or .rodata) must not be referenced via
+   ENCODE_SECTION_INFO with %gprel, as the rom might be too far away.
+
+   If you need to make a change here, you probably should check
+   ENCODE_SECTION_INFO to see if it needs a similar change.  */
+
+void
+microblaze_select_section (
+  tree decl,
+  int reloc,
+  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  int size = int_size_in_bytes (TREE_TYPE (decl));
+
+
+  /* 
+     if (DECL_NAME (decl))
+     fprintf (stderr, "microblaze_select_section: %s: \n", IDENTIFIER_POINTER (DECL_NAME (decl)));   
+  */
+    
+
+  /* 07/23/01 XLNX : Set the section to be either .data or .sdata */
+
+  /*  rtx decl_rtx = XEXP(DECL_RTL(decl),0);
+  
+  if (TREE_CODE(decl) != STRING_CST)
+  if (!(TREE_READONLY(decl)))
+  VAR_SECTION(decl_rtx)= (size <=microblaze_section_threshold && size > 0 && TARGET_XLGP_OPT) ? SDATA_VAR : DATA_VAR;
+  */
+  
+  if ((TARGET_EMBEDDED_PIC)
+      && TREE_CODE (decl) == STRING_CST)
+    /* For embedded position independent code, put constant strings in the
+       text section, because the data section is limited to 64K in size.
+    */
+    text_section ();
+
+  /* For embedded applications, always put an object in read-only data
+     if possible, in order to reduce RAM usage.  */
+
+  if (((TREE_CODE (decl) == VAR_DECL
+        && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl)
+        && DECL_INITIAL (decl)
+        && (DECL_INITIAL (decl) == error_mark_node
+            || TREE_CONSTANT (DECL_INITIAL (decl))))
+       /* Deal with calls from output_constant_def_contents.  */
+       || (TREE_CODE (decl) != VAR_DECL
+           && (TREE_CODE (decl) != STRING_CST)))
+      && ! (flag_pic && reloc)){
+    if(size > 0 && size <= microblaze_section_threshold && TARGET_XLGP_OPT)
+      READONLY_SDATA_SECTION ();
+    else
+      READONLY_DATA_SECTION ();
+  }
+  else if (size > 0 && size <= microblaze_section_threshold && TARGET_XLGP_OPT)
+    SDATA_SECTION ();
+  else
+    data_section ();
+}
+
+
+
+static void
+microblaze_unique_section (
+  tree decl,
+  int reloc)
+{
+
+  int len, size, sec;
+  const char *name, *prefix;
+  char *string;
+  const char *prefixes[4][2] = {
+    { ".text.", ".gnu.linkonce.t." },
+    { ".rodata.", ".gnu.linkonce.r." },
+    { ".data.", ".gnu.linkonce.d." },
+    { ".sdata.", ".gnu.linkonce.s." }
+  };
+    
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+  size = int_size_in_bytes (TREE_TYPE (decl));
+
+  /* Determine the base section we are interested in:
+     0=text, 1=rodata, 2=data, 3=sdata.  */
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    sec = 0;
+  else if ((TARGET_EMBEDDED_PIC)
+           && TREE_CODE (decl) == STRING_CST)
+  {
+    /* For embedded position independent code, put constant strings
+       in the text section, because the data section is limited to
+       64K in size.  For microblaze16 code, put strings in the text
+       section so that a PC relative load instruction can be used to
+       get their address.  */
+    sec = 0;
+  }
+  else
+  {
+    /* For hosted applications, always put an object in small data if
+       possible, as this gives the best performance.  */
+
+    if (size > 0 && size <= microblaze_section_threshold)
+      sec = 3;
+    else if (decl_readonly_section (decl, reloc))
+      sec = 1;
+    else
+      sec = 2;
+  }
+
+  prefix = prefixes[sec][DECL_ONE_ONLY (decl)];
+  len = strlen (name) + strlen (prefix);
+  /*  len =  strlen (prefix);                         */
+  string = alloca (len + 1);
+  sprintf (string, "%s%s", prefix, name);
+  DECL_SECTION_NAME(decl) = build_string(len,string);
+  /*  sprintf (string, "%s", prefix);                           */
+  /*  DECL_SECTION_NAME(DECL) = build_string(len,string);*/
+}
+
+
+
+/* GCC 3.4.1
+ * Re-write this. Can use default_encode_section_info. Refer to rs6000/mips.
+ */
+
+static void
+microblaze_encode_section_info (
+  tree DECL,
+  rtx rtl,
+  int new_decl_p ATTRIBUTE_UNUSED)
+{
+   
+  if (TARGET_EMBEDDED_PIC)					
+  {									
+    if (TREE_CODE (DECL) == VAR_DECL)				
+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;		
+    else if (TREE_CODE (DECL) == FUNCTION_DECL)			
+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 0;		
+    else if (TREE_CODE (DECL) == STRING_CST)
+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 0;		
+    else								
+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;		
+  }									
+									
+  else if (TREE_CODE (DECL) == VAR_DECL				
+           && DECL_SECTION_NAME (DECL) != NULL_TREE                   
+           && (0 == strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (DECL)), 
+                            ".sdata")                                 
+               || 0 == strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (DECL)),
+                               ".sbss")))                                
+  {									
+    SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;		
+  }									
+									
+  /* We can not perform GP optimizations on variables which are in	
+     specific sections, except for .sdata and .sbss which are		
+     handled above.  */						
+  else if (TARGET_GP_OPT && TREE_CODE (DECL) == VAR_DECL		
+           && DECL_SECTION_NAME (DECL) == NULL_TREE)			
+  {									
+    int size = int_size_in_bytes (TREE_TYPE (DECL));		
+    if (size > 0 && size <= microblaze_section_threshold)		
+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;		
+  }									
+									
+  else if (HALF_PIC_P ())						
+  {									
+    HALF_PIC_ENCODE (DECL);						
+  }					
+				
+  /* XLNX[07.24.01] */						        
+  /*Added for setting the var_section in different cases */       	        
+  {  								
+    int size = int_size_in_bytes (TREE_TYPE (DECL));                    
+    int small_size = (size > 0 && size <= microblaze_section_threshold   
+                      && TARGET_XLGP_OPT) ? 1 : 0;      	        
+    int read_only = (TREE_READONLY (DECL)) ;                             
+                                                                        
+    if ((TREE_CODE (DECL)) == VAR_DECL) {                            
+      int init_val = (DECL_INITIAL (DECL) == NULL) ? 0 : 1;              
+      int init_val_override = init_val ? (!initializer_zerop (DECL_INITIAL (DECL))): 1;
+      int value = (small_size & init_val_override) | (read_only << 1) | (init_val << 2);       
+            
+      if (DECL_EXTERNAL (DECL))                                            
+        VAR_SECTION (XEXP (rtl,0)) = DATA_VAR;                 
+      else {
+        if (init_val)          
+          VAR_SECTION (XEXP (rtl,0)) = value;                  
+        else                                                             
+          VAR_SECTION (XEXP (rtl,0)) = (value % 2) + 1;        
+      }
+            
+      /* 
+         if (DECL_NAME (DECL))
+         fprintf (stderr, "microblaze_encode_section_info: %s. size: %d, init_val: %d, read_only: %d, VAR_SECTION: %d\n", 
+         IDENTIFIER_POINTER (DECL_NAME (DECL)), size, init_val, read_only, VAR_SECTION (XEXP (rtl, 0)));
+      */
+            
+    }                                                                   
+    else if ((TREE_CODE (DECL)) == STRING_CST){                         
+      if ((XEXP (rtl, 0)) != NULL) {                      
+        if (TREE_STRING_LENGTH (DECL) <= microblaze_section_threshold) {     
+          VAR_SECTION (XEXP (rtl,0)) = SDATA2_VAR;   
+        }     
+        else {                                                              
+          VAR_SECTION (XEXP (rtl,0)) = RODATA_VAR;    
+        }    
+      } else {
+        fprintf(stderr,"Some Problem with the string\n");
+      }          
+    }									
+  }									
+}
+
+
+/* Determine of register must be saved/restored in call. */
+static int
+microblaze_must_save_register (int regno)
+{
+  if (regs_ever_live[regno] && !call_used_regs[regno]) return 1;
+
+  if (frame_pointer_needed && 
+      (regno == HARD_FRAME_POINTER_REGNUM)) return 1;
+
+  if (!current_function_is_leaf)
+  {
+      if (regno == MB_ABI_SUB_RETURN_ADDR_REGNUM) return 1;
+      if ((interrupt_handler || save_volatiles) &&
+          (regno >= 3 && regno <= 12)) return 1;
+  }
+
+  if (interrupt_handler) 
+  {
+    if ((regs_ever_live[regno]) ||
+        (regno == MB_ABI_MSR_SAVE_REG) ||
+        (regno == MB_ABI_ASM_TEMP_REGNUM) ||
+        (regno == MB_ABI_EXCEPTION_RETURN_ADDR_REGNUM))
+       return 1;
+  }
+
+  if (save_volatiles) 
+  {
+    if ((regs_ever_live[regno]) ||
+        (regno == MB_ABI_ASM_TEMP_REGNUM) ||
+        (regno == MB_ABI_EXCEPTION_RETURN_ADDR_REGNUM))
+       return 1;
+  }
+
+  return 0;
+}
diff --git a/gcc/config/microblaze/microblaze.h b/gcc/config/microblaze/microblaze.h
index 396306e..5f2153f 100644
--- a/gcc/config/microblaze/microblaze.h
+++ b/gcc/config/microblaze/microblaze.h
@@ -647,6 +647,9 @@ while (0)
 #define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)
 #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)
 
+/* Use DWARF 2 debugging information by default.  */
+#define DWARF2_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
 
 /* /\* Overrides for the COFF debug format.  *\/ */
 /* #define PUT_SDB_SCL(a)					\ */
@@ -1684,6 +1687,8 @@ extern struct microblaze_frame_info current_frame_info;
 /* Old Code */		     
 /*#define FIRST_PARM_OFFSET(FNDECL) (((current_function_is_leaf == 0 ? 1 : 0)  * (UNITS_PER_WORD)))   */
 
+/* Offset from the argument pointer register value to the top of stack.  */
+#define ARG_POINTER_CFA_OFFSET(FNDECL) 0
 
 /* When a parameter is passed in a register, stack space is still
    allocated for it.  For the MICROBLAZE, stack space must be allocated 
@@ -2895,84 +2900,18 @@ do {									\
 /*   Changed the way the string is to be printed in the assembly file. It
      will output .data8 words instead of .ascii and the string
 */
+#if TARGET_MICROBLAZE_ASM
 #define ASM_OUTPUT_ASCII(STREAM, STRING, LEN)				\
 do {									\
-if(TARGET_MICROBLAZE_ASM){                                                    \
   register int i, c, len = (LEN) ;  				        \
   register unsigned char *string = (unsigned char *)(STRING);		\
   for (i = 0; i < len; i++)						\
        fprintf((STREAM),".data8 %d\n",string[i]);			\
   }                                                                     \
- else /* If not MICROBLAZE_ASM print ascii */                                 \
-  {/* Original code for ASM_OUTPUT_ASCII */                             \
-  register int i, c, len = (LEN), cur_pos = 17;				\
-  register unsigned char *string = (unsigned char *)(STRING);		\
-  fprintf ((STREAM), "\t.ascii\t\"");					\
-  for (i = 0; i < len; i++)						\
-    {									\
-      register int c = string[i];					\
-									\
-      switch (c)							\
-	{								\
-	case '\"':							\
-	case '\\':							\
-	  putc ('\\', (STREAM));					\
-	  putc (c, (STREAM));						\
-	  cur_pos += 2;							\
-	  break;							\
-									\
-	case '\n':						\
-	  fputs ("\\n", (STREAM));					\
-	  if (i+1 < len							\
-	      && (((c = string[i+1]) >= '\040' && c <= '~')		\
-		  || c == '\t'))					\
-	    cur_pos = 32767;		/* break right here */		\
-	  else								\
-	    cur_pos += 2;						\
-	  break;							\
-									\
-	case '\t':						\
-	  fputs ("\\t", (STREAM));					\
-	  cur_pos += 2;							\
-	  break;							\
-									\
-	case '\f':							\
-	  fputs ("\\f", (STREAM));					\
-	  cur_pos += 2;							\
-	  break;							\
-									\
-	case '\b':							\
-	  fputs ("\\b", (STREAM));					\
-	  cur_pos += 2;							\
-	  break;							\
-									\
-	case '\r':							\
-	  fputs ("\\r", (STREAM));					\
-	  cur_pos += 2;							\
-	  break;							\
-									\
-	default:							\
-	  if (c >= ' ' && c < 0177)					\
-	    {								\
-	      putc (c, (STREAM));					\
-	      cur_pos++;						\
-	    }								\
-	  else								\
-	    {								\
-	      fprintf ((STREAM), "\\%03o", c);				\
-	      cur_pos += 4;						\
-	    }								\
-	}								\
-									\
-      if (cur_pos > 72 && i+1 < len)					\
-	{								\
-	  cur_pos = 17;							\
-	  fprintf ((STREAM), "\"\n\t.ascii\t\"");			\
-	}								\
-    }									\
-   fprintf ((STREAM), "\"\n");						\
-  } 								        \
 } while (0)
+#else
+#define ASM_OUTPUT_ASCII(STREAM, STRING, LEN) output_ascii(STREAM,STRING,LEN)
+#endif
 
 /* Handle certain cpp directives used in header files on sysV.  */
 /* GCC 3.4.1 - Poisoned */
diff --git a/gcc/config/microblaze/microblaze.h.orig b/gcc/config/microblaze/microblaze.h.orig
new file mode 100644
index 0000000..396306e
--- /dev/null
+++ b/gcc/config/microblaze/microblaze.h.orig
@@ -0,0 +1,3345 @@
+/* Definitions of target machine for GNU compiler.  MicroBlaze version.
+   Copyright (C) 1989, 90-98, 1999 Free Software Foundation, Inc.
+   This file is part of GNU CC.
+
+   GNU CC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU CC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU CC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ * 
+ * microblaze.h
+ * 
+ * MicroBlaze specific file. Contains functions for generating MicroBlaze code. 
+ * Certain lines of code are from Free Software Foundation
+ * 
+ * $Header: /devl/xcs/repo/env/Jobs/MDT/sw/ThirdParty/gnu/src/gcc/src-3.4/gcc/config/microblaze/microblaze.h,v 1.14.2.15 2006/05/22 15:25:28 vasanth Exp $
+ * 
+ */
+
+/* Standard GCC variables that we reference.  */
+
+/* MICROBLAZE external variables defined in microblaze.c.  */
+
+/* comparison type */
+enum cmp_type {
+    CMP_SI,				/* compare four byte integers */
+    CMP_DI,				/* compare eight byte integers */
+    CMP_SF,				/* compare single precision floats */
+    CMP_DF,				/* compare double precision floats */
+    CMP_MAX				/* max comparison type */
+};
+
+/* types of delay slot */
+enum delay_type {
+    DELAY_NONE,				/* no delay slot */
+    DELAY_LOAD,				/* load from memory delay */
+    DELAY_HILO,				/* move from/to hi/lo registers */
+    DELAY_FCMP				/* delay after doing c.<xx>.{d,s} */
+};
+
+/* Which pipeline to schedule for. */
+enum pipeline_type {
+  MICROBLAZE_PIPE_3 = 0,
+  MICROBLAZE_PIPE_5 = 1
+};
+
+
+
+
+/* Which ABI to use.  */
+
+#define ABI_32  0
+
+#define microblaze_abi ABI_32
+
+/* Whether to emit abicalls code sequences or not.  */
+
+enum microblaze_abicalls_type {
+    MICROBLAZE_ABICALLS_NO,
+    MICROBLAZE_ABICALLS_YES
+};
+
+/* Recast the abicalls class to be the abicalls attribute.  */
+#define microblaze_abicalls_attr ((enum attr_abicalls)microblaze_abicalls)
+
+/* Which type of block move to do (whether or not the last store is
+   split out so it can fill a branch delay slot).  */
+
+enum block_move_type {
+    BLOCK_MOVE_NORMAL,			/* generate complete block move */
+    BLOCK_MOVE_NOT_LAST,			/* generate all but last store */
+    BLOCK_MOVE_LAST			/* generate just the last store */
+};
+
+/* microblaze_cpu_select contains CPU info */
+struct microblaze_cpu_select
+{
+    const char *cpu;
+    const char *tune;
+    unsigned int flags;
+};
+
+#define MICROBLAZE_MASK_NO_UNSAFE_DELAY         0x00000001
+
+extern char microblaze_reg_names[][8];          /* register names (a0 vs. $4). */
+extern char microblaze_print_operand_punct[];	/* print_operand punctuation chars */
+extern const char *current_function_file;       /* filename current function is in */
+extern int num_source_filenames;                /* current .file # */
+extern int inside_function;                     /* != 0 if inside of a function */
+extern int ignore_line_number;                  /* != 0 if we are to ignore next .loc */
+extern int file_in_function_warning;            /* warning given about .file in func */
+extern int sdb_label_count;                     /* block start/end next label # */
+extern int sdb_begin_function_line;             /* Starting Line of current function */
+extern int microblaze_section_threshold;	/* # bytes of data/sdata cutoff */
+/* extern unsigned int g_switch_value;             /\* value of the -G xx switch *\/ */
+/* extern int g_switch_set;                        /\* whether -G xx was passed.  *\/ */
+extern int sym_lineno;                          /* sgi next label # for each stmt */
+extern int set_noreorder;                       /* # of nested .set noreorder's  */
+extern int set_nomacro;                         /* # of nested .set nomacro's  */
+extern int set_noat;                            /* # of nested .set noat's  */
+extern int set_volatile;                        /* # of nested .set volatile's  */
+extern int microblaze_dbx_regno[];		/* Map register # to debug register # */
+extern struct rtx_def *branch_cmp[2];           /* operands for compare */
+extern enum microblaze_abicalls_type microblaze_abicalls;/* for svr4 abi pic calls */
+extern int microblaze_isa;			/* architectural level */
+extern int dslots_load_total;                   /* total # load related delay slots */
+extern int dslots_load_filled;                  /* # filled load delay slots */
+extern int dslots_jump_total;                   /* total # jump related delay slots */
+extern int dslots_jump_filled;                  /* # filled jump delay slots */
+extern int dslots_number_nops;                  /* # of nops needed by previous insn */
+extern int num_refs[3];                         /* # 1/2/3 word references */
+extern struct rtx_def *microblaze_load_reg;	/* register to check for load delay */
+extern struct rtx_def *microblaze_load_reg2;	/* 2nd reg to check for load delay */
+extern struct rtx_def *microblaze_load_reg3;	/* 3rd reg to check for load delay */
+extern struct rtx_def *microblaze_load_reg4;	/* 4th reg to check for load delay */
+extern struct rtx_def *embedded_pic_fnaddr_rtx;	/* function address */
+extern const char       *asm_file_name;
+extern char             call_used_regs[];
+extern int              current_function_calls_alloca;
+extern char             *language_string;
+extern int              may_call_alloca;
+extern int              target_flags;
+extern struct microblaze_cpu_select 
+                        microblaze_select;
+extern int microblaze_no_unsafe_delay;
+extern enum pipeline_type microblaze_pipe;
+extern enum cmp_type branch_type;
+extern char *microblaze_no_clearbss;
+
+/*extern char    *version_string;*/
+
+/* Functions within microblaze.c that we reference.  Some of these return
+   type HOST_WIDE_INT, so define that here.  */
+
+#include "hwint.h"
+
+/* This is the only format we support */
+#define OBJECT_FORMAT_ELF
+
+
+/* Stubs for half-pic support if not OSF/1 reference platform.  */
+
+#ifndef HALF_PIC_P
+#define HALF_PIC_P() 0
+#define HALF_PIC_NUMBER_PTRS 0
+#define HALF_PIC_NUMBER_REFS 0
+#define HALF_PIC_ENCODE(DECL)
+#define HALF_PIC_DECLARE(NAME)
+#define HALF_PIC_INIT()	error ("half-pic init called on systems that don't support it.")
+#define HALF_PIC_ADDRESS_P(X) 0
+#define HALF_PIC_PTR(X) X
+#define HALF_PIC_FINISH(STREAM)
+#endif
+
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+/* Macros used in the machine description to test the flags.  */
+#define TARGET_UNIX_ASM		0
+#define TARGET_MICROBLAZE_AS		TARGET_UNIX_ASM
+/*#define TARGET_MICROBLAZE_ASM         (target_flags & MASK_LCC_ASM)  */
+#define TARGET_MICROBLAZE_ASM   0
+
+#define TARGET_GP_OPT            0       /* Vasanth: Cleanup */
+
+/* Optimize for Sdata/Sbss */
+#define TARGET_XLGP_OPT		(target_flags & MASK_XLGPOPT)
+
+/* This is true if we must enable the assembly language file switching
+   code.  */
+#define TARGET_FILE_SWITCHING	0
+
+/* We must disable the function end stabs when doing the file switching trick,
+   because the Lscope stabs end up in the wrong place, making it impossible
+   to debug the resulting code.  */
+#define NO_DBX_FUNCTION_END TARGET_FILE_SWITCHING
+
+#if 0
+/* Added by Sid for mb-objdump problem */
+#define DBX_FUNCTION_FIRST 1
+#define DBX_BLOCKS_FUNCTION_RELATIVE 1
+#endif
+
+/* Just to preserve old code */
+#define TARGET_SINGLE_FLOAT             0
+
+/* This table intercepts weirdo options whose names would interfere
+   with normal driver conventions, and either translates them into
+   standardly-named options, or adds a 'Z' so that they can get to
+   specs processing without interference.
+
+   Do not expand a linker option to "-Xlinker -<option>", since that
+   forfeits the ability to control via spec strings later.  However,
+   as a special exception, do this translation with -filelist, because
+   otherwise the driver will think there are no input files and quit.
+   (The alternative would be to hack the driver to recognize -filelist
+   specially, but it's simpler to use the translation table.)
+
+   Note that an option name with a prefix that matches another option
+   name, that also takes an argument, needs to be modified so the
+   prefix is different, otherwise a '*' after the shorter option will
+   match with the longer one.  */
+#define TARGET_OPTION_TRANSLATE_TABLE \
+  { "-xl-mode-executable", "-Zxl-mode-executable" }, \
+  { "-xl-mode-xmdstub", "-Zxl-mode-xmdstub" },  \
+  { "-xl-mode-bootstrap", "-Zxl-mode-bootstrap" }, \
+  { "-xl-mode-novectors", "-Zxl-mode-novectors" }, \
+  { "-xl-mode-xilkernel", "-Zxl-mode-xilkernel" },  \
+  { "-xl-blazeit", "-Zxl-blazeit" },    \
+  { "-xl-no-libxil", "-Zxl-no-libxil" }
+
+
+/* Default target_flags if no switches are specified  */
+#define TARGET_DEFAULT      (MASK_SOFT_MUL | MASK_SOFT_DIV | MASK_SOFT_FLOAT)
+
+#ifndef TARGET_CPU_DEFAULT
+#define TARGET_CPU_DEFAULT 0
+#endif
+
+#ifndef TARGET_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN
+#endif
+
+/* What is the default setting for -mcpu= . We set it to v4.00.a even though 
+   we are actually ahead. This is safest version that has generate code compatible 
+   for the original ISA */
+#define MICROBLAZE_DEFAULT_CPU      "v4.00.a"               
+
+#define LINKER_ENDIAN_SPEC ""
+
+
+/* Macros to decide whether certain features are available or not,
+   depending on the instruction set architecture level.  */
+
+#define HAVE_SQRT_P()		0
+
+/* 
+   The gen* programs link code that refers to MASK_64BIT.  They don't
+   actually use the information in target_flags; they just refer to
+   it.  */
+
+/* Switch  Recognition by gcc.c.  Add -G xx support */
+
+#ifdef SWITCH_TAKES_ARG
+#undef SWITCH_TAKES_ARG
+#endif
+
+#define SWITCH_TAKES_ARG(CHAR)						\
+  (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')
+
+/* Sometimes certain combinations of command options do not make sense
+   on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   On the MICROBLAZE, it is used to handle -G.  We also use it to set up all
+   of the tables referenced in the other macros.  */
+
+#define OVERRIDE_OPTIONS override_options ()
+
+/* Zero or more C statements that may conditionally modify two
+   variables `fixed_regs' and `call_used_regs' (both of type `char
+   []') after they have been initialized from the two preceding
+   macros.
+
+   This is necessary in case the fixed or call-clobbered registers
+   depend on target flags.
+
+   You need not define this macro if it has no work to do.
+
+   If the usage of an entire class of registers depends on the target
+   flags, you may indicate this to GCC by using this macro to modify
+   `fixed_regs' and `call_used_regs' to 1 for each of the registers in
+   the classes which should not be used by GCC.  Also define the macro
+   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a
+   letter for a class that shouldn't be used.
+
+   (However, if this class is not included in `GENERAL_REGS' and all
+   of the insn patterns whose constraints permit this class are
+   controlled by target switches, then GCC will automatically avoid
+   using these registers when the target switches are opposed to
+   them.)  */
+
+#define CONDITIONAL_REGISTER_USAGE					\
+do									\
+  {									\
+	int regno;							\
+	for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)	\
+	  fixed_regs[regno] = call_used_regs[regno] = 1;		\
+	for (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)	\
+	  fixed_regs[regno] = call_used_regs[regno] = 1;		\
+    SUBTARGET_CONDITIONAL_REGISTER_USAGE				\
+  }									\
+while (0)
+
+/* This is meant to be redefined in the host dependent files.  */
+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE
+
+/* Show we can debug even without a frame pointer.  */
+#define CAN_DEBUG_WITHOUT_FP
+
+#define DRIVER_SELF_SPECS    				\
+	"%{mxl-soft-mul:%<mno-xl-soft-mul}", 		\
+	"%{mno-xl-multiply-high:%<mxl-multiply-high}", 	\
+	"%{mno-xl-barrel-shift:%<mxl-barrel-shift}", 	\
+	"%{mno-xl-pattern-compare:%<mxl-pattern-compare}", \
+	"%{mxl-soft-div:%<mno-xl-soft-div}", 		\
+	"%{msoft-float:%<mhard-float}", 
+
+/* Tell collect what flags to pass to nm.  */
+#ifndef NM_FLAGS
+#define NM_FLAGS "-Bn"
+#endif
+
+/* Names to predefine in the preprocessor for this target machine.  */
+
+/* Target CPU builtins.  */
+#define TARGET_CPU_CPP_BUILTINS()				\
+  do								\
+    {								\
+        builtin_define ("microblaze");                          \
+        builtin_define ("_BIG_ENDIAN");                         \
+        builtin_define ("__MICROBLAZE__");                      \
+                                                                \
+        builtin_assert ("system=unix");                         \
+        builtin_assert ("system=bsd");                          \
+        builtin_assert ("cpu=microblaze");                      \
+        builtin_assert ("machine=microblaze");                  \
+} while (0)
+
+/* Assembler specs.  */
+
+/* MICROBLAZE_AS_ASM_SPEC is passed when using the MICROBLAZE assembler rather
+   than gas.  */
+
+#define MICROBLAZE_AS_ASM_SPEC "\
+%{!.s:-nocpp} %{.s: %{cpp} %{nocpp}} \
+%{pipe: %e-pipe is not supported.} \
+%{K} %(subtarget_microblaze_as_asm_spec)"
+
+/* SUBTARGET_MICROBLAZE_AS_ASM_SPEC is passed when using the MICROBLAZE assembler
+   rather than gas.  It may be overridden by subtargets.  */
+
+#ifndef SUBTARGET_MICROBLAZE_AS_ASM_SPEC
+#define SUBTARGET_MICROBLAZE_AS_ASM_SPEC "%{v}"
+#endif
+
+/* GAS_ASM_SPEC is passed when using gas, rather than the MICROBLAZE
+   assembler.  */
+
+#define GAS_ASM_SPEC "%{v}"
+
+/* TARGET_ASM_SPEC is used to select either MICROBLAZE_AS_ASM_SPEC or
+   GAS_ASM_SPEC as the default, depending upon the value of
+   TARGET_DEFAULT.  */
+
+#if ((TARGET_CPU_DEFAULT | TARGET_DEFAULT) & MASK_GAS) != 0
+/* GAS */
+
+#define TARGET_ASM_SPEC "\
+%{mmicroblaze-as: %(microblaze_as_asm_spec)} \
+%{!mmicroblaze-as: %(gas_asm_spec)}"
+
+#else /* not GAS */
+
+#define TARGET_ASM_SPEC ""
+/*#define TARGET_ASM_SPEC "\
+  %{!mgas: %(microblaze_as_asm_spec)} \
+  %{mgas: %(gas_asm_spec)}"
+*/
+#endif /* not GAS */
+
+/* SUBTARGET_ASM_OPTIMIZING_SPEC handles passing optimization options
+   to the assembler.  It may be overridden by subtargets.  */
+#ifndef SUBTARGET_ASM_OPTIMIZING_SPEC
+#define SUBTARGET_ASM_OPTIMIZING_SPEC " "
+#endif
+
+/* SUBTARGET_ASM_DEBUGGING_SPEC handles passing debugging options to
+   the assembler.  It may be overridden by subtargets.  */
+#ifndef SUBTARGET_ASM_DEBUGGING_SPEC
+#define SUBTARGET_ASM_DEBUGGING_SPEC "\
+%{g} %{g0} %{g1} %{g2} %{g3} \
+%{ggdb:-g} %{ggdb0:-g0} %{ggdb1:-g1} %{ggdb2:-g2} %{ggdb3:-g3} \
+%{gstabs:-g} %{gstabs0:-g0} %{gstabs1:-g1} %{gstabs2:-g2} %{gstabs3:-g3} \
+%{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3}"
+/* Old Specs */
+/*#define SUBTARGET_ASM_DEBUGGING_SPEC "\
+  %{g} %{g0} %{g1} %{g2} %{g3} \
+  %{ggdb:-g} %{ggdb0:-g0} %{ggdb1:-g1} %{ggdb2:-g2} %{ggdb3:-g3} \
+  %{gstabs:-g} %{gstabs0:-g0} %{gstabs1:-g1} %{gstabs2:-g2} %{gstabs3:-g3} \
+  %{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3} \
+  %{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3}"
+*/
+#endif
+
+
+/* SUBTARGET_ASM_SPEC is always passed to the assembler.  It may be
+   overridden by subtargets.  */
+
+#ifndef SUBTARGET_ASM_SPEC
+#define SUBTARGET_ASM_SPEC ""
+#endif
+
+/* ASM_SPEC is the set of arguments to pass to the assembler.  */
+
+#define ASM_SPEC "\
+%{microblaze1} \
+%(target_asm_spec) \
+%(subtarget_asm_spec)"
+
+/* old asm spec */
+/*#define ASM_SPEC "\
+  %{G*} %{EB} %{EL} %{microblaze1} \
+  %{membedded-pic} \
+  %(target_asm_spec) \
+  %(subtarget_asm_spec)"
+*/
+
+/* Specify to run a post-processor, microblaze-tfile after the assembler
+   has run to stuff the microblaze debug information into the object file.
+   This is needed because the $#!%^ MICROBLAZE assembler provides no way
+   of specifying such information in the assembly file.  If we are
+   cross compiling, disable microblaze-tfile unless the user specifies
+   -mmicroblaze-tfile.  */
+
+#ifndef ASM_FINAL_SPEC
+#define ASM_FINAL_SPEC ""
+#endif	/* ASM_FINAL_SPEC */
+
+/* Extra switches sometimes passed to the linker.  */
+/* ??? The bestGnum will never be passed to the linker, because the gcc driver
+   will interpret it as a -b option.  */
+
+#ifndef LINK_SPEC
+/*#define LINK_SPEC "\
+  %{G*} %{EB} %{EL} \
+  %{bestGnum} %{shared} %{non_shared} \
+  %(linker_endian_spec) -relax -N \
+  %{intrusive-debug:-defsym _TEXT_START_ADDR=0x400}"
+*/
+#define LINK_SPEC "-relax -N %{Zxl-mode-xmdstub:-defsym _TEXT_START_ADDR=0x800}"
+#endif	/* LINK_SPEC defined */
+
+/* Specs for the compiler proper */
+
+/* SUBTARGET_CC1_SPEC is passed to the compiler proper.  It may be
+   overridden by subtargets.  */
+#ifndef SUBTARGET_CC1_SPEC
+#define SUBTARGET_CC1_SPEC ""
+#endif
+
+/* CC1_SPEC is the set of arguments to pass to the compiler proper.  */
+
+#ifndef CC1_SPEC
+#define CC1_SPEC " \
+%{G*} %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \
+%{save-temps: } \
+%(subtarget_cc1_spec) \
+%{Zxl-blazeit: -mno-xl-soft-mul -mno-xl-soft-div -mxl-barrel-shift \
+-mxl-pattern-compare -mxl-multiply-high} \
+"
+#endif
+
+/* Preprocessor specs.  */
+
+/* SUBTARGET_CPP_SIZE_SPEC defines SIZE_TYPE and PTRDIFF_TYPE.  It may
+   be overridden by subtargets.  */
+/* GCC 3.4.1 
+ * Removed
+ */
+
+#ifndef SUBTARGET_CPP_SIZE_SPEC
+#define SUBTARGET_CPP_SIZE_SPEC "-D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int"
+/*#define SUBTARGET_CPP_SIZE_SPEC ""*/
+#endif
+
+
+/* SUBTARGET_CPP_SPEC is passed to the preprocessor.  It may be
+   overridden by subtargets.  */
+#ifndef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC ""
+#endif
+
+/* CPP_SPEC is the set of arguments to pass to the preprocessor.  */
+
+#ifndef CPP_SPEC
+#define CPP_SPEC "\
+%{.S:	-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \
+%{.s:	-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \
+%{!.S: %{!.s: %{!.cc: %{!.cxx: %{!.C: %{!.m: -D__LANGUAGE_C -D_LANGUAGE_C %{!ansi:-DLANGUAGE_C}}}}}}} \
+%{mno-xl-soft-mul: -DHAVE_HW_MUL}       	\
+%{mxl-multiply-high: -DHAVE_HW_MUL_HIGH}    	\
+%{mno-xl-soft-div: -DHAVE_HW_DIV}       	\
+%{mxl-barrel-shift: -DHAVE_HW_BSHIFT}   	\
+%{mxl-pattern-compare: -DHAVE_HW_PCMP}  	\
+%{mhard-float: -DHAVE_HW_FPU}           	\
+%{mxl-float-convert: -DHAVE_HW_FPU_CONVERT} \
+%{mxl-float-sqrt: -DHAVE_HW_FPU_SQRT}   \
+"
+#endif
+
+/* This macro defines names of additional specifications to put in the specs
+   that can be used in various specifications like CC1_SPEC.  Its definition
+   is an initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   specification name, and a string constant that used by the GNU CC driver
+   program.
+
+   Do not define this macro if it does not need to do anything.  */
+
+#define EXTRA_SPECS							\
+  { "subtarget_cc1_spec", SUBTARGET_CC1_SPEC },				\
+  { "subtarget_cpp_spec", SUBTARGET_CPP_SPEC },				\
+  { "subtarget_cpp_size_spec", SUBTARGET_CPP_SIZE_SPEC },		\
+  { "microblaze_as_asm_spec", MICROBLAZE_AS_ASM_SPEC },				\
+  { "gas_asm_spec", GAS_ASM_SPEC },					\
+  { "target_asm_spec", TARGET_ASM_SPEC },				\
+  { "subtarget_microblaze_as_asm_spec", SUBTARGET_MICROBLAZE_AS_ASM_SPEC }, 	\
+  { "subtarget_asm_optimizing_spec", SUBTARGET_ASM_OPTIMIZING_SPEC },	\
+  { "subtarget_asm_debugging_spec", SUBTARGET_ASM_DEBUGGING_SPEC },	\
+  { "subtarget_asm_spec", SUBTARGET_ASM_SPEC },				\
+  { "linker_endian_spec", LINKER_ENDIAN_SPEC },				\
+  SUBTARGET_EXTRA_SPECS
+
+/* If defined, this macro is an additional prefix to try after
+   `STANDARD_EXEC_PREFIX'.  */
+
+#ifndef MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX "/usr/lib/cmplrs/cc/"
+#endif
+
+#ifndef MD_STARTFILE_PREFIX
+/*#define MD_STARTFILE_PREFIX "/usr/lib/cmplrs/cc/"*/
+#define MD_STARTFILE_PREFIX "/home/sid/comp/tests/gcctest/"
+#endif
+
+
+/* Print subsidiary information on the compiler version in use.  */
+#define MICROBLAZE_VERSION MICROBLAZE_DEFAULT_CPU
+
+#ifndef MACHINE_TYPE
+#define MACHINE_TYPE "MicroBlaze/ELF"
+#endif
+
+#ifndef TARGET_VERSION_INTERNAL
+#define TARGET_VERSION_INTERNAL(STREAM)					\
+  fprintf (STREAM, " %s %s", MACHINE_TYPE, MICROBLAZE_VERSION)
+#endif
+
+#ifndef TARGET_VERSION
+#define TARGET_VERSION TARGET_VERSION_INTERNAL (stderr)
+#endif
+
+
+/* If we are passing smuggling stabs through the MICROBLAZE ECOFF object
+   format, put a comment in front of the .stab<x> operation so
+   that the MICROBLAZE assembler does not choke.  The microblaze-tfile program
+   will correctly put the stab into the object file.  */
+
+#define ASM_STABS_OP	".stabs "  
+#define ASM_STABN_OP	".stabn " 
+#define ASM_STABD_OP	".stabd " 
+
+/* Local compiler-generated symbols must have a prefix that the assembler
+   understands.   By default, this is $, although some targets (e.g.,
+   NetBSD-ELF) need to override this. */
+
+#ifndef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX	"$"
+#endif
+
+/* By default on the microblaze, external symbols do not have an underscore
+   prepended, but some targets (e.g., NetBSD) require this. */
+
+#ifndef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX	""
+#endif
+
+/* fixed registers */
+#define MB_ABI_BASE_REGNUM                   0
+#define MB_ABI_STACK_POINTER_REGNUM          1
+#define MB_ABI_GPRO_REGNUM                   2
+#define MB_ABI_GPRW_REGNUM                  13
+#define MB_ABI_INTR_RETURN_ADDR_REGNUM      14
+#define MB_ABI_SUB_RETURN_ADDR_REGNUM       15
+#define MB_ABI_DEBUG_RETURN_ADDR_REGNUM     16
+#define MB_ABI_EXCEPTION_RETURN_ADDR_REGNUM 17
+#define MB_ABI_ASM_TEMP_REGNUM              18          /* This is our workhorse temporary register. We use it heavily for compares and shifts */
+#define MB_ABI_FRAME_POINTER_REGNUM         19
+#define MB_ABI_PIC_ADDR_REGNUM              20
+#define MB_ABI_PIC_FUNC_REGNUM              21
+/* volatile registers */
+#define MB_ABI_INT_RETURN_VAL_REGNUM         3
+#define MB_ABI_INT_RETURN_VAL2_REGNUM        4
+#define MB_ABI_FIRST_ARG_REGNUM              5
+#define MB_ABI_LAST_ARG_REGNUM              10
+#define MB_ABI_MAX_ARG_REGS                 (MB_ABI_LAST_ARG_REGNUM - MB_ABI_FIRST_ARG_REGNUM + 1)
+#define MB_ABI_STATIC_CHAIN_REGNUM           3
+#define MB_ABI_TEMP1_REGNUM                 11
+#define MB_ABI_TEMP2_REGNUM                 12
+#define MB_ABI_MSR_SAVE_REG                 11          /* Volatile register used to save MSR in interrupt handlers */
+
+
+/* Debug stuff */
+
+/* #define SDB_DEBUGGING_INFO		/\* generate info for microblaze-tfile *\/ */
+/* /\* Forward references to tags are allowed.  *\/ */
+/* #define SDB_ALLOW_FORWARD_REFERENCES */
+
+/* /\* Unknown tags are also allowed.  *\/ */
+/* #define SDB_ALLOW_UNKNOWN_REFERENCES */
+
+#if 0
+#define DBX_DEBUGGING_INFO		/* generate stabs (OSF/rose) */
+
+/* On Sun 4, this limit is 2048.  We use 1500 to be safe,
+   since the length can run past this up to a continuation point.  */
+#define DBX_CONTIN_LENGTH 1500
+#endif
+
+/* How to renumber registers for dbx and gdb. */
+#define DBX_REGISTER_NUMBER(REGNO) microblaze_dbx_regno[ (REGNO) ]
+
+#define DWARF2_UNWIND_INFO 0
+/* The mapping from gcc register number to DWARF 2 CFA column number.
+ */
+#define DWARF_FRAME_REGNUM(REG)				\
+  (REG == GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM ? DWARF_FRAME_RETURN_COLUMN : REG)
+
+/* The DWARF 2 CFA column which tracks the return address.  */
+#define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)
+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)
+
+
+/* /\* Overrides for the COFF debug format.  *\/ */
+/* #define PUT_SDB_SCL(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.scl\t%d;", (a));	\ */
+/* } while (0) */
+
+/* #define PUT_SDB_INT_VAL(a)				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.val\t%d;", (a));	\ */
+/* } while (0) */
+
+/* #define PUT_SDB_VAL(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fputs ("\t.val\t", asm_out_text_file);		\ */
+/*   output_addr_const (asm_out_text_file, (a));		\ */
+/*   fputc (';', asm_out_text_file);			\ */
+/* } while (0) */
+
+/* #define PUT_SDB_DEF(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t%s.def\t",		\ */
+/* 	   (TARGET_GAS) ? "" : "#");			\ */
+/*   ASM_OUTPUT_LABELREF (asm_out_text_file, a); 		\ */
+/*   fputc (';', asm_out_text_file);			\ */
+/* } while (0) */
+
+/* #define PUT_SDB_PLAIN_DEF(a)				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t%s.def\t.%s;",		\ */
+/* 	   (TARGET_GAS) ? "" : "#", (a));		\ */
+/* } while (0) */
+
+/* #define PUT_SDB_ENDEF					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.endef\n");		\ */
+/* } while (0) */
+
+/* #define PUT_SDB_TYPE(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.type\t0x%x;", (a));	\ */
+/* } while (0) */
+
+/* #define PUT_SDB_SIZE(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.size\t%d;", (a));	\ */
+/* } while (0) */
+
+/* #define PUT_SDB_DIM(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.dim\t%d;", (a));	\ */
+/* } while (0) */
+
+/* #ifndef PUT_SDB_START_DIM */
+/* #define PUT_SDB_START_DIM				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.dim\t");		\ */
+/* } while (0) */
+/* #endif */
+
+/* #ifndef PUT_SDB_NEXT_DIM */
+/* #define PUT_SDB_NEXT_DIM(a)				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "%d,", a);		\ */
+/* } while (0) */
+/* #endif */
+
+/* #ifndef PUT_SDB_LAST_DIM */
+/* #define PUT_SDB_LAST_DIM(a)				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "%d;", a);		\ */
+/* } while (0) */
+/* #endif */
+
+/* #define PUT_SDB_TAG(a)					\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file, "\t.tag\t");		\ */
+/*   ASM_OUTPUT_LABELREF (asm_out_text_file, a); 		\ */
+/*   fputc (';', asm_out_text_file);			\ */
+/* } while (0) */
+
+/* /\* For block start and end, we create labels, so that */
+/*    later we can figure out where the correct offset is. */
+/*    The normal .ent/.end serve well enough for functions, */
+/*    so those are just commented out.  *\/ */
+
+/* #define PUT_SDB_BLOCK_START(LINE)			\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file,				\ */
+/* 	   "%sLb%d:\n\t%s.begin\t%sLb%d\t%d\n",		\ */
+/* 	   LOCAL_LABEL_PREFIX,				\ */
+/* 	   sdb_label_count,				\ */
+/* 	   (TARGET_GAS) ? "" : "#",			\ */
+/* 	   LOCAL_LABEL_PREFIX,				\ */
+/* 	   sdb_label_count,				\ */
+/* 	   (LINE));					\ */
+/*   sdb_label_count++;					\ */
+/* } while (0) */
+
+/* #define PUT_SDB_BLOCK_END(LINE)				\ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   fprintf (asm_out_text_file,				\ */
+/* 	   "%sLe%d:\n\t%s.bend\t%sLe%d\t%d\n",		\ */
+/* 	   LOCAL_LABEL_PREFIX,				\ */
+/* 	   sdb_label_count,				\ */
+/* 	   (TARGET_GAS) ? "" : "#",			\ */
+/* 	   LOCAL_LABEL_PREFIX,				\ */
+/* 	   sdb_label_count,				\ */
+/* 	   (LINE));					\ */
+/*   sdb_label_count++;					\ */
+/* } while (0) */
+
+/* #define PUT_SDB_FUNCTION_START(LINE)\ */
+/* do {                                                  \ */
+/*   extern FILE *asm_out_text_file;             \ */
+/*   ASM_OUTPUT_SOURCE_LINE (asm_out_text_file, LINE + sdb_begin_function_line, 0); \ */
+/* } while (0) */
+
+/* #define PUT_SDB_FUNCTION_END(LINE)            \ */
+/* do {                                                  \ */
+/*   extern FILE *asm_out_text_file;             \ */
+/*   ASM_OUTPUT_SOURCE_LINE (asm_out_text_file, LINE + sdb_begin_function_line, 0); \ */
+/* } while (0) */
+
+/* #define PUT_SDB_EPILOGUE_END(NAME) */
+
+/* #define PUT_SDB_SRC_FILE(FILENAME) \ */
+/* do {							\ */
+/*   extern FILE *asm_out_text_file;			\ */
+/*   output_file_directive (asm_out_text_file, (FILENAME)); \ */
+/* } while (0) */
+
+/* #define SDB_GENERATE_FAKE(BUFFER, NUMBER) \ */
+/*   sprintf ((BUFFER), ".%dfake", (NUMBER)); */
+
+/* Correct the offset of automatic variables and arguments.  Note that
+   the MICROBLAZE debug format wants all automatic variables and arguments
+   to be in terms of the virtual frame pointer (stack pointer before
+   any adjustment in the function), while the MICROBLAZE linker wants
+   the frame pointer to be the stack pointer after the initial
+   adjustment.  */
+
+#define DEBUGGER_AUTO_OFFSET(X)  \
+  microblaze_debugger_offset (X, (HOST_WIDE_INT) 0)
+#define DEBUGGER_ARG_OFFSET(OFFSET, X)  \
+  microblaze_debugger_offset (X, (HOST_WIDE_INT) OFFSET)
+
+/* /\* Tell collect that the object format is ECOFF *\/ */
+/* #define OBJECT_FORMAT_COFF	/\* Object file looks like COFF *\/ */
+/* #define EXTENDED_COFF		/\* ECOFF, not normal coff *\/ */
+
+
+/* Target machine storage layout */
+
+/* Define in order to support both big and little endian float formats
+   in the same gcc binary.  */
+/*#define REAL_ARITHMETIC*/
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.
+*/
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered. */
+#define BYTES_BIG_ENDIAN 1
+
+/* Define this if most significant word of a multiword number is the lowest. */
+#define WORDS_BIG_ENDIAN 1
+
+/* Define this to set the endianness to use in libgcc2.c, which can
+   not depend on target_flags.  */
+#define LIBGCC2_WORDS_BIG_ENDIAN 1
+
+/* Number of bits in an addressable storage unit */
+#define BITS_PER_UNIT           8
+
+/* Width in bits of a "word", which is the contents of a machine register.
+   Note that this is not necessarily the width of data type `int';
+   if using 16-bit ints on a 68000, this would still be 32.
+   But on a machine with 16-bit registers, this would be 16.  */
+#define BITS_PER_WORD           32
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD          4
+#define MIN_UNITS_PER_WORD      4
+
+/* For MICROBLAZE, width of a floating point register.  */
+#define UNITS_PER_FPREG         4
+
+/* A C expression for the size in bits of the type `int' on the
+   target machine.  If you don't define this, the default is one
+   word.  */
+#define INT_TYPE_SIZE           32
+/* GCC 3.4.1 
+ * Removed the MAX_INT_TYPE_SIZE 
+ */
+/* #define MAX_INT_TYPE_SIZE 64 */
+
+/* Tell the preprocessor the maximum size of wchar_t.  */
+/* GCC 3.4.1 
+ * Removed the MAX_WCHAR_TYPE_SIZE 
+ */
+/*
+  #ifndef MAX_WCHAR_TYPE_SIZE
+  #ifndef WCHAR_TYPE_SIZE
+  #define MAX_WCHAR_TYPE_SIZE MAX_INT_TYPE_SIZE
+  #endif
+  #endif
+*/
+
+/* A C expression for the size in bits of the type `short' on the
+   target machine.  If you don't define this, the default is half a
+   word.  (If this would be less than one storage unit, it is
+   rounded up to one unit.)  */
+#define SHORT_TYPE_SIZE         16
+
+/* A C expression for the size in bits of the type `long' on the
+   target machine.  If you don't define this, the default is one
+   word.  */
+#define LONG_TYPE_SIZE          32
+
+/* A C expression for the size in bits of the type `long long' on the
+   target machine.  If you don't define this, the default is two
+   words.  */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* A C expression for the size in bits of the type `char' on the
+   target machine.  If you don't define this, the default is one
+   quarter of a word.  (If this would be less than one storage unit,
+   it is rounded up to one unit.)  */
+#define CHAR_TYPE_SIZE BITS_PER_UNIT
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine.  If you don't define this, the default is one
+   word.  */
+#define FLOAT_TYPE_SIZE         32
+
+/* A C expression for the size in bits of the type `double' on the
+   target machine.  If you don't define this, the default is two
+   words.  */
+#define DOUBLE_TYPE_SIZE        64
+
+/* A C expression for the size in bits of the type `long double' on
+   the target machine.  If you don't define this, the default is two
+   words.  */
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/* Width in bits of a pointer.
+   See also the macro `Pmode' defined below.  */
+#ifndef POINTER_SIZE
+#define POINTER_SIZE            32
+#endif
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY           32
+
+/* Allocation boundary (in *bits*) for the code of a function.  */
+#define FUNCTION_BOUNDARY       32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY    32
+
+/* Every structure's size must be a multiple of this.  */
+/* 8 is observed right on a DECstation and on riscos 4.02.  */
+#define STRUCTURE_SIZE_BOUNDARY 8
+
+/* There is no point aligning anything to a rounder boundary than this.  */
+#define BIGGEST_ALIGNMENT       32
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT        1
+
+/* Define this if you wish to imitate the way many other C compilers
+   handle alignment of bitfields and the structures that contain
+   them.
+
+   The behavior is that the type written for a bitfield (`int',
+   `short', or other integer type) imposes an alignment for the
+   entire structure, as if the structure really did contain an
+   ordinary field of that type.  In addition, the bitfield is placed
+   within the structure so that it would fit within such a field,
+   not crossing a boundary for it.
+
+   Thus, on most machines, a bitfield whose type is written as `int'
+   would not cross a four-byte boundary, and would force four-byte
+   alignment for the whole structure.  (The alignment used may not
+   be four bytes; it is controlled by the other alignment
+   parameters.)
+
+   If the macro is defined, its definition should be a C expression;
+   a nonzero value for the expression enables this behavior.  */
+
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* If defined, a C expression to compute the alignment given to a
+   constant that is being placed in memory.  CONSTANT is the constant
+   and ALIGN is the alignment that the object would ordinarily have.
+   The value of this macro is used instead of that alignment to align
+   the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   The typical use of this macro is to increase alignment for string
+   constants to be word aligned so that `strcpy' calls that copy
+   constants can be done inline.  */
+
+#define CONSTANT_ALIGNMENT(EXP, ALIGN)					\
+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)	\
+   && (ALIGN) < BITS_PER_WORD						\
+	? BITS_PER_WORD							\
+	: (ALIGN))
+
+/* If defined, a C expression to compute the alignment for a static
+   variable.  TYPE is the data type, and ALIGN is the alignment that
+   the object would ordinarily have.  The value of this macro is used
+   instead of that alignment to align the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  Another is to
+   cause character arrays to be word-aligned so that `strcpy' calls
+   that copy constants to character arrays can be done inline.  */
+
+#undef DATA_ALIGNMENT
+#define DATA_ALIGNMENT(TYPE, ALIGN)					\
+  ((((ALIGN) < BITS_PER_WORD)						\
+    && (TREE_CODE (TYPE) == ARRAY_TYPE					\
+	|| TREE_CODE (TYPE) == UNION_TYPE				\
+	|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))
+
+/* Define if operations between registers always perform the operation
+   on the full register even if a narrower mode is specified.  */
+#define WORD_REGISTER_OPERATIONS
+
+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+   will either zero-extend or sign-extend.  The value of this macro should
+   be the code that says which one of the two operations is implicitly
+   done, NIL if none.  */
+#define LOAD_EXTEND_OP(MODE)  ZERO_EXTEND
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases, 
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type.
+
+   We promote any value smaller than SImode up to SImode.  We don't
+   want to promote to DImode when in 64 bit mode, because that would
+   prevent us from using the faster SImode multiply and divide
+   instructions.  */
+
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)	\
+  if (GET_MODE_CLASS (MODE) == MODE_INT		\
+      && GET_MODE_SIZE (MODE) < 4)		\
+    (MODE) = SImode;
+
+/* Standard register usage.  */
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.
+
+   On the MicroBlaze, we have 32 integer registers */
+
+#define FIRST_PSEUDO_REGISTER 78
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.
+   does not include arg passing regs 
+*/
+
+#define FIXED_REGISTERS							\
+{									\
+  1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,			\
+  1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 				\
+}
+
+
+/* 1 for registers not available across function calls.
+   i.e. all non-volatiles are 0
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like.  */
+
+#define CALL_USED_REGISTERS						\
+{									\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
+  1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
+  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 				\
+}
+
+/* Internal macros to classify a register number as to whether it's a
+   general purpose register, a floating point register, a
+   multiply/divide register, or a status register.  */
+
+#define GP_REG_FIRST    0
+#define GP_REG_LAST     31
+#define GP_REG_NUM      (GP_REG_LAST - GP_REG_FIRST + 1)
+#define GP_DBX_FIRST    0
+
+#define FP_REG_FIRST    32
+#define FP_REG_LAST     63 
+#define FP_REG_NUM      (FP_REG_LAST - FP_REG_FIRST + 1)
+#define FP_DBX_FIRST    ((write_symbols == DBX_DEBUG) ? 38 : 32)
+
+#define MD_REG_FIRST    64
+#define MD_REG_LAST     66
+#define MD_REG_NUM      (MD_REG_LAST - MD_REG_FIRST + 1)
+
+#define ST_REG_FIRST    67
+#define ST_REG_LAST     74
+#define ST_REG_NUM      (ST_REG_LAST - ST_REG_FIRST + 1)
+
+#define AP_REG_NUM      75
+#define RAP_REG_NUM     76
+#define FRP_REG_NUM     77
+
+#define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)
+#define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)
+#define MD_REG_P(REGNO) ((unsigned) ((REGNO) - MD_REG_FIRST) < MD_REG_NUM)
+#define ST_REG_P(REGNO) ((unsigned) ((REGNO) - ST_REG_FIRST) < ST_REG_NUM)
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.
+
+*/
+
+#define HARD_REGNO_NREGS(REGNO, MODE)					\
+  (! FP_REG_P (REGNO)							\
+	? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) \
+	: ((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG))
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode
+   MODE.  In 32 bit mode, require that DImode and DFmode be in even
+   registers.  For DImode, this makes some of the insns easier to
+   write, since you don't have to worry about a DImode value in
+   registers 3 & 4, producing a result in 4 & 5.
+   FIXME: Can we avoid restricting odd-numbered register bases for DImode and DFmode ?
+
+   To make the code simpler HARD_REGNO_MODE_OK now just references an
+   array built in override_options.  Because machmodes.h is not yet
+   included before this file is processed, the MODE bound can't be
+   expressed here.  */
+extern char microblaze_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];
+#define HARD_REGNO_MODE_OK(REGNO, MODE)					\
+            microblaze_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO)]
+
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+#define MODES_TIEABLE_P(MODE1, MODE2)					\
+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||				\
+    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)			\
+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||				\
+       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))
+
+/* MICROBLAZE pc is not overloaded on a register.	*/
+/* #define PC_REGNUM xx				*/
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM    \
+        (GP_REG_FIRST + MB_ABI_STACK_POINTER_REGNUM)
+
+/* Offset from the stack pointer to the first location for outgoing arguments. */
+#define STACK_POINTER_OFFSET    \
+        FIRST_PARM_OFFSET(FNDECL) 
+
+/* Base register for access to local variables of the function.  We
+   pretend that the frame pointer is
+   MB_ABI_INTR_RETURN_ADDR_REGNUM, and then eliminate it
+   to HARD_FRAME_POINTER_REGNUM.  We can get away with this because
+   rMB_ABI_INTR_RETUREN_ADDR_REGNUM is a fixed
+   register(return address for interrupt), and will not be used for
+   anything else.  
+   
+   [12/14/01] We need to check this out. This might be no longer true,
+   now that we have interrupt controllers working. */
+#define FRAME_POINTER_REGNUM            \
+        (FRP_REG_NUM)
+
+#define HARD_FRAME_POINTER_REGNUM       \
+        (GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM)
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms
+   may be accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c.  */
+#define FRAME_POINTER_REQUIRED          \
+        (current_function_calls_alloca)
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM              \
+        (AP_REG_NUM)
+
+/* Fake register that holds the address on the stack of the
+   current function's return address.  */
+#define RETURN_ADDRESS_POINTER_REGNUM   \
+        (RAP_REG_NUM)
+
+/* Register in which static-chain is passed to a function.  */
+#define STATIC_CHAIN_REGNUM             \
+        (GP_REG_FIRST + MB_ABI_STATIC_CHAIN_REGNUM)
+
+/* If the structure value address is passed in a register, then
+   `STRUCT_VALUE_REGNUM' should be the number of that register.  */
+/* #define STRUCT_VALUE_REGNUM (GP_REG_FIRST + 4) */
+
+/* If the structure value address is not passed in a register, define
+   `STRUCT_VALUE' as an expression returning an RTX for the place
+   where the address is passed.  If it returns 0, the address is
+   passed as an "invisible" first argument.  */
+#define STRUCT_VALUE    0
+
+/* registers used in prologue/epilogue code when the stack frame
+   is larger than 32K bytes.  These registers must come from the
+   scratch register set, and not used for passing and returning
+   arguments and any other information used in the calling sequence
+   (such as pic).  
+*/
+
+#define MICROBLAZE_TEMP1_REGNUM         \
+        (GP_REG_FIRST + MB_ABI_TEMP1_REGNUM)
+
+#define MICROBLAZE_TEMP2_REGNUM         \
+        (GP_REG_FIRST + MB_ABI_TEMP2_REGNUM)
+
+/* Define this macro if it is as good or better to call a constant
+   function address than to call an address kept in a register.  */
+#define NO_FUNCTION_CSE                 1
+
+/* The register number of the register used to address a table of
+   static data addresses in memory.  In some cases this register is
+   defined by a processor's "application binary interface" (ABI). 
+   When this macro is defined, RTL is generated for this register
+   once, as with the stack pointer and frame pointer registers.  If
+   this macro is not defined, it is up to the machine-dependent
+   files to allocate such a register (if necessary).  */
+#define PIC_OFFSET_TABLE_REGNUM         \
+        (GP_REG_FIRST + MB_ABI_PIC_ADDR_REGNUM)
+
+#define PIC_FUNCTION_ADDR_REGNUM        \
+        (GP_REG_FIRST + MB_ABI_PIC_FUNC_REGNUM)
+
+/* Initialize embedded_pic_fnaddr_rtx before RTL generation for
+   each function.  We used to do this in FINALIZE_PIC, but FINALIZE_PIC
+   isn't always called for static inline functions.  */
+#define INIT_EXPANDERS			\
+do {					\
+  embedded_pic_fnaddr_rtx = NULL;	\
+} while (0)
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+
+enum reg_class
+{
+    NO_REGS,			/* no registers in set */
+    GR_REGS,			/* integer registers */
+    FP_REGS,			/* floating point registers */
+    HI_REG,			/* hi register */
+    LO_REG,			/* lo register */
+    HILO_REG,			/* hilo register pair for 64 bit mode mult */
+    MD_REGS,			/* multiply/divide registers (hi/lo) */
+    HI_AND_GR_REGS,		/* union classes */
+    LO_AND_GR_REGS,
+    HILO_AND_GR_REGS,
+    ST_REGS,			/* status registers (fp status) */
+    ALL_REGS,			/* all registers */
+    LIM_REG_CLASSES		/* max value + 1 */
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define GENERAL_REGS GR_REGS
+
+/* An initializer containing the names of the register classes as C
+   string constants.  These names are used in writing some of the
+   debugging dumps.  */
+
+#define REG_CLASS_NAMES							\
+{									\
+  "NO_REGS",								\
+  "GR_REGS",								\
+  "FP_REGS",								\
+  "HI_REG",								\
+  "LO_REG",								\
+  "HILO_REG",								\
+  "MD_REGS",								\
+  "HI_AND_GR_REGS",							\
+  "LO_AND_GR_REGS",							\
+  "HILO_AND_GR_REGS",							\
+  "ST_REGS",								\
+  "ALL_REGS"								\
+}
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1.
+
+   When the machine has more than 32 registers, an integer does not
+   suffice.  Then the integers are replaced by sub-initializers,
+   braced groupings containing several integers.  Each
+   sub-initializer must be suitable as an initializer for the type
+   `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */
+
+#define REG_CLASS_CONTENTS						\
+{									\
+  { 0x00000000, 0x00000000, 0x00000000 },	/* no registers */	\
+  { 0xffffffff, 0x00000000, 0x00000000 },	/* integer registers */	\
+  { 0x00000000, 0xffffffff, 0x00000000 },	/* floating registers*/	\
+  { 0x00000000, 0x00000000, 0x00000001 },	/* hi register */	\
+  { 0x00000000, 0x00000000, 0x00000002 },	/* lo register */	\
+  { 0x00000000, 0x00000000, 0x00000004 },	/* hilo register */	\
+  { 0x00000000, 0x00000000, 0x00000003 },	/* mul/div registers */	\
+  { 0xffffffff, 0x00000000, 0x00000001 },	/* union classes */     \
+  { 0xffffffff, 0x00000000, 0x00000002 },				\
+  { 0xffffffff, 0x00000000, 0x00000004 },				\
+  { 0x00000000, 0x00000000, 0x000007f8 },	/* status registers */	\
+  { 0xffffffff, 0xffffffff, 0x000007ff }	/* all registers */	\
+}
+
+
+/* A C expression whose value is a register class containing hard
+   register REGNO.  In general there is more that one such class;
+   choose a class which is "minimal", meaning that no smaller class
+   also contains the register.  */
+
+extern enum reg_class microblaze_regno_to_class[];
+
+#define REGNO_REG_CLASS(REGNO) microblaze_regno_to_class[ (REGNO) ]
+
+/* A macro whose definition is the name of the class to which a
+   valid base register must belong.  A base register is one used in
+   an address which is the register value plus a displacement.  */
+
+#define BASE_REG_CLASS  GR_REGS
+
+/* A macro whose definition is the name of the class to which a
+   valid index register must belong.  An index register is one used
+   in an address where its value is either multiplied by a scale
+   factor or added to another register (as well as added to a
+   displacement).  */
+
+#define INDEX_REG_CLASS GR_REGS
+
+
+/* This macro is used later on in the file.  */
+#define GR_REG_CLASS_P(CLASS) ((CLASS) == GR_REGS)
+
+/* REG_ALLOC_ORDER is to order in which to allocate registers.  This
+   is the default value (allocate the registers in numeric order).  We
+   define it just so that we can override it if necessary in
+   ORDER_REGS_FOR_LOCAL_ALLOC.  */
+
+#define REG_ALLOC_ORDER							\
+{  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 16,	\
+  17, 18, 19, 20, 21, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 15,	\
+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,	\
+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,	\
+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75		        \
+}
+
+/* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order
+   to be rearranged based on a particular function.  
+*/
+
+#define ORDER_REGS_FOR_LOCAL_ALLOC microblaze_order_regs_for_local_alloc ()
+
+/* REGISTER AND CONSTANT CLASSES */
+
+/* Get reg_class from a letter such as appears in the machine
+   description.
+
+   DEFINED REGISTER CLASSES:
+
+   'd'  General (aka integer) registers
+   Normally this is GR_REGS
+   'y'  General registers 
+   'f'	Floating point registers
+   'h'	Hi register
+   'l'	Lo register
+   'x'	Multiply/divide registers
+   'a'	HILO_REG
+   'z'	FP Status register
+   'b'	All registers */
+
+extern enum reg_class microblaze_char_to_class[];
+
+#define REG_CLASS_FROM_LETTER(C) microblaze_char_to_class[(C)]
+
+/* The letters I, J, K, L, M, N, O, and P in a register constraint
+   string can be used to stand for particular ranges of immediate
+   operands.  This macro defines what the ranges are.  C is the
+   letter, and VALUE is a constant value.  Return 1 if VALUE is
+   in the range specified by C.  */
+
+/* 
+`I'	is used for the range of constants an arithmetic insn can
+actually contain (16 bits signed integers).
+
+`J'	is used for the range which is just zero (ie, $r0).
+
+`K'	is used for the range of constants a logical insn can actually
+contain (16 bit zero-extended integers).
+
+`L'	is used for the range of constants that be loaded with lui
+(ie, the bottom 16 bits are zero).
+
+`M'	is used for the range of constants that take two words to load
+(ie, not matched by `I', `K', and `L').
+
+`N'	is used for negative 16 bit constants other than -65536.
+
+`O'	is a 15 bit signed integer.
+
+`P'	is used for positive 16 bit constants.  */
+
+#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)
+#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)
+#define LARGE_INT(X) (((unsigned HOST_WIDE_INT) (INTVAL (X) + 0xffffffff)) \
+	== ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0xffffffff)))
+/* Test for a valid operand for a call instruction.
+   Don't allow the arg pointer register or virtual regs
+   since they may change into reg + const, which the patterns
+   can't handle yet.  */
+#define CALL_INSN_OP(X) (CONSTANT_ADDRESS_P (op)	\
+                         || (GET_CODE (op) == REG && op != arg_pointer_rtx	\
+                             && ! (REGNO (op) >= FIRST_PSEUDO_REGISTER	\
+                             && REGNO (op) <= LAST_VIRTUAL_REGISTER)))
+
+/* Deifinition of K changed for MicroBlaze specific code */
+
+#define CONST_OK_FOR_LETTER_P(VALUE, C)					\
+  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)	\
+   : (C) == 'J' ? ((VALUE) == 0)					\
+   : (C) == 'K' ? (((VALUE) >= -32768) && ((VALUE) <= 32767))           \
+   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0				\
+		   && (((VALUE) & ~2147483647) == 0			\
+		       || ((VALUE) & ~2147483647) == ~2147483647))	\
+   : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)			\
+		   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)		\
+		   && (((VALUE) & 0x0000ffff) != 0			\
+		       || (((VALUE) & ~2147483647) != 0			\
+			   && ((VALUE) & ~2147483647) != ~2147483647)))	\
+   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0xffff) < 0xffff) \
+   : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x4000) < 0x8000) \
+   : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))	\
+   : 0)
+
+/* Similar, but for floating constants, and defining letters G and H.
+   Here VALUE is the CONST_DOUBLE rtx itself.  */
+
+/* 'G'	: Floating point 0 */
+
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)				\
+  ((C) == 'G'								\
+   && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))
+
+/* Letters in the range `Q' through `U' may be defined in a
+   machine-dependent fashion to stand for arbitrary operand types. 
+   The machine description macro `EXTRA_CONSTRAINT' is passed the
+   operand as its first argument and the constraint letter as its
+   second operand.
+
+   `R'	is for memory references which take 1 word for the instruction.
+   `S'	is for references to extern items which are PIC for OSF/rose.
+   `T'	is for memory addresses that can be used to load two words.  */
+
+#define EXTRA_CONSTRAINT(OP,CODE)					\
+  (((CODE) == 'T')	  ? double_memory_operand (OP, GET_MODE (OP))	\
+   : ((CODE) == 'Q')	  ? FALSE                                       \
+   : (GET_CODE (OP) != MEM) ? FALSE					\
+   : ((CODE) == 'R')	  ? simple_memory_operand (OP, GET_MODE (OP))	\
+   : ((CODE) == 'S')	  ? (HALF_PIC_P () && CONSTANT_P (OP)		\
+			     && HALF_PIC_ADDRESS_P (OP))		\
+   : ((CODE) == 's')      ? ST_REG_P(INTVAL(OP))   			\
+   : FALSE)
+
+/* Say which of the above are memory constraints.  */
+#define EXTRA_MEMORY_CONSTRAINT(C, STR) ((C) == 'R' || (C) == 'T')
+
+/* Given an rtx X being reloaded into a reg required to be
+   in class CLASS, return the class of reg to actually use.
+   In general this is just CLASS; but on some machines
+   in some cases it is preferable to use a more restrictive class.  */
+
+#define PREFERRED_RELOAD_CLASS(X,CLASS)					\
+  ((CLASS) != ALL_REGS							\
+   ? (CLASS)							\
+   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT			\
+       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)		\
+      ? (GR_REGS)			\
+      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT			\
+	  || GET_MODE (X) == VOIDmode)					\
+	 ? (GR_REGS) : (CLASS))))
+
+/* Certain machines have the property that some registers cannot be
+   copied to some other registers without using memory.  Define this
+   macro on those machines to be a C expression that is non-zero if
+   objects of mode MODE in registers of CLASS1 can only be copied to
+   registers of class CLASS2 by storing a register of CLASS1 into
+   memory and loading that memory location into a register of CLASS2.
+
+   Do not define this macro if its value would always be zero.  */
+
+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)			\
+  ((!TARGET_DEBUG_H_MODE						\
+    && GET_MODE_CLASS (MODE) == MODE_INT				\
+    && ((CLASS1 == FP_REGS && GR_REG_CLASS_P (CLASS2))			\
+	|| (GR_REG_CLASS_P (CLASS1) && CLASS2 == FP_REGS))))
+
+/* The HI and LO registers can only be reloaded via the general
+   registers.  Condition code registers can only be loaded to the
+   general registers, and from the floating point registers.  */
+
+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)			\
+  microblaze_secondary_reload_class (CLASS, MODE, X, 1)
+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)			\
+  microblaze_secondary_reload_class (CLASS, MODE, X, 0)
+
+/* Not declared above, with the other functions, because enum
+   reg_class is not declared yet.  */
+/* enum reg_class	microblaze_secondary_reload_class ();*/
+
+/* Return the maximum number of consecutive registers
+   needed to represent mode MODE in a register of class CLASS.  */
+
+#define CLASS_UNITS(mode, size)						\
+  ((GET_MODE_SIZE (mode) + (size) - 1) / (size))
+
+#define CLASS_MAX_NREGS(CLASS, MODE)					\
+  ((CLASS) == FP_REGS							\
+   ? 2 * CLASS_UNITS (MODE, 8)					\
+   : CLASS_UNITS (MODE, UNITS_PER_WORD))
+
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+/* Changed the starting frame offset to including the new link stuff */
+#define STARTING_FRAME_OFFSET						\
+  (current_function_outgoing_args_size					\
+   +  (FIRST_PARM_OFFSET(FNDECL)))
+
+/* The return address for the current frame is in r31 is this is a leaf
+   function.  Otherwise, it is on the stack.  It is at a variable offset
+   from sp/fp/ap, so we define a fake hard register rap which is a
+   poiner to the return address on the stack.  This always gets eliminated
+   during reload to be either the frame pointer or the stack pointer plus
+   an offset.  */
+
+/* ??? This definition fails for leaf functions.  There is currently no
+   general solution for this problem.  */
+
+/* ??? There appears to be no way to get the return address of any previous
+   frame except by disassembling instructions in the prologue/epilogue.
+   So currently we support only the current frame.  */
+
+#define RETURN_ADDR_RTX(count, frame)			\
+  ((count == 0)						\
+   ? gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM))\
+   : (rtx) 0)
+
+/* Structure to be filled in by compute_frame_size with register
+   save masks, and offsets for the current function.  */
+
+    struct microblaze_frame_info
+    {
+        long total_size;		/* # bytes that the entire frame takes up */
+        long var_size;                  /* # bytes that variables take up */
+        long args_size;                 /* # bytes that outgoing arguments take up */
+        int  link_debug_size;           /* # bytes for the link reg and back pointer */
+        int  gp_reg_size;		/* # bytes needed to store gp regs */
+        long gp_offset;		        /* offset from new sp to store gp registers */
+        long mask;			/* mask of saved gp registers */
+        int  initialized;		/* != 0 if frame size already calculated */
+        int  num_gp;			/* number of gp registers saved */
+        long insns_len;                 /* length of insns */
+        int  alloc_stack;               /* Flag to indicate if the current function must not create stack space. (As an optimization) */
+    };
+
+extern struct microblaze_frame_info current_frame_info;
+
+/* If defined, this macro specifies a table of register pairs used to
+   eliminate unneeded registers that point into the stack frame.  If
+   it is not defined, the only elimination attempted by the compiler
+   is to replace references to the frame pointer with references to
+   the stack pointer.
+
+   The definition of this macro is a list of structure
+   initializations, each of which specifies an original and
+   replacement register.
+
+   On some machines, the position of the argument pointer is not
+   known until the compilation is completed.  In such a case, a
+   separate hard register must be used for the argument pointer. 
+   This register can be eliminated by replacing it with either the
+   frame pointer or the argument pointer, depending on whether or not
+   the frame pointer has been eliminated.
+
+   In this case, you might specify:
+   #define ELIMINABLE_REGS  \
+   {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+   {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+   Note that the elimination of the argument pointer with the stack
+   pointer is specified first since that is the preferred elimination.
+
+*/
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},				\
+ { ARG_POINTER_REGNUM,   GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM},				\
+ { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},		\
+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM},			\
+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM},			\
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},				\
+ { FRAME_POINTER_REGNUM, GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM}}
+
+/* A C expression that returns non-zero if the compiler is allowed to
+   try to replace register number FROM-REG with register number
+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is
+   defined, and will usually be the constant 1, since most of the
+   cases preventing register elimination are things that the compiler
+   already knows about.
+
+   We can always eliminate to the
+   frame pointer.  We can eliminate to the stack pointer unless
+   a frame pointer is needed.  
+*/
+
+#define CAN_ELIMINATE(FROM, TO)						\
+  (((FROM) == RETURN_ADDRESS_POINTER_REGNUM && (! leaf_function_p ()	\
+   || (TO == GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM && leaf_function_p)))   			\
+  || ((FROM) != RETURN_ADDRESS_POINTER_REGNUM				\
+   && ((TO) == HARD_FRAME_POINTER_REGNUM 				\
+   || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed))))
+
+
+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It
+   specifies the initial difference between the specified pair of
+   registers.  This macro must be defined if `ELIMINABLE_REGS' is
+   defined.  */
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			 \
+        (OFFSET) = microblaze_initial_elimination_offset ((FROM), (TO))
+
+/* If defined, the maximum amount of space required for outgoing
+   arguments will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue
+   should increase the stack frame size by this amount.
+
+   It is not proper to define both `PUSH_ROUNDING' and
+   `ACCUMULATE_OUTGOING_ARGS'.  */
+#define ACCUMULATE_OUTGOING_ARGS        1
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.
+
+   If `ARGS_GROW_DOWNWARD', this is the offset to the location above
+   the first argument's address.
+
+   On the MICROBLAZE, we must skip the first argument position if we are
+   returning a structure or a union, to account for its address being
+   passed in $4.  However, at the current time, this produces a compiler
+   that can't bootstrap, so comment it out for now.  */
+
+/* The first Parameter is dependent wether the
+   current_function_is_leaf and the wether in debug mode or not */
+
+/*  GCC 3.4.1 
+ *  Ideal definition is commented out below as "Old Code". Somehow, current_function_is_leaf seems to be incorrect when used in these contexts.
+ *  Hence there is a hack in compute_frame_size to identify when not to allocate stack for leaf functions.
+ */ 
+#define FIRST_PARM_OFFSET(FNDECL)       (UNITS_PER_WORD)  
+
+/* Old Code */		     
+/*#define FIRST_PARM_OFFSET(FNDECL) (((current_function_is_leaf == 0 ? 1 : 0)  * (UNITS_PER_WORD)))   */
+
+
+/* When a parameter is passed in a register, stack space is still
+   allocated for it.  For the MICROBLAZE, stack space must be allocated 
+
+   BEWARE that some space is also allocated for non existing arguments
+   in register. In case an argument list is of form GF used registers
+   are a0 (a2,a3), but we should push over a1...  */
+
+#define REG_PARM_STACK_SPACE(FNDECL)        (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD) 
+
+/* Define this if it is the responsibility of the caller to
+   allocate the area reserved for arguments passed in registers. 
+   If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect
+   of this macro is to determine whether the space is included in 
+   `current_function_outgoing_args_size'.  */
+#define OUTGOING_REG_PARM_STACK_SPACE       1
+
+/* Align stack frames on 32 bits */
+#define STACK_BOUNDARY                      32
+
+/* Make sure 4 words are always allocated on the stack.  */
+/* XLNX : Need to see if this should be changed to 6 since there are 6
+   registers for argument now */
+
+/* Added NUM_OF_ARGS to have value 6, so that atleast 6 *
+   UNITS_PER_WORD is stored for arguments */
+    
+#define NUM_OF_ARGS                         6
+
+/* A C expression that should indicate the number of bytes of its
+   own arguments that a function pops on returning, or 0
+   if the function pops no arguments and the caller must therefore
+   pop them all after the function returns.
+
+   FUNDECL is the declaration node of the function (as a tree).
+
+   FUNTYPE is a C variable whose value is a tree node that
+   describes the function in question.  Normally it is a node of
+   type `FUNCTION_TYPE' that describes the data type of the function.
+   From this it is possible to obtain the data types of the value
+   and arguments (if known).
+
+   When a call to a library function is being considered, FUNTYPE
+   will contain an identifier node for the library function.  Thus,
+   if you need to distinguish among various library functions, you
+   can do so by their names.  Note that "library function" in this
+   context means a function used to perform arithmetic, whose name
+   is known specially in the compiler and was not mentioned in the
+   C code being compiled.
+
+   STACK-SIZE is the number of bytes of arguments passed on the
+   stack.  If a variable number of bytes is passed, it is zero, and
+   argument popping will always be the responsibility of the
+   calling function.  */
+
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0
+
+
+/* Symbolic macros for the registers used to return integer and floating
+   point values.  */
+
+#define GP_RETURN (GP_REG_FIRST + MB_ABI_INT_RETURN_VAL_REGNUM)
+#define FP_RETURN (GP_RETURN)
+
+/* Symbolic macros for the first/last argument registers.  */
+
+#define GP_ARG_FIRST (GP_REG_FIRST + MB_ABI_FIRST_ARG_REGNUM)
+#define GP_ARG_LAST  (GP_REG_FIRST + MB_ABI_LAST_ARG_REGNUM)
+#define FP_ARG_FIRST (FP_REG_FIRST + 12)
+#define FP_ARG_LAST  (FP_REG_FIRST + 15)
+
+#define MAX_ARGS_IN_REGISTERS	MB_ABI_MAX_ARG_REGS
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  Because we define
+   PROMOTE_FUNCTION_RETURN, we must promote the mode just as
+   PROMOTE_MODE does.  */
+
+#define LIBCALL_VALUE(MODE)						\
+  gen_rtx_REG (								\
+	   ((GET_MODE_CLASS (MODE) != MODE_INT				\
+	     || GET_MODE_SIZE (MODE) >= 4)				\
+	    ? (MODE)							\
+	    : SImode),							\
+	   ((GET_MODE_CLASS (MODE) == MODE_FLOAT			\
+	     && (! TARGET_SINGLE_FLOAT					\
+		 || GET_MODE_SIZE (MODE) <= 4))				\
+	    ? FP_RETURN							\
+	    : GP_RETURN))
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its FUNCTION_DECL;
+   otherwise, FUNC is 0.  */
+
+#define FUNCTION_VALUE(VALTYPE, FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))
+
+
+/* 1 if N is a possible register number for a function value.
+   On the MICROBLAZE, R2 R3 and F0 F2 are the only register thus used.
+   Currently, R2 and F0 are only implemented  here (C has no complex type)  */
+
+#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN || (N) == FP_RETURN)
+
+/* 1 if N is a possible register number for function argument passing.
+   We have no FP argument registers when soft-float.  When FP registers
+   are 32 bits, we can't directly reference the odd numbered ones.  */
+
+#define FUNCTION_ARG_REGNO_P(N)					\
+  (((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST))
+
+/* A C expression which can inhibit the returning of certain function
+   values in registers, based on the type of value.  A nonzero value says
+   to return the function value in memory, just as large structures are
+   always returned.  Here TYPE will be a C expression of type
+   `tree', representing the data type of the value.
+
+   Note that values of mode `BLKmode' must be explicitly
+   handled by this macro.  Also, the option `-fpcc-struct-return'
+   takes effect regardless of this macro.  On most systems, it is
+   possible to leave the macro undefined; this causes a default
+   definition to be used, whose value is the constant 1 for BLKmode
+   values, and 0 otherwise.
+
+   GCC normally converts 1 byte structures into chars, 2 byte
+   structs into shorts, and 4 byte structs into ints, and returns
+   them this way.  Defining the following macro overrides this,
+   to give us MICROBLAZE cc compatibility.  */
+
+#define RETURN_IN_MEMORY(TYPE)	\
+  (TYPE_MODE (TYPE) == BLKmode)
+
+/* A code distinguishing the floating point format of the target
+   machine.  There are three defined values: IEEE_FLOAT_FORMAT,
+   VAX_FLOAT_FORMAT, and UNKNOWN_FLOAT_FORMAT.  */
+
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.
+
+*/
+
+typedef struct microblaze_args {
+    int gp_reg_found;		/* whether a gp register was found yet */
+    int arg_number;		/* argument number */
+    int arg_words;		/* # total words the arguments take */
+    int fp_arg_words;		/* # words for FP args (MICROBLAZE_EABI only) */
+    int last_arg_fp;		/* nonzero if last arg was FP (EABI only) */
+    int fp_code;		/* Mode of FP arguments */
+    int num_adjusts;		/* number of adjustments made */
+				/* Adjustments made to args pass in regs.  */
+				/* ??? The size is doubled to work around a 
+				   bug in the code that sets the adjustments
+				   in function_arg.  */
+    struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];
+} CUMULATIVE_ARGS;
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.
+
+*/
+
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS)		\
+  init_cumulative_args (&CUM, FNTYPE, LIBNAME)                                  
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)			\
+  function_arg_advance (&CUM, MODE, TYPE, NAMED)
+
+/* Determine where to put an argument to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+   This is null for libcalls where that information may
+   not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+   the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+   (otherwise it is an extra parameter matching an ellipsis).  */
+
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  function_arg( &CUM, MODE, TYPE, NAMED)
+
+/* Tell prologue and epilogue if register REGNO should be saved / restored.  */
+#define MUST_SAVE_REGISTER(regno) microblaze_must_save_register(regno)
+
+/* Define this macro if the mcount subroutine on your system does not need 
+   a counter variable allocated for each function. This is true for almost 
+   all modern implementations. If you define this macro, you must not use 
+   the labelno argument to FUNCTION_PROFILER. */
+
+#define NO_PROFILE_COUNTERS         1
+
+/* Output assembler code to FILE to call profiling routine '_mcount'
+   for profiling a function entry.  */
+
+#define FUNCTION_PROFILER(FILE, LABELNO) { \
+  {                                        \
+    char *fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0); \
+    fprintf (FILE, "\tbrki\tr16,_mcount\n");           \
+  }                                                    \
+ }
+
+/* Define this macro if the code for function profiling should come
+   before the function prologue.  Normally, the profiling code comes
+   after.  
+   
+   #define PROFILE_BEFORE_PROLOGUE 
+*/
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.
+   No definition is equivalent to always zero.  */
+
+#define EXIT_IGNORE_STACK 1
+
+
+/* A C statement to output, on the stream FILE, assembler code for a
+   block of data that contains the constant parts of a trampoline. 
+   This code should not include a label--the label is taken care of
+   automatically.  */
+
+#define TRAMPOLINE_TEMPLATE(STREAM)					 \
+{									 \
+  fprintf (STREAM, "\t.word\t0x03e00821\t\t# move   $1,$31\n");		\
+  fprintf (STREAM, "\t.word\t0x04110001\t\t# bgezal $0,.+8\n");		\
+  fprintf (STREAM, "\t.word\t0x00000000\t\t# nop\n");			\
+  fprintf (STREAM, "\t.word\t0x8fe30014\t\t# lw     $3,20($31)\n");	\
+  fprintf (STREAM, "\t.word\t0x8fe20018\t\t# lw     $2,24($31)\n");	\
+  fprintf (STREAM, "\t.word\t0x0060c821\t\t# move   $25,$3 (abicalls)\n"); \
+  fprintf (STREAM, "\t.word\t0x00600008\t\t# jr     $3\n");		\
+  fprintf (STREAM, "\t.word\t0x0020f821\t\t# move   $31,$1\n");		\
+  fprintf (STREAM, "\t.word\t0x00000000\t\t# <function address>\n"); \
+  fprintf (STREAM, "\t.word\t0x00000000\t\t# <static chain value>\n"); \
+}
+
+/* A C expression for the size in bytes of the trampoline, as an
+   integer.  */
+
+#define TRAMPOLINE_SIZE (32 + (8))
+
+/* Alignment required for trampolines, in bits.  */
+
+#define TRAMPOLINE_ALIGNMENT    32
+
+/* INITIALIZE_TRAMPOLINE calls this library function to flush
+   program and data caches.  */
+
+#ifndef CACHE_FLUSH_FUNC
+#define CACHE_FLUSH_FUNC "_flush_cache"
+#endif
+
+/* A C statement to initialize the variable parts of a trampoline. 
+   ADDR is an RTX for the address of the trampoline; FNADDR is an
+   RTX for the address of the nested function; STATIC_CHAIN is an
+   RTX for the static chain value that should be passed to the
+   function when it is called.  */
+
+#define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)			    \
+{									    \
+  rtx addr = ADDR;							    \
+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 32)), FUNC);   \
+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 36)), CHAIN);  \
+									    \
+  /* Flush both caches.  We need to flush the data cache in case	    \
+     the system has a write-back cache.  */				    \
+  /* ??? Should check the return value for errors.  */			    \
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, CACHE_FLUSH_FUNC),	    \
+		     0, VOIDmode, 3, addr, Pmode,			    \
+		     GEN_INT (TRAMPOLINE_SIZE), TYPE_MODE (integer_type_node),\
+		     GEN_INT (3), TYPE_MODE (integer_type_node));	    \
+}
+
+/* Addressing modes, and classification of registers for them.  */
+
+#define REGNO_OK_FOR_BASE_P(regno)   \
+  microblaze_regno_ok_for_base_p ((regno), 1)
+
+
+#define REGNO_OK_FOR_INDEX_P(regno)  \
+  microblaze_regno_ok_for_base_p ((regno), 1)
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
+   and check its validity for a certain class.
+   We have two alternate definitions for each of them.
+   The usual definition accepts all pseudo regs; the other rejects them all.
+   The symbol REG_OK_STRICT causes the latter definition to be used.
+
+   Most source files want to accept pseudo regs in the hope that
+   they will get allocated to the class that the insn wants them to be in.
+   Some source files that are used after register allocation
+   need to be strict.  */
+
+#ifndef REG_OK_STRICT
+#define REG_STRICT_FLAG         0
+#else
+#define REG_STRICT_FLAG         1
+#endif
+
+/* Nonzero if X is a hard reg that can be used as an index
+   or if it is a pseudo reg in the non-strict case.  */
+#define REG_OK_FOR_BASE_P(X)    \
+  microblaze_regno_ok_for_base_p (REGNO (X), REG_STRICT_FLAG)
+
+/* Nonzero if X is a hard reg that can be used as an index
+   or if it is a pseudo reg in the non-strict case.  */
+#define REG_OK_FOR_INDEX_P(X)   \
+  microblaze_regno_ok_for_base_p (REGNO (X), REG_STRICT_FLAG)
+
+
+/* Maximum number of registers that can appear in a valid memory address.  */
+
+#define MAX_REGS_PER_ADDRESS 2
+
+/* A C compound statement with a conditional `goto LABEL;' executed
+   if X (an RTX) is a legitimate memory address on the target
+   machine for a memory operand of mode MODE.
+
+   It usually pays to define several simpler macros to serve as
+   subroutines for this one.  Otherwise it may be too complicated
+   to understand.
+
+   This macro must exist in two variants: a strict variant and a
+   non-strict one.  The strict variant is used in the reload pass. 
+   It must be defined so that any pseudo-register that has not been
+   allocated a hard register is considered a memory reference.  In
+   contexts where some kind of register is required, a
+   pseudo-register with no hard register must be rejected.
+
+   The non-strict variant is used in other passes.  It must be
+   defined to accept all pseudo-registers in every context where
+   some kind of register is required.
+
+   Typically among the subroutines used to define
+   `GO_IF_LEGITIMATE_ADDRESS' are subroutines to check for
+   acceptable registers for various purposes (one for base
+   registers, one for index registers, and so on).  Then only these
+   subroutine macros need have two variants; the higher levels of
+   macros may be the same whether strict or not.
+
+   Normally, constant addresses which are the sum of a `symbol_ref'
+   and an integer are stored inside a `const' RTX to mark them as
+   constant.  Therefore, there is no need to recognize such sums
+   specifically as legitimate addresses.  Normally you would simply
+   recognize any `const' as legitimate.
+
+   Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle
+   constant sums that are not marked with  `const'.  It assumes
+   that a naked `plus' indicates indexing.  If so, then you *must*
+   reject such naked constant sums as illegitimate addresses, so
+   that none of them will be given to `PRINT_OPERAND_ADDRESS'.
+
+   On some machines, whether a symbolic address is legitimate
+   depends on the section that the address refers to.  On these
+   machines, define the macro `ENCODE_SECTION_INFO' to store the
+   information into the `symbol_ref', and then check for it here. 
+   When you see a `const', you will have to look inside it to find
+   the `symbol_ref' in order to determine the section.  */
+
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                     \
+{                                                                   \
+  if (microblaze_legitimate_address_p (MODE, X, REG_STRICT_FLAG))   \
+    goto ADDR;                                                      \
+}
+
+
+/* A C statement or compound statement with a conditional `goto
+   LABEL;' executed if memory address X (an RTX) can have different
+   meanings depending on the machine mode of the memory reference it
+   is used for.
+
+   Autoincrement and autodecrement addresses typically have
+   mode-dependent effects because the amount of the increment or
+   decrement is the size of the operand being addressed.  Some
+   machines have other mode-dependent addresses.  Many RISC machines
+   have no mode-dependent addresses.
+
+   You may assume that ADDR is a valid address for the machine.  */
+
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) {}
+
+#if 1
+#define GO_PRINTF(x)	trace(x, 0, 0)
+#define GO_PRINTF2(x,y)	trace(x,y, 0)
+#define GO_DEBUG_RTX(x) debug_rtx(x)
+#else
+#define GO_PRINTF(x)
+#define GO_PRINTF2(x,y)
+#define GO_DEBUG_RTX(x)
+#endif
+
+/* A C expression that is 1 if the RTX X is a constant which is a
+   valid address.  This is defined to be the same as `CONSTANT_P (X)',
+   but rejecting CONST_DOUBLE.  */
+/* When pic, we must reject addresses of the form symbol+large int.
+   This is because an instruction `sw $4,s+70000' needs to be converted
+   by the assembler to `lw $at,s($gp);sw $4,70000($at)'.  Normally the
+   assembler would use $at as a temp to load in the large offset.  In this
+   case $at is already in use.  We convert such problem addresses to
+   `la $5,s;sw $4,70000($5)' via LEGITIMIZE_ADDRESS.  */
+#define CONSTANT_ADDRESS_P(X)						\
+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF		\
+    || GET_CODE (X) == CONST_INT 		                        \
+    || (GET_CODE (X) == CONST						\
+	&& ! (flag_pic && pic_address_needs_scratch (X))))		\
+   && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))
+
+/* Define this, so that when PIC, reload won't try to reload invalid
+   addresses which require two reload registers.  */
+
+#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.
+
+   At present, GAS doesn't understand li.[sd], so don't allow it
+   to be generated at present.  Also, the MICROBLAZE assembler does not
+   grok li.d Infinity.  */
+
+#define LEGITIMATE_CONSTANT_P(X)				\
+  (GET_CODE (X) != CONST_DOUBLE					\
+    || microblaze_const_double_ok (X, GET_MODE (X)))
+
+/* Try a machine-dependent way of reloading an illegitimate address
+   operand.  If we find one, push the reload and jump to WIN.  This
+   macro is used in only one place: `find_reloads_address' in reload.c.
+
+   Implemented on microblaze by microblaze_legitimize_reload_address.  
+   Note that (X) is evaluated twice; this is safe in current usage.  */ 
+
+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)			\
+{  rtx result = microblaze_legitimize_address (X, OLDX, MODE);	\
+   if (result != NULL_RTX) {					\
+       (X) = result;						\
+       goto WIN;						\
+     }								\
+}
+
+/* Define this macro if references to a symbol must be treated
+   differently depending on something about the variable or
+   function named by the symbol (such as what section it is in).
+
+   The macro definition, if any, is executed immediately after the
+   rtl for DECL has been created and stored in `DECL_RTL (DECL)'. 
+   The value of the rtl will be a `mem' whose address is a
+   `symbol_ref'.
+
+   The usual thing for this macro to do is to a flag in the
+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified
+   name string in the `symbol_ref' (if one bit is not enough
+   information).
+
+   The best way to modify the name string is by adding text to the
+   beginning, with suitable punctuation to prevent any ambiguity. 
+   Allocate the new name in `saveable_obstack'.  You will have to
+   modify `ASM_OUTPUT_LABELREF' to remove and decode the added text
+   and output the name accordingly.
+
+   You can also check the information stored in the `symbol_ref' in
+   the definition of `GO_IF_LEGITIMATE_ADDRESS' or
+   `PRINT_OPERAND_ADDRESS'.
+
+   When optimizing for the $gp pointer, SYMBOL_REF_FLAG is set for all
+   small objects.
+
+   When generating embedded PIC code, SYMBOL_REF_FLAG is set for
+   symbols which are not in the .text section.
+
+   When not embedded PIC, if a symbol is in a
+   gp addresable section, SYMBOL_REF_FLAG is set prevent gcc from
+   splitting the reference so that gas can generate a gp relative
+   reference.
+
+   When TARGET_EMBEDDED_DATA is set, we assume that all const
+   variables will be stored in ROM, which is too far from %gp to use
+   %gprel addressing.  Note that (1) we include "extern const"
+   variables in this, which microblaze_select_section doesn't, and (2) we
+   can't always tell if they're really const (they might be const C++
+   objects with non-const constructors), so we err on the side of
+   caution and won't use %gprel anyway (otherwise we'd have to defer
+   this decision to the linker/loader).  The handling of extern consts
+   is why the DECL_INITIAL macros differ from microblaze_select_section.
+
+   If you are changing this macro, you should look at
+   microblaze_select_section and see if it needs a similar change.  */
+
+#ifndef UNIQUE_SECTION_P
+#define UNIQUE_SECTION_P(DECL) (0)
+#endif
+
+#define TREE_STRING_RTL(NODE) (STRING_CST_CHECK (NODE)->string.rtl)
+
+#define CONSTANT_POOL_BEFORE_FUNCTION TRUE
+
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.
+*/
+#define CASE_VECTOR_MODE    (SImode)
+
+/* Define as C expression which evaluates to nonzero if the tablejump
+   instruction expects the table to contain offsets from the address of the
+   table.
+   Do not define this if the table should contain absolute addresses. */
+
+/* GCC 3.4.1 
+ * Removed
+ */
+/* Specify the tree operation to be used to convert reals to integers.  */
+/* #define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR*/
+
+/* GCC 3.4.1 
+ * Removed
+ */
+/* This is the kind of divide that is easiest to do in the general case.  */
+/* #define EASY_DIV_EXPR TRUNC_DIV_EXPR*/
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#ifndef DEFAULT_SIGNED_CHAR
+#define DEFAULT_SIGNED_CHAR 1
+#endif
+
+/* Max number of bytes we can move from memory to memory
+   in one reasonably fast instruction.  */
+#define MOVE_MAX 4
+#define MAX_MOVE_MAX 8
+
+/* Define this macro as a C expression which is nonzero if
+   accessing less than a word of memory (i.e. a `char' or a
+   `short') is no faster than accessing a word of memory, i.e., if
+   such access require more than one instruction or if there is no
+   difference in cost between byte and (aligned) word loads.
+
+   On RISC machines, it tends to generate better code to define
+   this as 1, since it avoids making a QI or HI mode register.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* We assume that the store-condition-codes instructions store 0 for false
+   and some other value for true.  This is the value stored for true.  */
+
+#define STORE_FLAG_VALUE 1
+
+/* Define this if zero-extension is slow (more than one real instruction).  */
+/* removed for GCC 3.3 */
+/*#define SLOW_ZERO_EXTEND*/
+
+/* Define this to be nonzero if shift instructions ignore all but the low-order
+   few bits. */
+#define SHIFT_COUNT_TRUNCATED 1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+/* In 64 bit mode, 32 bit instructions require that register values be properly
+   sign-extended to 64 bits.  As a result, a truncate is not a no-op if it
+   converts a value >32 bits to a value <32 bits.  */
+/* ??? This results in inefficient code for 64 bit to 32 conversions.
+   Something needs to be done about this.  Perhaps not use any 32 bit
+   instructions?  Perhaps use PROMOTE_MODE?  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode. */
+
+#ifndef Pmode
+#define Pmode SImode
+#endif
+
+/* A function address in a call instruction
+   is a word address (for indexing purposes)
+   so give the MEM rtx a words's mode.  */
+
+#define FUNCTION_MODE   (SImode)
+
+/* GCC 3.4.1
+ * Removed CONST_COSTS. Find a way to get behavior back ???
+ */
+
+/* /\* A part of a C `switch' statement that describes the relative */
+/*    costs of constant RTL expressions.  It must contain `case' */
+/*    labels for expression codes `const_int', `const', `symbol_ref', */
+/*    `label_ref' and `const_double'.  Each case must ultimately reach */
+/*    a `return' statement to return the relative cost of the use of */
+/*    that kind of constant value in an expression.  The cost may */
+/*    depend on the precise value of the constant, which is available */
+/*    for examination in X. */
+
+/*    CODE is the expression code--redundant, since it can be obtained */
+/*    with `GET_CODE (X)'.  *\/ */
+
+/* #define CONST_COSTS(X,CODE,OUTER_CODE)					\ */
+/*   case CONST_INT:							\ */
+/* 	/\* Always return 0, since we don't have different sized		\ */
+/* 	   instructions, hence different costs according to Richard	\ */
+/* 	   Kenner *\/							\ */
+/* 	return 0;							\ */
+/*   case LABEL_REF:							\ */
+/*     return COSTS_N_INSNS (2);						\ */
+/* 									\ */
+/*   case CONST:								\ */
+/*     {									\ */
+/*       rtx offset = const0_rtx;						\ */
+/*       rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);	\ */
+/* 									\ */
+/*       if (GET_CODE (symref) == LABEL_REF)				\ */
+/* 	return COSTS_N_INSNS (2);					\ */
+/* 									\ */
+/*       if (GET_CODE (symref) != SYMBOL_REF)				\ */
+/* 	return COSTS_N_INSNS (4);					\ */
+/* 									\ */
+/*       /\* let's be paranoid.... *\/					\ */
+/*       if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)		\ */
+/* 	return COSTS_N_INSNS (2);					\ */
+/* 									\ */
+/*       return COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);		\ */
+/*     }									\ */
+/* 									\ */
+/*   case SYMBOL_REF:							\ */
+/*     return COSTS_N_INSNS (SYMBOL_REF_FLAG (X) ? 1 : 2);			\ */
+/* 									\ */
+/*   case CONST_DOUBLE:							\ */
+/*     {									\ */
+/*       rtx high, low;							\ */
+/*       split_double (X, &high, &low);					\ */
+/*       return COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))	\ */
+/* 			     || low == CONST0_RTX (GET_MODE (low)))	\ */
+/* 			    ? 2 : 4);					\ */
+/*     } */
+
+/* A C expression for the cost of moving data from a register in
+   class FROM to one in class TO.  The classes are expressed using
+   the enumeration values such as `GENERAL_REGS'.  A value of 2 is
+   the default; other values are interpreted relative to that.
+
+   It is not required that the cost always equal 2 when FROM is the
+   same as TO; on some machines it is expensive to move between
+   registers if they are not general registers.
+
+   If reload sees an insn consisting of a single `set' between two
+   hard registers, and if `REGISTER_MOVE_COST' applied to their
+   classes returns a value of 2, reload does not check to ensure
+   that the constraints of the insn are met.  Setting a cost of
+   other than 2 will allow reload to verify that the constraints are
+   met.  You should do this if the `movM' pattern's constraints do
+   not allow such copying. */
+
+/* SID : GCC move Initial definition was : REGISTER_MOVE_COST(FROM, TO) */
+/* Mode should alwasy be SImode */
+#define REGISTER_MOVE_COST(MODE, FROM, TO)	\
+  ( GR_REG_CLASS_P (FROM) && GR_REG_CLASS_P (TO) ? 2 \
+   : (FROM) == FP_REGS && (TO) == FP_REGS ? 2				\
+   : GR_REG_CLASS_P (FROM) && (TO) == FP_REGS ? 4			\
+   : (FROM) == FP_REGS && GR_REG_CLASS_P (TO) ? 4			\
+   : (((FROM) == HI_REG || (FROM) == LO_REG				\
+       || (FROM) == MD_REGS || (FROM) == HILO_REG)			\
+      && GR_REG_CLASS_P (TO)) ? 6		\
+   : (((TO) == HI_REG || (TO) == LO_REG					\
+       || (TO) == MD_REGS || (TO) == HILO_REG)				\
+      && GR_REG_CLASS_P (FROM)) ? 6		\
+   : (FROM) == ST_REGS && GR_REG_CLASS_P (TO) ? 4			\
+   : (FROM) == FP_REGS && (TO) == ST_REGS ? 8				\
+   : 12)
+
+#define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \
+  (4 + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))
+
+/* Define if copies to/from condition code registers should be avoided.
+
+This is needed for the MICROBLAZE because reload_outcc is not complete;
+it needs to handle cases where the source is a general or another
+condition code register.  */
+#define AVOID_CCMODE_COPIES
+
+/* A C expression for the cost of a branch instruction.  A value of
+   1 is the default; other values are interpreted relative to that.  */
+
+#define BRANCH_COST   2
+
+/* A C statement (sans semicolon) to update the integer variable COST
+   based on the relationship between INSN that is dependent on
+   DEP_INSN through the dependence LINK.  The default is to make no
+   adjustment to COST.  On the MICROBLAZE, ignore the cost of anti- and
+   output-dependencies.  */
+
+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)				\
+  if (REG_NOTE_KIND (LINK) != 0)					\
+    (COST) = 0; /* Anti or output dependence.  */
+
+
+/* If defined, a C statement to be executed just prior to the
+   output of assembler code for INSN, to modify the extracted
+   operands so they will be output differently.
+
+   Here the argument OPVEC is the vector containing the operands
+   extracted from INSN, and NOPERANDS is the number of elements of
+   the vector which contain meaningful data for this insn.  The
+   contents of this vector are what will be used to convert the
+   insn template into assembler code, so you can change the
+   assembler output by changing the contents of the vector.
+
+   We use it to check if the current insn needs a nop in front of it
+   because of load delays, and also to update the delay slot
+   statistics.  */
+
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)			\
+  final_prescan_insn (INSN, OPVEC, NOPERANDS)
+
+
+/* Control the assembler format that we output.  */
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+
+#define ASM_APP_ON " #APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+
+#define ASM_APP_OFF " #NO_APP\n"
+
+/* How to refer to registers in assembler output.
+   This sequence is indexed by compiler's hard-register-number (see above).
+
+   In order to support the two different conventions for register names,
+   we use the name of a table set up in microblaze.c, which is overwritten
+   if -mrnames is used.  */
+
+#define REGISTER_NAMES							\
+{									\
+  &microblaze_reg_names[ 0][0],						\
+  &microblaze_reg_names[ 1][0],						\
+  &microblaze_reg_names[ 2][0],						\
+  &microblaze_reg_names[ 3][0],						\
+  &microblaze_reg_names[ 4][0],						\
+  &microblaze_reg_names[ 5][0],						\
+  &microblaze_reg_names[ 6][0],						\
+  &microblaze_reg_names[ 7][0],						\
+  &microblaze_reg_names[ 8][0],						\
+  &microblaze_reg_names[ 9][0],						\
+  &microblaze_reg_names[10][0],						\
+  &microblaze_reg_names[11][0],						\
+  &microblaze_reg_names[12][0],						\
+  &microblaze_reg_names[13][0],						\
+  &microblaze_reg_names[14][0],						\
+  &microblaze_reg_names[15][0],						\
+  &microblaze_reg_names[16][0],						\
+  &microblaze_reg_names[17][0],						\
+  &microblaze_reg_names[18][0],						\
+  &microblaze_reg_names[19][0],						\
+  &microblaze_reg_names[20][0],						\
+  &microblaze_reg_names[21][0],						\
+  &microblaze_reg_names[22][0],						\
+  &microblaze_reg_names[23][0],						\
+  &microblaze_reg_names[24][0],						\
+  &microblaze_reg_names[25][0],						\
+  &microblaze_reg_names[26][0],						\
+  &microblaze_reg_names[27][0],						\
+  &microblaze_reg_names[28][0],						\
+  &microblaze_reg_names[29][0],						\
+  &microblaze_reg_names[30][0],						\
+  &microblaze_reg_names[31][0],						\
+  &microblaze_reg_names[32][0],						\
+  &microblaze_reg_names[33][0],						\
+  &microblaze_reg_names[34][0],						\
+  &microblaze_reg_names[35][0],						\
+  &microblaze_reg_names[36][0],						\
+  &microblaze_reg_names[37][0],						\
+  &microblaze_reg_names[38][0],						\
+  &microblaze_reg_names[39][0],						\
+  &microblaze_reg_names[40][0],						\
+  &microblaze_reg_names[41][0],						\
+  &microblaze_reg_names[42][0],						\
+  &microblaze_reg_names[43][0],						\
+  &microblaze_reg_names[44][0],						\
+  &microblaze_reg_names[45][0],						\
+  &microblaze_reg_names[46][0],						\
+  &microblaze_reg_names[47][0],						\
+  &microblaze_reg_names[48][0],						\
+  &microblaze_reg_names[49][0],						\
+  &microblaze_reg_names[50][0],						\
+  &microblaze_reg_names[51][0],						\
+  &microblaze_reg_names[52][0],						\
+  &microblaze_reg_names[53][0],						\
+  &microblaze_reg_names[54][0],						\
+  &microblaze_reg_names[55][0],						\
+  &microblaze_reg_names[56][0],						\
+  &microblaze_reg_names[57][0],						\
+  &microblaze_reg_names[58][0],						\
+  &microblaze_reg_names[59][0],						\
+  &microblaze_reg_names[60][0],						\
+  &microblaze_reg_names[61][0],						\
+  &microblaze_reg_names[62][0],						\
+  &microblaze_reg_names[63][0],						\
+  &microblaze_reg_names[64][0],						\
+  &microblaze_reg_names[65][0],						\
+  &microblaze_reg_names[66][0],						\
+  &microblaze_reg_names[67][0],						\
+  &microblaze_reg_names[68][0],						\
+  &microblaze_reg_names[69][0],						\
+  &microblaze_reg_names[70][0],						\
+  &microblaze_reg_names[71][0],						\
+  &microblaze_reg_names[72][0],						\
+  &microblaze_reg_names[73][0],						\
+  &microblaze_reg_names[74][0],						\
+  &microblaze_reg_names[75][0],						\
+  &microblaze_reg_names[76][0],						\
+  &microblaze_reg_names[77][0],						\
+}
+
+/* print-rtl.c can't use REGISTER_NAMES, since it depends on microblaze.c.
+   So define this for it.  */
+#define DEBUG_REGISTER_NAMES						\
+{									\
+  "$0",   "sp", "rogp",   "v0",   "v1",   "a0",   "a1",   "a2",		\
+  "a3",   "a4",   "a5",   "t0",   "t1",   "rwgp", "k0",   "k1",		\
+  "k2",   "k3",   "at",   "s0",   "s1",   "s2",   "s3",   "s4",		\
+  "s5",   "s6",   "s7",   "s8",   "s9",   "s10",  "s11",  "s12",	\
+  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",	\
+  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",	\
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",	\
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",	\
+  "hi",   "lo",   "accum","rmsr","$fcc1","$fcc2","$fcc3","$fcc4",	\
+  "$fcc5","$fcc6","$fcc7","$rap"					\
+}
+
+/* If defined, a C initializer for an array of structures
+   containing a name and a register number.  This macro defines
+   additional names for hard registers, thus allowing the `asm'
+   option in declarations to refer to registers using alternate
+   names.
+
+   We define both names for the integer registers here.  */
+
+#define ADDITIONAL_REGISTER_NAMES					\
+{									\
+  { "r0",	 0 + GP_REG_FIRST },					\
+  { "r1",	 1 + GP_REG_FIRST },					\
+  { "r2",	 2 + GP_REG_FIRST },					\
+  { "r3",	 3 + GP_REG_FIRST },					\
+  { "r4",	 4 + GP_REG_FIRST },					\
+  { "r5",	 5 + GP_REG_FIRST },					\
+  { "r6",	 6 + GP_REG_FIRST },					\
+  { "r7",	 7 + GP_REG_FIRST },					\
+  { "r8",	 8 + GP_REG_FIRST },					\
+  { "r9",	 9 + GP_REG_FIRST },					\
+  { "r10",	10 + GP_REG_FIRST },					\
+  { "r11",	11 + GP_REG_FIRST },					\
+  { "r12",	12 + GP_REG_FIRST },					\
+  { "r13",	13 + GP_REG_FIRST },					\
+  { "r14",	14 + GP_REG_FIRST },					\
+  { "r15",	15 + GP_REG_FIRST },					\
+  { "r16",	16 + GP_REG_FIRST },					\
+  { "r17",	17 + GP_REG_FIRST },					\
+  { "r18",	18 + GP_REG_FIRST },					\
+  { "r19",	19 + GP_REG_FIRST },					\
+  { "r20",	20 + GP_REG_FIRST },					\
+  { "r21",	21 + GP_REG_FIRST },					\
+  { "r22",	22 + GP_REG_FIRST },					\
+  { "r23",	23 + GP_REG_FIRST },					\
+  { "r24",	24 + GP_REG_FIRST },					\
+  { "r25",	25 + GP_REG_FIRST },					\
+  { "r26",	26 + GP_REG_FIRST },					\
+  { "r27",	27 + GP_REG_FIRST },					\
+  { "r28",	28 + GP_REG_FIRST },					\
+  { "r29",	29 + GP_REG_FIRST },					\
+  { "r30",	30 + GP_REG_FIRST },					\
+  { "r31",	31 + GP_REG_FIRST },					\
+  { "rsp",	MB_ABI_STACK_POINTER_REGNUM + GP_REG_FIRST },					\
+  { "rfp",	MB_ABI_FRAME_POINTER_REGNUM + GP_REG_FIRST },					\
+  { "at",	 MB_ABI_ASM_TEMP_REGNUM + GP_REG_FIRST },					\
+  { "rmsr",     ST_REG_FIRST}, \
+  { "rogp",	 2 + GP_REG_FIRST },					\
+  { "v0",	 3 + GP_REG_FIRST },					\
+  { "v1",	 4 + GP_REG_FIRST },					\
+  { "a0",	 5 + GP_REG_FIRST },					\
+  { "a1",	 6 + GP_REG_FIRST },					\
+  { "a2",	 7 + GP_REG_FIRST },					\
+  { "t3",	 8 + GP_REG_FIRST },					\
+  { "t4",	 9 + GP_REG_FIRST },					\
+  { "t5",	10 + GP_REG_FIRST },					\
+  { "t0",	11 + GP_REG_FIRST },					\
+  { "t1",	12 + GP_REG_FIRST },					\
+  { "rwgp",	13 + GP_REG_FIRST },					\
+  { "k0",	14 + GP_REG_FIRST },					\
+  { "k1",	15 + GP_REG_FIRST },					\
+  { "k2",	16 + GP_REG_FIRST },					\
+  { "k3",	17 + GP_REG_FIRST },					\
+  { "at",	18 + GP_REG_FIRST },					\
+  { "$fp",	19 + GP_REG_FIRST },					\
+  { "s0",	20 + GP_REG_FIRST },					\
+  { "s1",	21 + GP_REG_FIRST },					\
+  { "s2",	22 + GP_REG_FIRST },					\
+  { "s3",	23 + GP_REG_FIRST },					\
+  { "s4",	24 + GP_REG_FIRST },					\
+  { "s5",	25 + GP_REG_FIRST },					\
+  { "s6",	26 + GP_REG_FIRST },					\
+  { "s7",	27 + GP_REG_FIRST },					\
+  { "s8",	28 + GP_REG_FIRST },					\
+  { "s9",	29 + GP_REG_FIRST },					\
+  { "s10",	30 + GP_REG_FIRST },					\
+  { "s11",	31 + GP_REG_FIRST },					\
+  { "s12",	29 + GP_REG_FIRST },					\
+  { "s13",	30 + GP_REG_FIRST }					\
+}
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand X.  X is an RTL
+   expression.
+
+   CODE is a value that can be used to specify one of several ways
+   of printing the operand.  It is used when identical operands
+   must be printed differently depending on the context.  CODE
+   comes from the `%' specification that was used to request
+   printing of the operand.  If the specification was just `%DIGIT'
+   then CODE is 0; if the specification was `%LTR DIGIT' then CODE
+   is the ASCII code for LTR.
+
+   If X is a register, this macro should print the register's name.
+   The names can be found in an array `reg_names' whose type is
+   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.
+
+   When the machine description has a specification `%PUNCT' (a `%'
+   followed by a punctuation character), this macro is called with
+   a null pointer for X and the punctuation character for CODE.
+
+   See microblaze.c for the MICROBLAZE specific codes.  */
+
+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)
+
+/* A C expression which evaluates to true if CODE is a valid
+   punctuation character for use in the `PRINT_OPERAND' macro.  If
+   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no
+   punctuation characters (except for the standard one, `%') are
+   used in this way.  */
+
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) microblaze_print_operand_punct[CODE]
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand that is a memory
+   reference whose address is ADDR.  ADDR is an RTL expression.
+
+   On some machines, the syntax for a symbolic address depends on
+   the section that the address refers to.  On these machines,
+   define the macro `ENCODE_SECTION_INFO' to store the information
+   into the `symbol_ref', and then check for it here.  */
+
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)
+
+
+/* A C statement, to be executed after all slot-filler instructions
+   have been output.  If necessary, call `dbr_sequence_length' to
+   determine the number of slots filled in a sequence (zero if not
+   currently outputting a sequence), to decide how many no-ops to
+   output, or whatever.
+
+   Don't define this macro if it has nothing to do, but it is
+   helpful in reading assembly output if the extent of the delay
+   sequence is made explicit (e.g. with white space).
+
+   Note that output routines for instructions with delay slots must
+   be prepared to deal with not being output as part of a sequence
+   (i.e.  when the scheduling pass is not run, or when no slot
+   fillers could be found.)  The variable `final_sequence' is null
+   when not processing a sequence, otherwise it contains the
+   `sequence' rtx being output.  */
+
+#define DBR_OUTPUT_SEQEND(STREAM)					\
+do									\
+  {									\
+    if (set_nomacro > 0 && --set_nomacro == 0)				\
+      {}								\
+									\
+    if (set_noreorder > 0 && --set_noreorder == 0)			\
+      {}								\
+									\
+    dslots_jump_filled++;						\
+    fputs ("\n", STREAM);						\
+  }									\
+while (0)
+
+
+/* How to tell the debugger about changes of source files.  Note, the
+   microblaze ECOFF format cannot deal with changes of files inside of
+   functions, which means the output of parser generators like bison
+   is generally not debuggable without using the -l switch.  Lose,
+   lose, lose.  Silicon graphics seems to want all .file's hardwired
+   to 1.  */
+
+#ifndef SET_FILE_NUMBER
+#define SET_FILE_NUMBER() ++num_source_filenames
+#endif
+
+#define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)			\
+  microblaze_output_filename (STREAM, NAME)
+
+/* This is how to output a note the debugger telling it the line number
+   to which the following sequence of instructions corresponds.
+   Silicon graphics puts a label after each .loc.  */
+
+#ifndef LABEL_AFTER_LOC
+#define LABEL_AFTER_LOC(STREAM)
+#endif
+
+/* The MICROBLAZE implementation uses some labels for its own purpose.  The
+   following lists what labels are created, and are all formed by the
+   pattern $L[a-z].*.  The machine independent portion of GCC creates
+   labels matching:  $L[A-Z][0-9]+ and $L[0-9]+.
+
+   LM[0-9]+	Silicon Graphics/ECOFF stabs label before each stmt.
+   $Lb[0-9]+	Begin blocks for MICROBLAZE debug support
+   $Lc[0-9]+	Label for use in s<xx> operation.
+   $Le[0-9]+	End blocks for MICROBLAZE debug support
+   $Lp\..+		Half-pic labels. */
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.
+
+   If we are optimizing the gp, remember that this label has been put
+   out, so we know not to emit an .extern for it in microblaze_asm_file_end.
+   We use one of the common bits in the IDENTIFIER tree node for this,
+   since those bits seem to be unused, and we don't have any method
+   of getting the decl nodes from the name.  */
+
+#define ASM_OUTPUT_LABEL(STREAM,NAME)					\
+do {									\
+  assemble_name (STREAM, NAME);						\
+  fputs (":\n", STREAM);						\
+} while (0)
+
+
+/* This says how to define an aligned common symbol */
+#define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT)   \
+    (microblaze_declare_comm_object (STREAM, NAME, "\n\t.comm\t", ",%u,%u\n", (SIZE), (ALIGNMENT)))
+
+/* This says how to define an aligned static common symbol */
+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGNMENT)     \
+    (microblaze_declare_comm_object (STREAM, NAME, "\n\t.lcomm\t", ",%u,%u\n", (SIZE), (ALIGNMENT)))
+
+/* This says how to output an aligned BSS symbol */
+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGNMENT) \
+    asm_output_aligned_bss (STREAM, DECL, NAME, SIZE, ALIGNMENT)
+
+/* This says how to output an external.  It would be possible not to
+   output anything and let undefined symbol become external. However
+   the assembler uses length information on externals to allocate in
+   data/sdata bss/sbss, thereby saving exec time.  */
+
+#define ASM_OUTPUT_EXTERNAL(STREAM,DECL,NAME) \
+  microblaze_output_external(STREAM,DECL,NAME)
+
+/* This is how to declare a function name.  The actual work of
+   emitting the label is moved to function_prologue, so that we can
+   get the line number correctly emitted before the .ent directive,
+   and after any .file directives.
+
+   Also, switch files if we are optimizing the global pointer.  */
+
+/* Older FUNCTION_NAME macro. has been replaced by a new one for the
+   .size issue */
+#if 0 
+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)			\
+{									\
+  extern FILE *asm_out_text_file;					\
+  if (TARGET_GP_OPT )					\
+    {									\
+      STREAM = asm_out_text_file;					\
+      /* ??? text_section gets called too soon.  If the previous	\
+	 function is in a special section and we're not, we have	\
+	 to switch back to the text section.  We can't call		\
+	 text_section again as gcc thinks we're already there.  */	\
+      /* ??? See varasm.c.  There are other things that get output	\
+	 too early, like alignment (before we've switched STREAM).  */	\
+      if (DECL_SECTION_NAME (DECL) == NULL_TREE)			\
+	fprintf (STREAM, "%s\n", TEXT_SECTION_ASM_OP);			\
+    }									\
+									\
+  HALF_PIC_DECLARE (NAME);						\
+}
+#endif
+
+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)                         \
+{                                                                           \
+}
+
+
+/* This is how to store into the string LABEL
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.  */
+
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)			\
+  sprintf ((LABEL), "*%s%s%ld", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))
+
+/* This is how to output an assembler line defining a `double' constant.  */
+
+#define ASM_OUTPUT_DOUBLE(STREAM,VALUE)					\
+  microblaze_output_double (STREAM, VALUE)
+
+
+/* This is how to output an assembler line defining a `float' constant.  */
+
+#define ASM_OUTPUT_FLOAT(STREAM,VALUE)					\
+  microblaze_output_float (STREAM, VALUE)
+
+
+/* This is how to output an assembler line defining an `int' constant.  */
+
+#define ASM_OUTPUT_INT(STREAM,VALUE)					\
+do {									\
+  fprintf (STREAM, "\t.data32\t");					\
+  output_addr_const (STREAM, (VALUE));					\
+  fprintf (STREAM, "\n");						\
+} while (0)
+
+/* Likewise for 64 bit, `char' and `short' constants.  */
+
+#define ASM_OUTPUT_DOUBLE_INT(STREAM,VALUE)				\
+do {									\
+      assemble_integer (operand_subword ((VALUE), 0, 0, DImode),	\
+			UNITS_PER_WORD, 1);				\
+      assemble_integer (operand_subword ((VALUE), 1, 0, DImode),	\
+			UNITS_PER_WORD, 1);				\
+} while (0)
+
+#define ASM_OUTPUT_SHORT(STREAM,VALUE)					\
+{									\
+  fprintf (STREAM, "\t.data16\t");					\
+  output_addr_const (STREAM, (VALUE));					\
+  fprintf (STREAM, "\n");						\
+}
+
+#define ASM_OUTPUT_CHAR(STREAM,VALUE)					\
+{									\
+  fprintf (STREAM, "\t.data8\t");					\
+  output_addr_const (STREAM, (VALUE));					\
+  fprintf (STREAM, "\n");						\
+}
+
+/* This is how to output an assembler line for a numeric constant byte.  */
+
+#define ASM_OUTPUT_BYTE(STREAM,VALUE)					\
+  fprintf (STREAM, "\t.data8\t0x%x\n", (VALUE))
+
+/* This is how to output an element of a case-vector that is absolute.  */
+
+/*   Changed .word to .gpword*/
+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)				\
+  fprintf (STREAM, "\t%s\t%sL%d\n",					\
+	   ".gpword",                                                   \
+	   LOCAL_LABEL_PREFIX, VALUE)
+
+/*   Changed .word to .gpword*/
+
+/* This is how to output an element of a case-vector that is relative.
+   This is used for pc-relative code (e.g. when TARGET_ABICALLS or
+   TARGET_EMBEDDED_PIC).  */
+
+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)		\
+do {									\
+  if (TARGET_EMBEDDED_PIC)						\
+    fprintf (STREAM, "\t%s\t%sL%d-%sLS%d\n",				\
+	     ".gpword",                                                 \
+	     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);	\
+  else                                                                  \
+    fprintf (STREAM, "\t%s\t%sL%d\n",					\
+	     ".gpword",                                                 \
+	     LOCAL_LABEL_PREFIX, VALUE);				\
+} while (0)
+
+/* When generating embedded PIC code we want to put the jump
+   table in the .text section.  In all other cases, we want to put the
+   jump table in the .rdata section.  Unfortunately, we can't use
+   JUMP_TABLES_IN_TEXT_SECTION, because it is not conditional.
+   Instead, we use ASM_OUTPUT_CASE_LABEL to switch back to the .text
+   section if appropriate.  */
+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, INSN)			\
+do {									\
+  if (TARGET_EMBEDDED_PIC )                                             \
+    function_section (current_function_decl);				\
+  (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);		\
+} while (0)
+
+/* This is how to output an assembler line
+   that says to advance the location counter
+   to a multiple of 2**LOG bytes.  */
+
+#define ASM_OUTPUT_ALIGN(STREAM,LOG)					\
+  fprintf (STREAM, "\t.align\t%d\n", (LOG))
+
+/* This is how to output an assembler line to advance the location
+   counter by SIZE bytes.  */
+
+#define ASM_OUTPUT_SKIP(STREAM,SIZE)					\
+  fprintf (STREAM, "\t.space\t%u\n", (SIZE))
+
+/* This is how to output a string.  */
+/*   Changed the way the string is to be printed in the assembly file. It
+     will output .data8 words instead of .ascii and the string
+*/
+#define ASM_OUTPUT_ASCII(STREAM, STRING, LEN)				\
+do {									\
+if(TARGET_MICROBLAZE_ASM){                                                    \
+  register int i, c, len = (LEN) ;  				        \
+  register unsigned char *string = (unsigned char *)(STRING);		\
+  for (i = 0; i < len; i++)						\
+       fprintf((STREAM),".data8 %d\n",string[i]);			\
+  }                                                                     \
+ else /* If not MICROBLAZE_ASM print ascii */                                 \
+  {/* Original code for ASM_OUTPUT_ASCII */                             \
+  register int i, c, len = (LEN), cur_pos = 17;				\
+  register unsigned char *string = (unsigned char *)(STRING);		\
+  fprintf ((STREAM), "\t.ascii\t\"");					\
+  for (i = 0; i < len; i++)						\
+    {									\
+      register int c = string[i];					\
+									\
+      switch (c)							\
+	{								\
+	case '\"':							\
+	case '\\':							\
+	  putc ('\\', (STREAM));					\
+	  putc (c, (STREAM));						\
+	  cur_pos += 2;							\
+	  break;							\
+									\
+	case '\n':						\
+	  fputs ("\\n", (STREAM));					\
+	  if (i+1 < len							\
+	      && (((c = string[i+1]) >= '\040' && c <= '~')		\
+		  || c == '\t'))					\
+	    cur_pos = 32767;		/* break right here */		\
+	  else								\
+	    cur_pos += 2;						\
+	  break;							\
+									\
+	case '\t':						\
+	  fputs ("\\t", (STREAM));					\
+	  cur_pos += 2;							\
+	  break;							\
+									\
+	case '\f':							\
+	  fputs ("\\f", (STREAM));					\
+	  cur_pos += 2;							\
+	  break;							\
+									\
+	case '\b':							\
+	  fputs ("\\b", (STREAM));					\
+	  cur_pos += 2;							\
+	  break;							\
+									\
+	case '\r':							\
+	  fputs ("\\r", (STREAM));					\
+	  cur_pos += 2;							\
+	  break;							\
+									\
+	default:							\
+	  if (c >= ' ' && c < 0177)					\
+	    {								\
+	      putc (c, (STREAM));					\
+	      cur_pos++;						\
+	    }								\
+	  else								\
+	    {								\
+	      fprintf ((STREAM), "\\%03o", c);				\
+	      cur_pos += 4;						\
+	    }								\
+	}								\
+									\
+      if (cur_pos > 72 && i+1 < len)					\
+	{								\
+	  cur_pos = 17;							\
+	  fprintf ((STREAM), "\"\n\t.ascii\t\"");			\
+	}								\
+    }									\
+   fprintf ((STREAM), "\"\n");						\
+  } 								        \
+} while (0)
+
+/* Handle certain cpp directives used in header files on sysV.  */
+/* GCC 3.4.1 - Poisoned */
+/* #define SCCS_DIRECTIVE */
+
+/* Output #ident as a in the read-only data section.  */
+#define ASM_OUTPUT_IDENT(FILE, STRING)					\
+{									\
+  char *p = STRING;							\
+  int size = strlen (p) + 1;						\
+  if(size <= microblaze_section_threshold)				\
+     sdata2_section ();							\
+  else 									\
+     rodata_section ();							\
+  assemble_string (p, size);						\
+}
+
+/* Default to -G 8 */
+
+
+#ifndef MICROBLAZE_DEFAULT_GVALUE
+#define MICROBLAZE_DEFAULT_GVALUE 8
+#endif
+
+/* Given a decl node or constant node, choose the section to output it in
+   and select that section.  */
+
+/* Store in OUTPUT a string (made with alloca) containing
+   an assembler-name for a local static variable named NAME.
+   LABELNO is an integer which is different for each call.  */
+
+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)			\
+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),			\
+  sprintf ((OUTPUT), "%s.%d", (NAME), (LABELNO)))
+
+/* How to start an assembler comment.
+   The leading space is important (the microblaze native assembler requires it).  */
+
+#ifndef ASM_COMMENT_START
+#define ASM_COMMENT_START " #"
+#endif
+
+#define VAR_SECTION(RTX) ((RTX)->var_section)
+#define SHIFT_TYPE(RTX) ((RTX)->shift_type)
+
+/* Macros for microblaze-tfile.c to encapsulate stabs in ECOFF, and for
+   and microblaze-tdump.c to print them out.
+
+   These must match the corresponding definitions in gdb/microblazeread.c.
+   Unfortunately, gcc and gdb do not currently share any directories. */
+
+#define CODE_MASK 0x8F300
+#define MICROBLAZE_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)
+#define MICROBLAZE_MARK_STAB(code) ((code)+CODE_MASK)
+#define MICROBLAZE_UNMARK_STAB(code) ((code)-CODE_MASK)
+
+#undef TARGET_FP_CALL_32
+
+#define BSS_VAR         1
+#define SBSS_VAR        2
+#define DATA_VAR        4
+#define SDATA_VAR       5
+#define RODATA_VAR      6
+#define SDATA2_VAR      7
+
+/* These definitions are used in combination with the shift_type flag in the rtl */
+
+#define SHIFT_CONST     1
+#define SHIFT_REG       2
+#define USE_ADDK        3
+
+/* handle interrupt attribute */
+
+/*extern int microblaze_valid_machine_decl_attribute ();*/
+/*
+  #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \
+  microblaze_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)
+*/
+extern int interrupt_handler;
+extern int save_volatiles;
+
+/*int microblaze_is_interrupt_handler();*/
+
+/*extern int dbl_register_operand();*/
+/*extern int shiftdone;*/
+
+#define INTERRUPT_HANDLER_NAME "_interrupt_handler"
+
+/* these #define added for C++ */
+#ifdef OBJECT_FORMAT_ELF
+#define UNALIGNED_SHORT_ASM_OP          ".data16"
+#define UNALIGNED_INT_ASM_OP            ".data32"
+#define UNALIGNED_DOUBLE_INT_ASM_OP     ".data8"
+#endif /* OBJECT_FORMAT_ELF */
+
+#define ASM_BYTE_OP                     ".data8"
+
+/* the following #defines are used in the headers files. Always retain these */
+
+/* Added for declaring size at the end of the function*/
+#undef ASM_DECLARE_FUNCTION_SIZE
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do {									\
+    if (!flag_inhibit_size_directive)					\
+      {									\
+        char label[256];						\
+	static int labelno;						\
+	labelno++;							\
+	ASM_GENERATE_INTERNAL_LABEL (label, "Lfe", labelno);		\
+        (*targetm.asm_out.internal_label) (FILE, "Lfe", labelno);	\
+	fprintf (FILE, "%s", SIZE_ASM_OP);				\
+	assemble_name (FILE, (FNAME));					\
+        fprintf (FILE, ",");						\
+	assemble_name (FILE, label);					\
+        fprintf (FILE, "-");						\
+	assemble_name (FILE, (FNAME));					\
+	putc ('\n', FILE);						\
+      }									\
+  } while (0)
+
+/*  ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);*/
+#if 0 
+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)		\
+do{ \
+   if (!flag_inhibit_size_directive) \
+   { \
+      fputs ("\t.ent\t", FILE); \
+      if (interrupt_handler && strcmp(INTERRUPT_HANDLER_NAME,NAME)) \
+         fputs("_interrupt_handler",FILE);\
+      else\
+         assemble_name (FILE, NAME);\
+      fputs ("\n", FILE);\
+   }\
+\
+   assemble_name (FILE, NAME);\
+   fputs (":\n", FILE);\
+   if (interrupt_handler && strcmp(INTERRUPT_HANDLER_NAME,NAME))\
+      fputs ("_interrupt_handler:\n",FILE);\
+   \
+} while(0) 
+#endif
+
+#define GLOBAL_ASM_OP "\t.globl\t"
+
+#define MAX_OFILE_ALIGNMENT (32768*8)
+
+/* The following macro defines the format used to output the second
+   operand of the .type assembler directive.  Different svr4 assemblers
+   expect various different forms for this operand.  The one given here
+   is just a default.  You may need to override it in your machine-
+   specific tm.h file (depending upon the particulars of your assembler).  */
+
+#define TYPE_OPERAND_FMT        "@%s"
+
+/* Define the strings used for the special svr4 .type and .size directives.
+   These strings generally do not vary from one system running svr4 to
+   another, but if a given system (e.g. m88k running svr) needs to use
+   different pseudo-op names for these, they may be overridden in the
+   file which includes this one.  */
+
+#undef TYPE_ASM_OP
+#undef SIZE_ASM_OP
+#define TYPE_ASM_OP	"\t.type\t"
+#define SIZE_ASM_OP	"\t.size\t"
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries in an ELF object file under SVR4.  These macros also output
+   the starting labels for the relevant functions/objects.  */
+
+/* Write the extra assembler code needed to declare an object properly.  */
+
+#undef ASM_DECLARE_OBJECT_NAME
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
+  do {									\
+    fprintf (FILE, "%s", TYPE_ASM_OP);			         	\
+    assemble_name (FILE, NAME);						\
+    putc (',', FILE);							\
+    fprintf (FILE, TYPE_OPERAND_FMT, "object");				\
+    putc ('\n', FILE);							\
+    size_directive_output = 0;						\
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))		\
+      {									\
+	size_directive_output = 1;					\
+	fprintf (FILE, "%s", SIZE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	fprintf (FILE, ",%d\n",  int_size_in_bytes (TREE_TYPE (DECL)));	\
+      }									\
+    microblaze_declare_object (FILE, NAME, "", ":\n", 0);			\
+  } while (0)
+
+/* Output the size directive for a decl in rest_of_decl_compilation
+   in the case where we did not do so before the initializer.
+   Once we find the error_mark_node, we know that the value of
+   size_directive_output was set
+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */
+
+#undef ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	 \
+do {									 \
+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);			 \
+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		 \
+         && ! AT_END && TOP_LEVEL					 \
+	 && DECL_INITIAL (DECL) == error_mark_node			 \
+	 && !size_directive_output)					 \
+       {								 \
+	 size_directive_output = 1;					 \
+	 fprintf (FILE, "%s", SIZE_ASM_OP);			         \
+	 assemble_name (FILE, name);					 \
+	 fprintf (FILE, ",%d\n", int_size_in_bytes (TREE_TYPE (DECL)));  \
+       }								 \
+   } while (0)
+
+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)                            \
+ do { fputc ( '\t', FILE);                                            \
+      assemble_name (FILE, LABEL1);                                   \
+      fputs ( " = ", FILE);                                           \
+      assemble_name (FILE, LABEL2);                                   \
+      fputc ( '\n', FILE);                                            \
+ } while (0)
+
+
+/* No support for weak in MicroBlaze. Hence commenting out this part */
+
+#define ASM_WEAKEN_LABEL(FILE,NAME) ASM_OUTPUT_WEAK_ALIAS(FILE,NAME,0)
+#define ASM_OUTPUT_WEAK_ALIAS(FILE,NAME,VALUE)	\
+  do {						\
+  fputs ("\t.weakext\t", FILE);		\
+  assemble_name (FILE, NAME);			\
+  if (VALUE)					\
+  {						\
+  fputc (' ', FILE);			\
+  assemble_name (FILE, VALUE);		\
+  }						\
+  fputc ('\n', FILE);				\
+  } while (0)
+
+
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+#undef UNIQUE_SECTION_P
+#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))
+
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION        default_elf_asm_named_section
+
+#undef TARGET_UNIQUE_SECTION
+#define TARGET_UNIQUE_SECTION microblaze_unique_section
+
+/* Define the strings to put out for each section in the object file.  
+   
+   Note: For ctors/dtors, we want to give these sections the SHF_WRITE attribute 
+   to allow shared libraries to patch/resolve addresses into these locations.
+   On Microblaze, there is no concept of shared libraries yet, so this is for
+   future use. */
+#define TEXT_SECTION_ASM_OP	"\t.text"	
+#define DATA_SECTION_ASM_OP	"\t.data"	
+#define READONLY_DATA_SECTION_ASM_OP    \
+                                "\t.rodata"
+#define BSS_SECTION_ASM_OP      "\t.bss"        
+#define CTORS_SECTION_ASM_OP    "\t.section\t.ctors,\"aw\""
+#define DTORS_SECTION_ASM_OP    "\t.section\t.dtors,\"aw\""
+#define INIT_SECTION_ASM_OP     "\t.section\t.init,\"ax\""
+#define FINI_SECTION_ASM_OP     "\t.section\t.fini,\"ax\""
+
+#define SDATA_SECTION_ASM_OP	"\t.sdata"	/* Small RW initialized data   */
+#define SDATA2_SECTION_ASM_OP	"\t.sdata2"	/* Small RO initialized data   */ 
+#define SBSS_SECTION_ASM_OP     "\t.sbss"       /* Small RW uninitialized data */
+#define SBSS2_SECTION_ASM_OP    "\t.sbss2"      /* Small RO uninitialized data */
+
+#define HOT_TEXT_SECTION_NAME   ".text.hot"
+#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \
+                                ".text.unlikely"
+
+#define READONLY_DATA_SECTION   rodata_section
+#define SDATA_SECTION           sdata_section
+#define READONLY_SDATA_SECTION  sdata2_section
+#define SBSS_SECTION            sbss_section
+#define READONLY_SBSS_SECTION   sbss2_section
+#define BSS_SECTION             bss_section
+
+/* A list of other sections which the compiler might be "in" at any
+   given time.  */
+#undef EXTRA_SECTIONS
+#define EXTRA_SECTIONS in_rodata, in_sdata, in_sdata2, in_sbss, in_sbss2, in_init, in_fini
+
+#undef EXTRA_SECTION_FUNCTIONS
+#define EXTRA_SECTION_FUNCTIONS                                                     \
+  SECTION_FUNCTION_TEMPLATE(rodata_section, in_rodata, READONLY_DATA_SECTION_ASM_OP)\
+  SECTION_FUNCTION_TEMPLATE(sdata_section,  in_sdata,  SDATA_SECTION_ASM_OP)        \
+  SECTION_FUNCTION_TEMPLATE(sdata2_section, in_sdata2, SDATA2_SECTION_ASM_OP)       \
+  SECTION_FUNCTION_TEMPLATE(sbss_section,   in_sbss,   SBSS_SECTION_ASM_OP)         \
+  SECTION_FUNCTION_TEMPLATE(sbss2_section,  in_sbss2,  SBSS2_SECTION_ASM_OP)        \
+  SECTION_FUNCTION_TEMPLATE(init_section,  in_init,  INIT_SECTION_ASM_OP)           \
+  SECTION_FUNCTION_TEMPLATE(fini_section,  in_fini,  FINI_SECTION_ASM_OP)        
+
+#define SECTION_FUNCTION_TEMPLATE(FN, ENUM, OP)                                 \
+void FN ()                                                                      \
+{                                                                               \
+  if (in_section != ENUM)                                                       \
+    {                                                                           \
+      fprintf (asm_out_file, "%s\n", OP);                                       \
+      in_section = ENUM;                                                        \
+    }                                                                           \
+}
+
+/* We do this to save a few 10s of code space that would be taken up
+   by the call_FUNC () wrappers, used by the generic CRT_CALL_STATIC_FUNCTION
+   definition in crtstuff.c */
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+    asm ( SECTION_OP "\n"                               \
+          "\tbralid   r15, " #FUNC "\n\t nop\n"         \
+          TEXT_SECTION_ASM_OP);
+
+/* #define CTOR_LIST_BEGIN                                 \ */
+/* asm (CTORS_SECTION_ASM_OP);                             \ */
+/* func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) } */
+ 
+/* #define CTOR_LIST_END                                   \ */
+/* asm (CTORS_SECTION_ASM_OP);                             \ */
+/* func_ptr __CTOR_END__[1] = { (func_ptr) 0 }; */
+ 
+/* #define DTOR_LIST_BEGIN                                 \ */
+/* asm (DTORS_SECTION_ASM_OP);                             \ */
+/* func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) } */
+
+/* #define DTOR_LIST_END                                   \ */
+/* asm (DTORS_SECTION_ASM_OP);                             \ */
+/* func_ptr __DTOR_END__[1] = { (func_ptr) 0 }; */
+
+/* Don't set the target flags, this is done by the linker script */
+#undef LIB_SPEC
+#define LIB_SPEC "%{!pg:%{!nostdlib:%{!Zxl-no-libxil:-start-group -lxil -lc -lm -end-group }}} %{pg:%{!nostdlib:-start-group -lxilprofile -lxil -lc -lm -end-group }} %{Zxl-no-libxil: %{!nostdlib: -start-group -lc -lm -end-group }}"        /* Xilinx: We need to group -lm as well, since some Newlib math functions reference __errno! */
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s crtn.o%s"
+
+
+#define STARTFILE_EXECUTABLE_SPEC   "crt0.o%s crti.o%s crtbegin.o%s"
+#define STARTFILE_XMDSTUB_SPEC      "crt1.o%s crti.o%s crtbegin.o%s"
+#define STARTFILE_BOOTSTRAP_SPEC    "crt2.o%s crti.o%s crtbegin.o%s"
+#define STARTFILE_NOVECTORS_SPEC    "crt3.o%s crti.o%s crtbegin.o%s"
+#define STARTFILE_XILKERNEL_SPEC    "crt4.o%s crti.o%s crtbegin.o%s"
+#define STARTFILE_CRTINIT_SPEC      "%{!pg: %{!mno-clearbss: crtinit.o%s} %{mno-clearbss: sim-crtinit.o%s}} \
+                                     %{pg: %{!mno-clearbss: pgcrtinit.o%s} %{mno-clearbss: sim-pgcrtinit.o%s}}"
+
+
+#define STARTFILE_DEFAULT_SPEC      STARTFILE_EXECUTABLE_SPEC
+
+
+#undef SUBTARGET_EXTRA_SPECS
+#define	SUBTARGET_EXTRA_SPECS						\
+  { "startfile_executable",	STARTFILE_EXECUTABLE_SPEC },		\
+  { "startfile_xmdstub",	STARTFILE_XMDSTUB_SPEC },		\
+  { "startfile_bootstrap",	STARTFILE_BOOTSTRAP_SPEC },		\
+  { "startfile_novectors",	STARTFILE_NOVECTORS_SPEC },		\
+  { "startfile_xilkernel",	STARTFILE_XILKERNEL_SPEC },		\
+  { "startfile_crtinit",        STARTFILE_CRTINIT_SPEC },               \
+  { "startfile_default",	STARTFILE_DEFAULT_SPEC },		
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC  "\
+%{Zxl-mode-executable   : %(startfile_executable)  ; \
+  Zxl-mode-xmdstub      : %(startfile_xmdstub)     ; \
+  Zxl-mode-bootstrap    : %(startfile_bootstrap)   ; \
+  Zxl-mode-novectors    : %(startfile_novectors)   ; \
+  Zxl-mode-xilkernel    : %(startfile_xilkernel)   ; \
+                        : %(startfile_default)       \
+} \
+%(startfile_crtinit)"
+
-- 
1.5.3.8

